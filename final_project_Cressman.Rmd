---
title: "BMIN503 Final Project: Predicting SARS-CoV-2 Cases in the Delaware Valley Region"
author: "Leigh Cressman"
date: '`r format(Sys.time(), "%B %d, %Y")`'
output: 
  html_document:
    theme: paper 
    highlight: tango
---
```{r set-options, echo=FALSE, cache=FALSE}
options(width = 400)
```  
***

### Overview
This analysis seeks to determine how changes in community mobility, SARS-CoV-2 variants, and vaccination relate to weekly changes in SARS-CoV-2 case incidence at the county level. Vaccination prevalence and case incidence data are publicly available on the website of the Center for Disease Control and Prevention (CDC). Community mobility data is captured using Google's county-level COVID-19 Community Mobility Reports. SARS-CoV-2 variant data is from a study led by Dr. Brendan Kelly and Dr. Rick Bushman in PSOM involving metagenomic viral whole genome sequencing (WGS) performed on COVID-19 tests from Penn Medicine clinical laboratories (1, 2). This analysis is based on a sub-aim of the aforementioned study, and I have received ongoing guidance for this project from Dr. Kelly.

### Introduction 
Since the start of the SARS-CoV-2 pandemic, scientists have been developing statistical models to predict various epidemiologic outcomes in different areas of the world. This analysis seeks to contribute to that knowledge base by examining how changes in community mobility, vaccine prevalence, and SARS-CoV-2 variants are related to weekly changes in case incidence in Philadelphia and the surrounding counties. As Google social mobility data is available starting February 15, 2020, the analysis spans from then through October 2, 2021, using week as time intervals. The above-referenced study in PSOM randomly samples SARS-CoV-2 positive specimens collected at UPHS facilities with cycle threshold (Ct) values < 30. Whole genome sequencing is performed on these specimens, which have higher viral loads, to identify the lineage. The results of WGS are used as an additional explanatory variable in this analysis to indicate the dominant variant circulating in the greater Philadelphia metropolitan area during the study period.  

This analysis draws upon microbiology for the identification of SARS-CoV-2 variants, and infectious disease epidemiology, biostatistics, and informatics to analyze and interpret the relationship between dominant SARS-CoV-2 variants, vaccination, and change in case incidence. In addition, this analysis incorporates the behavioral sciences, as it seeks to identify whether social behavior (i.e., community mobility data) is associated with case incidence. 

One particular difficulty I had in the initial phase of this analysis was data harmonization. I examined a plethora of datasets from the CDC, the Pennsylvania Department of Health, Google, and OpenDataPhilly before I was able to find data that covered the time span and geographic areas of interest. My discussion with Dr. John Holmes was especially helpful for finalizing the data harmonization aspect of my project. He explained that if I were trying to publish this project, I would need express written permission from the CDC to link their data to other data sources. However, for a class project, it is fine to link the data to other sources without obtaining permission.

I spoke with Dr. Joe Romano from DBEI to discuss my questions regarding the logistic regression component of the analysis. Specifically, I was thinking about logistic regression in terms of traditional statistical modeling versus machine learning. I asked him whether I should only include predictor variables in the machine learning model if they are individually significantly associated with the outcome in the univariate models. I also asked about the necessity of checking for multicollinearity among predictor variables. Joe explained that when building a logistic regression model in a machine learning context, we are less concerned with predictors being significant, or whether there are interactions among the features. The goal is to make a highly performant model, rather than have a precise understanding of how individual features contribute to the outcome variable. I found this especially interesting, as all of my experience to-date is using logistic regression to perform traditional statistical modeling. Joe added that multicollinearity is not usually tested in real-world machine learning, and a good machine learning model should be able to deal with complex interactions among features. I discussed this topic further with Dr. Brendan Kelly, an infectious disease physician, and concluded that for this analysis, I am primarily interested in using logistic regression within an epidemiological context to understand the relationship between explanatory variables and the outcome.

Finally, I contacted Dr. Sherrie Xie, in geographic epidemiology, to gain insights on creating maps to effectively compare the changes in the study variables over time and by county. Specifically, I wanted to use gganimate to animate county-level maps of the Philadelphia area. Ultimately, because there was not a great deal of variation among the counties in the study, I decided a geographic component was not suitable for this project.

[My final project GitHub repository can be accessed here.](https://github.com/LeighCressman/BMIN503_Final_Project)


### Methods
#### Data Cleaning and Transformation
The majority of the data for this analysis is publicly available via the Internet. 
[The county-level vaccination data is on the CDC website and can be accessed via the Socrata Open Data API (SODA).](https://data.cdc.gov/Vaccinations/COVID-19-Vaccinations-in-the-United-States-County/8xkx-amqh). The CDC's county-level case data is not accessible through SODA, but can be downloaded manually from the [CDC's COVID Data Tracker page](https://covid.cdc.gov/covid-data-tracker).
To obtain county-level time-series case data, each county must be selected individually and downloaded. Google Community Mobility Reports are available for [2020](https://www.gstatic.com/covid19/mobility/2020_US_Region_Mobility_Report.csv) and [2021](https://www.gstatic.com/covid19/mobility/2021_US_Region_Mobility_Report.csv).

The counties of interest in this analysis are:   
1. PA: Bucks, Chester, Delaware, Montgomery, Philadelphia  
2. NJ: Burlington, Camden, Gloucester, Mercer   
3. DE: New Castle

Each dataset (CDC vaccine, CDC case, and Google community mobility) contains county-level time-series data with days as the interval. This analysis increments time in weeks, which are defined by the Morbidity and Mortality Weekly Report (*MMWR*). The *MMWR* week is used by the CDC to standardize the reporting of weekly data. Values range from 1 through 53, and Sunday is the first day of any *MMWR* week (3). The county-level data in each dataset is aggregated by *MMWR* week, using MMWRweek::MMWRweek. The study begins with *MMWR* week 2020-07 (mid-February 2020) and ends with week 2021-39 (early October 2021, at the end of a full *MMWR* week). 

#### Vaccination Data
As previously mentioned, the vaccination data for this study comes from the CDC website. While these data were pulled through the API during the testing phase, due to the need for login credentials to access the API, the relevant vaccination file has been included in the GitHub repository. The file exceeded GitHub's size limit, so it has been restricted to observations in Pennsylvania, New Jersey, and Delaware in a previous step. 

The CDC includes multiple vaccination point prevalence variables which are used in this analysis:   
 **Percent of people who are fully vaccinated** (have second dose of a two-dose vaccine or one dose     of a single-dose vaccine) based on the jurisdiction and county where the recipient lives   
 **Total number of people who are fully vaccinated** (have second dose of a two-dose vaccine or one     dose of a single-dose vaccine) based on the jurisdiction and county where recipient lives (4).   
The CDC includes all age groups in the vaccination data in order to give a better measure of community immunity (5).

With regard to vaccines, the investigators leading this study are interested in the relationship between vaccination point prevalence and case change, as they hypothesize that vaccination affects disease transmission as a function of point prevalence. Out of personal interest, I used the available point prevalence data to create a variable for vaccine incidence.

The Google Community Mobility Reports date back to February 15, 2020. CDC vaccination data does not report fully vaccinated individuals prior to January 2021. Therefore, rows of zeros have been added to the vaccine data so that it could be merged with the social mobility dataset.  Prior to joining on county and *MMWR* week, the vaccination variables were grouped by county and *MMWR* week and averaged.

Vaccine incidence and vaccine prevalence have been adjusted for county population (based on estimates from the 2019 U.S. Census) and standardized (base::scale) prior to being included as independent variables in regression models. As mean vaccine incidence and mean vaccine prevalence are expressed as a rate per 100,000 people per week, they are by definition _vaccine incidence density_ and _vaccine prevalence density_, respectively.


#### Google's COVID-19 Community Mobility Reports
Google has created publicly available datasets to reflect how community activity has changed throughout the pandemic. Daily activity is measured in percent change from baseline. Baseline is defined as the median value of the corresponding day of the week over the period from January 3, 2020, through February 6, 2020 (6).

Google created categories of community mobility based on their relevance to social distancing efforts and access to essential services. Mobility trends are available for the following places:  
1. Grocery and pharmacy  
2. Parks  
3. Transit stations  
4. Retail and recreation  
5. Residential  
6. Workplaces  

County-level data are available for each day, so these variables have been aggregated by county and MMWR week and averaged before being joined to vaccination and case data on county and week. The resulting values for Google mobility data in this analysis are mean percent change from baseline.

The variables for parks and transit stations contain missing values. This is the result of activity being too low upon a specific day and therefore not achieving the anonymity threshold set by Google (7). Multiple methods were considered for dealing with missing data. As the suppressed cells are related to low activity, missing values are dealt with by identifying the minimum absolute value by county and replacing corresponding NAs with the resulting value.


#### Whole Genome Sequencing Data
The SARS-CoV-2 variant data used in this analysis consists of 2,934 samples which were sequenced in the Bushman lab at Penn between January and September 2021. The lineage designation of the genomes is based on the CDC definition (8), and two binary indicator variables are created using different methods to indicate the pre-delta and post-delta period:  
1. first_delta - starts when the first delta variant is identified in the study: 2021-15 (week ending April 17, 2021)  
2. dominant_delta - starts when delta makes up >=50% of samples in study: 2021-25 (week ending June 26, 2021) 


#### SARS-CoV-2 Case Data
County-level time-series case data can be accessed through the CDC's COVID Data Tracker website. The CDC reports the 7-day rolling average of new cases per 100,000 people based on 2019 U.S. Census estimates (9). 

As CDC case data did not exist for the Delaware Valley Region prior to March 2020, and Google social mobility data begins in February 2020, rows of zeros were added to case data so that it could be merged with social mobility and vaccine data, joining on county and *MMWR* week. 

Each county in the CDC case dataset contains suppressed cells. This is due to case numbers falling below the required reporting threshold in the first weeks of the pandemic. Therefore, similar to the approach used for missing values in Google social mobility data, the data were grouped by county, and the minimum observed case value per county was selected to replace the missing data. Of note, 0 values were not included when identifying the minimum number of cases per county.

Similar to vaccine prevalence and incidence data, case numbers per 100,000 people are grouped by county and *MMWR* week and averaged, thus creating a variable for case incidence density. To deal with the time-series component of this analysis, a binary outcome variable based on case incidence density is used to identify whether there is an increase in next week's value compared to the current week. To create the binary outcome variable, dplyr::lead retrieves next week's case incidence density. This value is compared to the current week's value, and the result is 1 = increase, 0 = no increase.


``` {r, eval = TRUE, message = FALSE}

################################################
################################################
# Create dataset for BMIN503 analysis
################################################
################################################

# load libraries
library(tidyverse)
library(lubridate)
library(MMWRweek)
library(data.table)
library(RSocrata)
library(magrittr)
library(ggplot2)
library(broom)
library(GGally)
library(tibble)
library(pROC)
library(car)
library(gtsummary)
library(patchwork)
library(stringr)
library(viridis)
library(gganimate)
library(gifski)


##########################
##########################
# Explanatory variables
##########################
##########################

############################
# county-level vaccine data
############################

# import CDC county-level vaccination data for PA, NJ, and DE
cdc_vacc <- read_csv("cdc_vacc_pa_nj_de.csv")

# filter and reformat data
coun_name <- "phila|bucks|chester|montgom|dela|camden|burlin|glouc|new castle" # counties of interest
cdc_coun <- cdc_vacc %>%
  filter(recip_county %ilike% coun_name | (recip_state == "NJ" & 
                                                recip_county %ilike% "Mercer")) %>%
  mutate(series_complete_yes = as.numeric(series_complete_yes),
         date = date %>% ymd_hms) %>%
  mutate(MMWRweek(date)) %>% # convert date to MMWR week
  rename_at(.vars = vars(contains("MMWR")), .funs = ~ gsub("mmwr", "mmwr_",
                                                           tolower(.x))) %>%
  mutate(year_week = ifelse(mmwr_week < 10, paste0(mmwr_year, " - ", "0", mmwr_week),
                            paste0(mmwr_year, " - ", mmwr_week))) %>% 
  rename(fully_vaccinated = series_complete_yes,
         fully_vacc_per_pop = series_complete_pop_pct) %>%
  arrange(recip_county, desc(date)) %>%
  mutate(new_vaccinations = fully_vaccinated) %>%
  select(date, recip_county, fully_vacc_per_pop, fully_vaccinated, 
         new_vaccinations, year_week) 


# transform vaccine point prevalence data into time-series data
counties <- c("Philadelphia County", "Bucks County",
              "Chester County", "Delaware County",
              "Montgomery County", "Burlington County",
              "Gloucester County", "Camden County", 
              "Mercer County", "New Castle County")


# subtract yesterday's vaccine numbers from today to get n of new vaccinations 
county_new <- data.frame()
for (county in counties) {
  county_data <- cdc_coun %>% filter(recip_county == county)
  for (i in 1:nrow(county_data) - 1) {
    county_data$new_vaccinations[i] = county_data$fully_vaccinated[i] - county_data$fully_vaccinated[i + 1] 
    } 
  county_new <- rbind(county_new, county_data)
}


# aggregate vaccine data by county and MMWR week 
county_agg <- county_new %>% 
  filter(between(date, "2020-02-14", "2021-10-09")) %>%
  group_by(recip_county, year_week) %>%
  summarize(vacc_incidence_n = mean(new_vaccinations), #mean new fully vaccinated individuals               
            mean_per_pop_fully_vacc = mean(fully_vacc_per_pop), # per pop fully vaccinated 
            mean_fully_vacc_n = mean(fully_vaccinated)) %>% # mean cum. fully vaccinated
  arrange(recip_county, year_week)


##############################
# Google social mobility data
##############################

import_google <- function(url) { # function to read and filter data from URLs
  df <- read_csv(url, col_types = cols(.default = col_character())) %>%
    filter(sub_region_1 %in% c("Pennsylvania", "New Jersey", "Delaware"))
  return(df)
}

# get data from 2020 and 2021 mobility reports
url1 <- "https://www.gstatic.com/covid19/mobility/2020_US_Region_Mobility_Report.csv"
url2 <- "https://www.gstatic.com/covid19/mobility/2021_US_Region_Mobility_Report.csv"

# combine dfs into one
google_df <- bind_rows(import_google(url1), import_google(url2))

# filter and reformat Google data
coun_g <- google_df %>% mutate(date = date %>% ymd) %>%
  filter(between(date, "2020-02-14", "2021-10-09") &
    (sub_region_2 %ilike% coun_name | (sub_region_1 == "New Jersey" & 
                                     sub_region_2 %ilike% "Mercer County"))) %>%
  mutate(MMWRweek(date)) %>% # convert date to MMWR week
  rename_at(.vars = vars(contains("MMWR")), .funs = ~ gsub("mmwr", "mmwr_",
                                                           tolower(.x))) %>%
  mutate(year_week = ifelse(mmwr_week < 10, paste0(mmwr_year, " - ", "0", mmwr_week),
                            paste0(mmwr_year, " - ", mmwr_week))) %>%
  select(sub_region_2, year_week, 
         retail_and_recreation_percent_change_from_baseline,
         grocery_and_pharmacy_percent_change_from_baseline,
         parks_percent_change_from_baseline,
         transit_stations_percent_change_from_baseline,
         workplaces_percent_change_from_baseline,
         residential_percent_change_from_baseline) %>%
  arrange(sub_region_2, year_week)

# calculate mean social mobility score by week
coun_g[3:8] <- sapply(coun_g[3:8], as.numeric) # convert social mobility vars to numeric

google_week <- coun_g %>% 
  rename(retail_rec = retail_and_recreation_percent_change_from_baseline,
         grocery_pharm = grocery_and_pharmacy_percent_change_from_baseline,
         parks = parks_percent_change_from_baseline,
         transit_stations = transit_stations_percent_change_from_baseline,
         workplaces = workplaces_percent_change_from_baseline,
         residential = residential_percent_change_from_baseline) %>%
  group_by(sub_region_2, year_week) %>%
  summarize(across(everything(), mean, na.rm = TRUE, # compute mean for each col
                   .names = "mean_{.col}")) %>% # add "mean" to each col name
  arrange(sub_region_2, year_week)
  
# identify counties with missing data
google_miss <- google_week %>%
  filter(mean_parks == "NaN" | mean_transit_stations == "NaN")

# identify minimum absolute value of observed values for each county
coun_min <- google_week %>% filter(mean_parks != "NaN",
                                   mean_transit_stations != "Nan") %>%
  mutate(mean_parks = abs(mean_parks),
         mean_transit_stations = abs(mean_transit_stations)) %>%
  group_by(sub_region_2) %>%
  summarize(parks_min = min(mean_parks),
            transit_min = min(mean_transit_stations))

# replace NAs with county-level minimum absolute value
google_na <- google_week %>% 
  mutate(mean_parks = ifelse(sub_region_2 == "Bucks County" & 
                                 mean_parks == "NaN", 0.5714286,
                      ifelse(sub_region_2 == "Burlington County" &
                                 mean_parks == "NaN", 0.0000000,
                      ifelse(sub_region_2 == "Camden County" &
                                 mean_parks == "NaN", 0.0000000,
                      ifelse(sub_region_2 == "Chester County" &
                                 mean_parks == "NaN", 0.8571429,
                      ifelse(sub_region_2 == "Delaware County" &
                                 mean_parks == "NaN", 0.5714286,
                      ifelse(sub_region_2 == "Gloucester County" &
                                 mean_parks == "NaN", 3.4285714,
                      ifelse(sub_region_2 == "Mercer County" & 
                                 mean_parks == "NaN", 1.7142857,
                      ifelse(sub_region_2 == "Montgomery County" &
                                 mean_parks == "NaN", 0.5714286,
                      ifelse(sub_region_2 == "New Castle County" &
                                 mean_parks == "NaN", 1.4285714,
                      ifelse(sub_region_2 == "Philadelphia County" &
                                 mean_parks == "NaN", 0.5714286, mean_parks))))))))))) %>%
  mutate(mean_parks = as.numeric(mean_parks)) %>%
  mutate(mean_transit_stations = ifelse(sub_region_2 == "Bucks County" & 
                                 mean_transit_stations == "NaN", 1.0000000,
                       ifelse(sub_region_2 == "Chester County" & 
                                 mean_transit_stations == "NaN", 2.1428571,
                       ifelse(sub_region_2 == "Gloucester County" &
                                 mean_transit_stations == "NaN", 1.7142857, mean_transit_stations)))) %>%
  mutate(mean_transit_stations = as.numeric(mean_transit_stations))


################################################
# combine vaccine and social mobility data
################################################

# Add rows of 0s for vaccination variables prior to MMWR week 2020-51
add_vacc <- coun_g %>% distinct(sub_region_2, year_week) %>%
  filter(between(year_week, "2020 - 07", "2020 - 50")) %>%
  rename(recip_county = sub_region_2) %>%
  mutate(vacc_incidence_n = 0,
         mean_per_pop_fully_vacc = 0,
         mean_fully_vacc_n = 0)
  
all_vacc <- add_vacc %>% bind_rows(county_agg) %>%
  arrange(recip_county, year_week)

# join vaccine and Google social mobility data on county and MMWR week
explan <- all_vacc %>% 
  inner_join(google_na, by = c("recip_county" = "sub_region_2",
                                 "year_week" = "year_week")) %>%
  arrange(recip_county, year_week)


#####################################
# Whole genome sequencing (WGS) data
#####################################

# import pre-processed WGS data containing
# binary indicator variables to define pre-delta and post-delta period
wgs <- read_csv("wgs_dominant_variant.csv") %>%
  mutate(first_delta = as.factor(first_delta), 
         dominant_delta = as.factor(dominant_delta)) 
wgs$first_delta <- relevel(wgs$first_delta, ref = "Pre-delta")
wgs$dominant_delta <- relevel(wgs$dominant_delta, ref = "Pre-delta")  

# join WGS data to other explanatory variables
explan <- explan %>% inner_join(wgs, by = c("recip_county" = "recip_county",
                                            "year_week" = "year_week")) 
  


#############################################
#############################################
# Outcome data
# Case data by county
# one file for each county (10 total)
# downloaded from CDC website
#############################################
#############################################

# import and combine all CDC case files
case_files <- list.files(pattern = "cdc_cases.*\\.csv") 
cdc_case_data <- rbindlist(sapply(case_files, fread, simplify = FALSE),
                           use.names = TRUE) 

# filter and reformat case data
clean_case <- cdc_case_data %>% rename(state = "State Abbreviation",
                                  county = "County",
                                  cases_7d_avg = "Cases 7-day rolling average",
                                  date = "Date") %>%
  mutate(date = date %>% mdy) %>%
  filter(between(date, "2020-02-15", "2021-10-09")) %>%
  mutate(MMWRweek(date)) %>% # convert date to MMRW week
  rename_at(.vars = vars(contains("MMWR")), .funs = ~ gsub("mmwr", "mmwr_",
                                                           tolower(.x))) %>%
  mutate(year_week = ifelse(mmwr_week < 10, paste0(mmwr_year, " - ", "0", mmwr_week),
                            paste0(mmwr_year, " - ", mmwr_week))) %>%
  select(state, county, year_week, date, cases_7d_avg) %>%
  arrange(county, year_week)

# identify minimum number of cases for each county for replacing missing values
supp <- clean_case %>% filter(cases_7d_avg != "suppressed" &
                                cases_7d_avg != 0) %>%
  mutate(cases_7d_avg = as.numeric(cases_7d_avg)) %>%
  group_by(county) %>%
  summarize(min_val = min(cases_7d_avg))
supp

# replace suppressed cells with values from supp
case_na <- clean_case %>% 
  mutate(cases_7d_avg = ifelse(county == "Bucks County" & 
                                 cases_7d_avg == "suppressed", 1.42857,
                        ifelse(county == "Burlington County" &
                                 cases_7d_avg == "suppressed", 1.57143,
                        ifelse(county == "Camden County" &
                                 cases_7d_avg == "suppressed", 1.42857,
                        ifelse(county == "Chester County" &
                                 cases_7d_avg == "suppressed", 1.42857,
                        ifelse(county == "Delaware County" &
                                  cases_7d_avg == "suppressed", 1.85714,
                        ifelse(county == "Gloucester County" &
                                 cases_7d_avg == "suppressed", 1.85714,
                        ifelse(county == "Mercer County" & 
                                 cases_7d_avg == "suppressed", 2.14286,
                        ifelse(county == "Montgomery County" &
                                 cases_7d_avg == "suppressed", 1.85714,
                        ifelse(county == "New Castle County" &
                                 cases_7d_avg == "suppressed", 2.14286,
                        ifelse(county == "Philadelphia County" &
                                 cases_7d_avg == "suppressed", 2.28571, cases_7d_avg))))))))))) %>%
  mutate(cases_7d_avg = as.numeric(cases_7d_avg))

# calculate mean of 7-day rolling case average by county and week
weekly_case <- case_na %>% group_by(county, year_week) %>%
  summarize(case_mean = mean(cases_7d_avg)) %>%
  arrange(county, year_week)

# transform data to get case_mean for next week
# so that this week can be compared to next week
next_case <- weekly_case %>%
  ungroup() %>%
  mutate(next_week_mean = lead(case_mean, 1), # return next week's value
         next_week_mean = replace_na(next_week_mean, 0))
           
# add county population data to case data
all_coun <- read_csv("all_counties_population.csv")
next_case_fi <- next_case %>% inner_join(all_coun, by = "county")


###############################################
# combine explanatory and outcome variables
# to create complete data set for analysis
###############################################
full_df <- next_case_fi %>% mutate(county_pop = population) %>%
  inner_join(explan, by = c("county" = "recip_county",
                            "year_week" = "year_week")) %>%
  mutate(vacc_incidence_per100thou = vacc_incidence_n / county_pop * 100000, # adjust by county population
         case_mean_per100thou = case_mean, 
         next_week_per100thou = next_week_mean, 
         vacc_prevalence_per100thou = mean_fully_vacc_n / county_pop * 100000, # adjust by county population
         next_week_increase = ifelse(next_week_per100thou > case_mean_per100thou, 1, 0)) %>% 
  select(county, year_week, case_mean, case_mean_per100thou, next_week_mean,
         next_week_per100thou, next_week_increase, vacc_incidence_n,
         vacc_incidence_per100thou, mean_per_pop_fully_vacc, mean_fully_vacc_n, 
         vacc_prevalence_per100thou, first_delta, dominant_delta, mean_retail_rec, mean_grocery_pharm, mean_parks, 
         mean_transit_stations, mean_workplaces, mean_residential) %>%
  arrange(county, year_week) %>%
  filter(year_week != "2021 - 40") # this is first week of October; it was needed for 
                                   # comparing the final week of the study (2021-39) to 
                                   # next week, but it will not be included in analysis

```

#### Descriptive Analysis

After finalizing the analysis dataset, several data quality checks are performed. Specifically, we verify that the dataset contains the expected number of rows, and the start and end dates of the study are correct.

We then note that of the 860 observations in the dataset, 440 saw an increase in cases in the next week, and 420 did not see an increase.


``` {r, eval = TRUE, message = FALSE}

########################################################
########################################################
               # Descriptive Analysis
########################################################
########################################################

# convert outcome variable to factor
covid <- full_df %>%
  mutate(next_week_increase = factor(next_week_increase,
                                     levels = c(0, 1),
                                     labels = c("No increase", "Increase")))

# view data
glimpse(covid)

# check that each county has 86 rows
table(covid$county)

# check min and max year_week
min(covid$year_week) # 2020-07
max(covid$year_week) # 2021-39

# next week increase or no increase 
table(covid$next_week_increase) # split is close to 50/50

```

Next, we look at the three vaccination independent variables to determine how the "increase" and "no increase" groups compare.


``` {r, eval = TRUE, message = FALSE}

#################################
# outcome variable x vaccination 
#################################

# view summary stats of vaccine vars - overall
summary_df <- covid %>%
  select(mean_per_pop_fully_vacc, vacc_prevalence_per100thou,
         vacc_incidence_per100thou) %>%
  psych::describe(quant=c(.25,.75)) %>%
  as_tibble(rownames="rowname")  %>%
  select(-vars, -trimmed, -mad, -range, -skew, -kurtosis, -se) %>%
  select(rowname, n, min, Q0.25, median, Q0.75, max, mean, sd) 
summary_df

```

``` {r, eval = TRUE, message = FALSE}

# observations with increase
summary_inc <- covid %>% filter(next_week_increase == "Increase") %>%
  select(mean_per_pop_fully_vacc, vacc_prevalence_per100thou,
         vacc_incidence_per100thou) %>%
  psych::describe(quant=c(.25,.75)) %>%
  as_tibble(rownames="rowname")  %>%
  select(-vars, -trimmed, -mad, -range, -skew, -kurtosis, -se) %>%
  select(rowname, n, min, Q0.25, median, Q0.75, max, mean, sd) 
summary_inc

```

``` {r, eval = TRUE, message = FALSE}

# observations with no increase
summary_noinc <- covid %>% filter(next_week_increase == "No increase") %>%
  select(mean_per_pop_fully_vacc, vacc_prevalence_per100thou,
         vacc_incidence_per100thou) %>%
  psych::describe(quant=c(.25,.75)) %>%
  as_tibble(rownames="rowname")  %>%
  select(-vars, -trimmed, -mad, -range, -skew, -kurtosis, -se) %>%
  select(rowname, n, min, Q0.25, median, Q0.75, max, mean, sd) 
summary_noinc

```
Interestingly, we observe that in the group that has an increase in next week's case incidence density, the means of the prevalence-related vaccination variables are higher ((1) percent of population which are fully vaccinated: mean = 16.13% in "increase" group vs. 13.71% in "no increase" group; and (2) vaccination prevalence per 100,000 population: mean = 16131.71 (increase group) vs. 13714.27 (no increase group)). Please note that these two vaccination variables are essentially the same, just on different scales.

We expected that the group which did not have an increase in mean cases in the following week would have higher means for these two vaccination variables. 

When examining the vaccine incidence variable, we see the results we would expect: vaccine incidence densities are 122.77 and 74 in the "no increase"  and "increase" groups, respectively.

The above findings are visualized in the boxplots below.

``` {r, eval = TRUE, message = FALSE, fig.width=10, fig.height=10}

# boxplot for mean percentage of population fully vaccinated by outcome
box1 <- ggplot(data = covid, aes(x = next_week_increase, y = mean_per_pop_fully_vacc)) +
  geom_boxplot(color = "magenta4", fill = "thistle") +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 12)) +
  xlab("Outcome: Next Week's SARS-CoV-2 Cases") +
  ylab("Percent of Population Fully Vaccinated") +
  labs(title = "Vaccination by Outcome Group") 
  

# boxplot for mean vaccine prevalence density by outcome
box2 <- ggplot(data = covid, aes(x = next_week_increase, y = vacc_prevalence_per100thou)) +
  geom_boxplot(color = "darkorchid4", fill = "mediumpurple2") +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 12)) +
  xlab("Outcome: Next Week's SARS-CoV-2 Cases") +
  ylab("Vaccine Prevalence Density") +
  labs(title = "Vaccination by Outcome Group") 


# boxplot for mean vaccine incidence density by outcome
box3 <- ggplot(data = covid, aes(x = next_week_increase, y = vacc_incidence_per100thou)) +
  geom_boxplot(color = "darkblue", fill = "plum3") +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 12)) +
  xlab("Outcome: Next Week's SARS-CoV-2 Cases") +
  ylab("Vaccine Incidence Density") +
  labs(title = "Vaccination by Outcome Group") 



(box1 + box2) / box3 + plot_layout(guides = "collect")  


```

#### Additional Time-Series Plots
Based on the above findings, the temporal relationship between vaccine incidence density and case incidence density is further analyzed. The investigators hypothesized that vaccine prevalence density would be significantly associated with change in case incidence density. However, vaccine incidence density (standardized form) was identified as significant at p < 0.05 in the univariate modeling stage, while vaccine prevalence density was not.

``` {r, eval = TRUE, message = FALSE}

# reformat df for plots
stopwords <- "County" # remove "County" from county name
covid$County <- gsub(paste(stopwords, collapse="|"), "", covid$county) 

# create numeric year_week variable for gganimate
covid_time <- covid %>% 
  mutate(yearweek_num = as.numeric(paste0(substr(year_week, 1, 4), substr(year_week, 8, 9))))

# vaccine plot
vacc_plot <- ggplot(covid_time, aes(x = year_week, y = vacc_incidence_per100thou, 
                                    color = County, group = County)) +
  geom_line(size = 1) + 
  scale_color_viridis(discrete = TRUE) + 
  theme_bw() +
    theme(
          plot.title = element_text(size=rel(1.2), hjust = 0.5, lineheight=.9, face="bold", colour="black"),
          axis.title.x = element_text(size=11, lineheight=.9, face="bold", colour="black"),
          axis.title.y = element_text(size=11, lineheight=.9, face="bold", colour="black"),
          axis.text.x = element_text(colour="black", angle = 60, hjust = 1.00),
          axis.text.y = element_text(colour="black"),
          legend.title = element_text(), 
          legend.text = element_text(size = 10)) +
  labs(title = "SARS-CoV-2 Vaccination Incidence in the Delaware Valley", 
       x = "MMWR Week", 
       y = "Mean Vaccination Incidence per 100,000 People") +
  scale_y_continuous(expand = c(0, 0), limit = c(0, 800)) +
  scale_x_discrete(labels = c("2020-07", "", "", "", "", "", "", "2020-14", "", "",
                              "", "", "", "", "2020-21", "", "", "", "", "", "",
                              "2020-28", "", "", "", "", "", "", "2020-35", 
                              "", "", "", "", "", "", "2020-42", "", "", "", "", "", "",
                              "2020-49", "", "", "", "", "", "", "2021-03", "", "", "", 
                              "", "", "", "2021-10", "", "", "", "", "", "", "2021-17",
                              "", "", "", "", "", "", "2021-24", "", "", "", "", "", "",
                              "2021-31", "", "", "", "", "", "", "", "2021-39"))


# case plot
case_plot <- ggplot(covid_time, aes(x = year_week, y = case_mean_per100thou, 
                                    color = County, group = County)) +
  geom_line(size = 1) + 
  scale_color_viridis(discrete = TRUE) + 
  theme_bw() +
    theme(
          plot.title = element_text(size=rel(1.2), hjust = 0.5, lineheight=.9, face="bold", colour="black"),
          axis.title.x = element_text(size=11, lineheight=.9, face="bold", colour="black"),
          axis.title.y = element_text(size=11, lineheight=.9, face="bold", colour="black"),
          axis.text.x = element_text(colour="black", angle = 60, hjust = 1.00),
          axis.text.y = element_text(colour="black"),
          legend.title = element_text(), 
          legend.text = element_text(size = 10)) +
  labs(title = "SARS-CoV-2 Case Incidence in the Delaware Valley", 
       x = "MMWR Week", 
       y = "Mean Case Incidence per 100,000 People") +
  scale_y_continuous(expand = c(0, 0), limit = c(0, 1110)) +
  scale_x_discrete(labels = c("2020-07", "", "", "", "", "", "", "2020-14", "", "",
                              "", "", "", "", "2020-21", "", "", "", "", "", "",
                              "2020-28", "", "", "", "", "", "", "2020-35", 
                              "", "", "", "", "", "", "2020-42", "", "", "", "", "", "",
                              "2020-49", "", "", "", "", "", "", "2021-03", "", "", "", 
                              "", "", "", "2021-10", "", "", "", "", "", "", "2021-17",
                              "", "", "", "", "", "", "2021-24", "", "", "", "", "", "",
                              "2021-31", "", "", "", "", "", "", "", "2021-39"))



```

First, we check the static vaccine incidence and case incidence plots.

```{r, eval = TRUE, message = FALSE, fig.width = 9, fig.height = 9}

vacc_plot / case_plot + plot_layout(guides = "collect")  


```

Next, we view animated versions of the vaccine incidence and case incidence plots.
```{r, eval = TRUE, message = FALSE}

animate_vacc <- vacc_plot + transition_reveal(covid_time$yearweek_num) 
animate(animate_vacc, height = 350, width = 600)

```

```{r, eval = TRUE, message = FALSE}

animate_case <- case_plot + transition_reveal(covid_time$yearweek_num) 
animate(animate_case, height = 350, width = 600)

```

We note a spike in vaccination incidence between *MMWR* week 13 and 17 (approximately April 3 through May 1, 2021), and a spike in cases in *MMWR* week 15 of 2021 (week ending Saturday, April 17). 

The SARS-CoV-2 vaccination opened up to all U.S. adults on April 19, 2021. It is possible that the availability of vaccines caused a surge in demand.

It should also be considered that a large increase in cases (i.e., the case spike in week 15) may predict vaccination incidence, rather than vaccine incidence predicting case incidence.




Finally, we plot the independent variables against each other, and against the outcome variable to identify existing relationships. 

``` {r, eval = TRUE, message = FALSE}

########################
# plot with ggpairs
########################

# limit dataframe to focus on specific predictor variables  
df_clean <- covid %>% filter(complete.cases(.)) %>%
  select(-county, -year_week, -case_mean, -case_mean_per100thou,
         -next_week_mean, -next_week_per100thou, -vacc_incidence_n,
         -vacc_incidence_per100thou, -mean_fully_vacc_n,
         -vacc_prevalence_per100thou, -first_delta, -dominant_delta) %>%
  rename(case_inc = next_week_increase,
         vacc = mean_per_pop_fully_vacc,
         retail = mean_retail_rec,
         groc = mean_grocery_pharm,
         park = mean_parks,
         trans = mean_transit_stations,
         work = mean_workplaces,
         res = mean_residential)

# compare all variables simultaneously
ggpairs(df_clean)

```

We note strong correlations (both negative and positive) between some pairs of variables. Additional tests will be executed to check for multicollinearity in the subsequent regression models.





#### Regression Analysis

The primary goal of this analysis is to identify how changes in community mobility, SARS-CoV-2 variants, and vaccination relate to weekly changes in SARS-CoV-2 case incidence using logistic regression. The next step in the analysis is to fit univariate statistical models to determine which variables are individually associated with case increase at a nominally significant level.

Prior to running the logistic regression models, vaccine incidence density and vaccine prevalence density are standardized. The motivation for this is that all other independent variables in the dataset are percentages, and there is concern about the magnitude of unstandardized vaccine incidence and prevalence affecting the regression coefficients.

``` {r, eval = TRUE, message = FALSE}

########################################################
########################################################
          # Logistic Regression Models
########################################################
########################################################

###############################################
# Fit univariate logistic regression models 
###############################################

# standardize vaccine variables 
covid$vacc_inc_per100thou_st <- scale(covid$vacc_incidence_per100thou, center = FALSE)
covid$vacc_prev_per100thou_st <- scale(covid$vacc_prevalence_per100thou, center = FALSE)

# drop unneeded variables
covid_clean <- covid %>% select(-county, -year_week,
                                -case_mean_per100thou, -case_mean,
                                -next_week_mean, -next_week_per100thou,
                                -vacc_incidence_n, -mean_fully_vacc_n) 

# generate multiple univariate models and save output to df
glm_output <- covid_clean %>%
  select(-next_week_increase, -vacc_incidence_per100thou,
         -vacc_prevalence_per100thou, -mean_per_pop_fully_vacc) %>%
  names() %>%
  paste("next_week_increase ~", .) %>%
  map_df(~tidy(glm(as.formula(.x), 
                   data = covid_clean, 
                   family = "binomial"), 
               estimate = TRUE,
               conf.int = TRUE, 
               exponentiate = TRUE)) %>%
  filter(term != "(Intercept)") %>%
  arrange(p.value) %>%
  rename("Odds Ratio" = estimate,
         Variable = term,
         "SE" = std.error,
         Statistic = statistic,
         "P-value" = p.value,
         "95% CI Lower" = conf.low,
         "95% CI Upper" = conf.high) %>%
  mutate(Variable = recode_factor(Variable,
                                  "dominant_deltaPost-delta" = "WGS: Delta-dominant Period",
                                  "first_deltaPost-delta" = "WGS: First Delta Cases",
                                  "vacc_inc_per100thou_st" = "Vaccine incidence density (st.)",
                                  "mean_retail_rec" = "Google: mean retail and recreation",
                                  "vacc_prev_per100thou_st" = "Vaccine prevalence density (st.)",
                                  "mean_grocery_pharm" = "Google: mean grocery and pharmacy",
                                  "mean_residential" = "Google: mean residential",
                                  "mean_parks" = "Google: mean parks",
                                  "mean_workplaces" = "Google: mean workplaces",
                                  "mean_transit_stations" = "Google: mean transit stations"))
glm_output


```

The above table shows that three of the independent variables are significantly associated with case increase:   
1. the WGS variable (defining pre-delta/post-delta based on when delta becomes the dominant variant in circulation)   
2. vaccine incidence density   
3. the social mobility variable for retail and recreation


Based on the above univariate analysis, a multivariate model is fit using the pre-delta/post-delta variable, vaccine incidence density, and retail and recreation. Table output is generated using gtsummary::tbl_regression. The model is checked for multicollinearity, which is not an issue.

``` {r, eval = TRUE, message = FALSE}

#####################################
# model using significant predictors
#####################################

# fit model
mod_one <- glm(next_week_increase ~ dominant_delta + vacc_inc_per100thou_st + mean_retail_rec,
                data = covid, family = "binomial")

# check model output
mod_table1 <- mod_one %>%
  tbl_regression(
    exponentiate = TRUE,
    label = list(dominant_delta ~ "Delta Dominant Period",
                  vacc_inc_per100thou_st ~ "Vaccine Incidence Density",
                 mean_retail_rec ~ "Mean Retail and Recreation")) %>%
  bold_labels() 

# check for multicollinearity
car::vif(mod_one) # variance inflation factors are low, so no issues 

```


``` {r, eval = TRUE, message = FALSE}

#####################################
# model using predictors that were
# significant in multivariate model
#####################################

# re-run with sig predictors
mod_vacc <- glm(next_week_increase ~ dominant_delta + vacc_inc_per100thou_st,
                data = covid, family = "binomial")

# check model output
mod_table <- mod_vacc %>%
  tbl_regression(
    exponentiate = TRUE,
    label = list(dominant_delta ~ "Delta Dominant Period",
                  vacc_inc_per100thou_st ~ "Vaccine Incidence Density")) %>%
  bold_labels() 

# check for multicollinearity
car::vif(mod_vacc) # variance inflation factors are low, so no issues 

# store predicted values of training data
vacc_pred <- predict(mod_vacc, covid, type = "response") 
head(vacc_pred)

```

After fitting the model, 10-fold cross-validation is performed to train and test the model.

``` {r, eval = TRUE, message = FALSE}

########################################################
########################################################
#           10-fold cross validation
########################################################
########################################################

N = nrow(covid)
K = 10
set.seed(1234)
s = sample(1:K, size = N, replace = T)
pred_outputs <- vector(mode = "numeric", length = N)
obs_outputs <- vector(mode = "numeric", length = N)
offset <- 0
for (i in 1:K) {
  train <- filter(covid, s != i)
  test <- filter(covid, s == i)
  obs_outputs[1:length(s[s == i]) + offset] <- test$next_week_increase
  
  # GLM train/test
glm <- glm(next_week_increase ~ vacc_inc_per100thou_st + mean_retail_rec, 
             data = train, family = "binomial")
  glm_pred_curr <- predict(glm, test, type = "response")
  pred_outputs[1:length(s[s == i]) + offset] <- glm_pred_curr
  
  offset <- offset + length(s[s == i])
}
head(cbind(pred_outputs, obs_outputs))


```


### Results
#### Independent Variables
Of particular interest is the finding that vaccine incidence density is significantly related to the binary outcome case increase, as the investigators hypothesized that vaccine prevalence density (vacc_prevalence_per100thou_st) would be significantly associated with change in case incidence density.

When controlling for the delta-dominant period and vaccine incidence density, mean retail and recreation is no longer significant, so it is dropped from the final model.

``` {r, eval = TRUE, message = FALSE}

# multivariate model with 3 predictors
mod_table1

```



#### Main Model
Ultimately, the final multivariate model includes the delta-dominant variable and vaccine incidence density as explanatory variables, which are significant at <0.001. 

The odds ratio for the delta-dominant period is 3.60 (95% CI: 2.40 - 5.51). This means that when adjusting for vaccine incidence density, the odds of an increase in case incidence in the following week is 3.60 times greater when delta is the dominant variant circulating in the Philadelphia metropolitan area.

The odds ratio for vaccine incidence density is 0.67 (95% CI: 0.56 - 0.80). When controlling for the delta-dominant period, for each additional 1 vaccine per 100,000 people in a given week, the likelihood of an increase in case incidence density in the following week is 33% lower.

``` {r, eval = TRUE, message = FALSE}

mod_table


```



As a final step, the areas  under the curve (AUC) for training and test sets are calculated, and the corresponding receiver operating characteristic (ROC) curves are generated. The AUCs are 0.65 (95% CI: 0.62 - 0.68) and 0.62 (95% CI: 0.58 - 0.66) for training and test data, respectively. These numbers indicate that the predictive accuracy is not very high, and therefore, the model does not distinguish well between no case increase and case increase. However, Joe Romano commented that because the AUC is better than random guessing, it means the model is learning something and is therefore of potential value.

Additionally, as these models are for an epidemiology study, we are less interested in predictive accuracy, and more interested in the interaction between the explanatory variables and their relationship with the outcome variable.

 
``` {r, eval = TRUE, message = FALSE}

#############################################
# evaluate model using ROC curve analysis
#############################################

# calculate area under the ROC curve
roc(covid$next_week_increase, vacc_pred, ci = TRUE) # training data
roc(obs_outputs, pred_outputs, ci = TRUE) # test data

# plot ROC curves for training and test data
plot.roc(covid$next_week_increase, vacc_pred, ci = TRUE, col = "darkblue", lwd = 3)
plot.roc(obs_outputs, pred_outputs, ci = TRUE, col = "mediumorchid2", add = TRUE, lwd = 3) #CV of glm
legend("bottomright", legend = c("GLM Logistic", "GLM Logistic Cross-Validation"), 
       col = c("darkblue", "mediumorchid2"), lwd = 3)

```

#### Next Steps
This analysis will continue next semester as part of Dr. Kelly's SARS-CoV-2 study. Additional regression models predicting vaccine incidence density based on case incidence density will be fit. 


### References
(1) https://microb120.med.upenn.edu/data/SARS-CoV-2/
(2) https://pubmed.ncbi.nlm.nih.gov/34704098/
(3) https://ndc.services.cdc.gov/wp-content/uploads/MMWR_Week_overview.pdf
(4) https://data.cdc.gov/Vaccinations/COVID-19-Vaccinations-in-the-United-States-County/8xkx-amqh
(5) https://www.cdc.gov/coronavirus/2019-ncov/vaccines/distributing/about-vaccine-data.html
(6) https://www.google.com/covid19/mobility/data_documentation.html?hl=en
(7) https://support.google.com/covid19-mobility/answer/9825414?hl=en
(8) https://www.cdc.gov/coronavirus/2019-ncov/variants/variant-classifications.html?CDC_AA_refVal=https%3A%2F%2Fwww.cdc.gov%2Fcoronavirus%2F2019-ncov%2Fvariants%2Fvariant-info.html
(9) https://covid.cdc.gov/covid-data-tracker