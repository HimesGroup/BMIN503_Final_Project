---
title: "BMIN503 Final Project: Predicting SARS-CoV-2 Cases in the Delaware Valley Region"
author: "Leigh Cressman"
output: 
  html_document:
    theme: paper 
    highlight: tango
---
```{r set-options, echo=FALSE, cache=FALSE}
options(width = 400)
```  
***

### Overview
This analysis seeks to determine how changes in community mobility, SARS-CoV-2 variants, and vaccination relate to weekly changes in SARS-CoV-2 case incidence at the county level. County-level vaccination prevalence and case incidence data are publicly available on the CDC website. Community mobility data is captured using Google's county-level COVID-19 Community Mobility Reports. SARS-CoV-2 variant data is from a study led by Dr. Brendan Kelly and Dr. Rick Bushman in PSOM involving metagenomic viral whole genome sequencing (WGS) performed on COVID-19 tests from Penn Medicine clinical laboratories. 

### Introduction 
Since the start of the SARS-CoV-2 pandemic, scientists have been developing statistical models to predict various epidemiologic outcomes in different areas of the world. This analysis will contribute to that knowledge base by examining how changes in community mobility, vaccine prevalence, and SARS-CoV-2 variants are related to weekly changes in case incidence in Philadelphia and the surrounding counties. As Google social mobility data is available starting February 15, 2020, the analysis spans from then through October 2, 2021, using MMWR week as time intervals. The above-referenced study in PSOM randomly samples SARS-CoV-2 positive specimens collected at UPHS facilities with cycle threshold (Ct) values < 30. Whole genome sequencing is performed on these specimens, which have higher viral loads, to identify the variant. The results of WGS will be used as an additional explanatory variable in this analysis to indicate which SARS-CoV-2 variants were dominant in each MMWR week in the greater Philadelphia metropolitan area during the study period.  

This analysis draws upon microbiology for the identification of SARS-CoV-2 variants, and infectious disease epidemiology, biostatistics, and informatics to analyze and interpret the relationship between dominant SARS-CoV-2 variants, vaccination, and change in case incidence. Geographical epidemiology will also contribute to the analysis in the form of visualizing the change in vaccinations, cases, variants, and community mobility across time in the target geographic areas. In addition, this analysis incorporates the behavioral sciences, as it seeks to identify whether social behavior (i.e., community mobility data) is associated with case incidence. 
One particular difficulty I had in the initial phase of this analysis was data harmonization. I examined a plethora of datasets from the CDC, the Pennsylvania Department of Health, Google, and OpenDataPhilly before I was able to find data that covered the time span and geographic areas of interest. 
My discussion with Dr. John Holmes was especially helpful for finalizing the data harmonization aspect of this analysis. He explained that if I were trying to publish this project, I would need express written permission from the CDC to link their data to other data sources. However, for a class project, it is fine to link the data to other sources without obtaining permission.
I spoke with Dr. Joe Romano from IBI to discuss my questions regarding the logistic regression component of the analysis. Specifically, I was thinking about logistic regression in terms of traditional statistical modeling versus machine learning. I asked him whether I should only include predictor variables in the machine learning model if they are individually significantly associated with the outcome in univariate models. I also asked about the necessity of checking for multicollinearity among predictor variables. Joe explained that when building a logistic regression model in a machine learning context, we are less concerned with predictors being significant, or whether there are interactions between the features. The goal is to make a highly performant model, rather than having a precise understanding of how individual features contribute to the outcome variable. I found this especially interesting, as all of my experience to-date is using logistic regression in epidemiological studies. Joe added that possible ways to deal with interaction between features are through using regularization (i.e., lasso) or feature selection. However, he said that multicollinearity is not usually tested in real-world machine learning, and a good machine learning model should be able to deal with complex interactions among features. In addition, the ensemble approach used in random forest models is characteristically resistant to the effects of interactions among features.
 Finally, I spoke with Dr. Sherrie Xie, in geographic epidemiology, to gain insights on creating maps to effectively demonstrate the changes in my study variables over time.



[My final project GitHub repository can be accessed here.](https://github.com/LeighCressman/BMIN503_Final_Project)


### Methods
## Data Cleaning and Transformation
Describe the data used and general methodological approach. Subsequently, incorporate full R code necessary to retrieve and clean data, and perform analysis. Be sure to include a description of code so that others (including your future self) can understand what you are doing and why. 

The majority of the data for this analysis was publicly available via the Internet. 
[The county-level vaccination data is on the CDC website and can be accessed via the Socrata Open Data API (SODA).](https://data.cdc.gov/Vaccinations/COVID-19-Vaccinations-in-the-United-States-County/8xkx-amqh). The CDC's county-level case data is not accessible through SODA, but can be downloaded manually from the [COVID-19 Integrated County View page](https://covid.cdc.gov/covid-data-tracker/#county-view&list_select_map_data_parent=Risk&map-metrics-cv-comm-transmission=community_transmission_level&list_select_map_data_metro=all).
To obtain county-level time-series case data, each county must be selected individually and downloaded. Google Community Mobility Reports are available for [2020](https://www.gstatic.com/covid19/mobility/2020_US_Region_Mobility_Report.csv) and [2021](https://www.gstatic.com/covid19/mobility/2021_US_Region_Mobility_Report.csv).

The counties of interest in this analysis are:
PA: Bucks, Chester, Delaware, Montgomery, Philadelphia
NJ: Burlington, Camden, Gloucester, Mercer 
DE: New Castle

Each dataset (CDC vaccine, CDC case, and Google community mobility) contains county-level time-series data with days as the interval. This analysis increments time in weeks, which are defined by the Morbidity and Mortality Weekly Report (*MMWR* week). The *MMWR* week is used for disease incidence and public health reporting, with values ranging from 1 through 53, and Sunday being the first day of any *MMWR* week (1). The county-level data in each dataset is aggregated by *MMWR* week, using MMWRweek::MMWRweek. The study begins with *MMWR* week 2020-07 (mid-February 2020) and ends with week 2021-39 (end of September 2021).

# Vaccination Data
As previously mentioned, the vaccination data for this study came from the CDC website. While these data were pulled through the API during the testing phase, due to the need for login credentials to access the API, the relevant vaccination file has been included in the GitHub repository. The file exceeded GitHub's size limit, so it has been restricted to observations in Pennsylvania, New Jersey, and Delaware in a previous step. The CDC includes multiple vaccination point prevalence variables which are used in this analysis: Percent of people who are fully vaccinated (have second dose of a two-dose vaccine or one dose of a single-dose vaccine) based on the jurisdiction and county where the recipient lives, and total number of people who are fully vaccinated (have second dose of a two-dose vaccine or one dose of a single-dose vaccine) based on the jurisdiction and county where recipient lives (2). The CDC includes all age groups in the vaccination data in order to give a better measure of community immunity (3).

With regard to vaccines, the investigators in charge of the study are interested in the relationship between vaccination point prevalence and case change, as they hypothesize that vaccination affects transmission as a function of point prevalence. However, out of personal interest, I used the available point prevalence data and created a variable for vaccine incidence.

The Google Community Mobility Reports date back to February 15, 2020. CDC vaccination data does not pick up fully vaccinated individuals prior to January 2021. Therefore, rows of zeros have been added to vaccine so that it could be merged with the social mobility dataset, joining on county and *MMWR* week.

Vaccine incidence and vaccine prevalence (total number of people fully vaccinated) have been adjusted for county population (based on estimates from the 2019 U.S. Census) and standardized (base::scale) prior to being included as independent variables in regression models.


# Google's COVID-19 Community Mobility Reports
Google has created publicly available datasets to reflect how community activity has changed throughout the pandemic. Daily activity is measured in percent change from baseline, which is defined as the median value of the corresponding day of the week from January 3, 2020, through February 6, 2020 (4).

Google created categories of community mobility based on their relevance to social distancing efforts and access to essentials services. Mobility trends are available for the following places:
1) Grocery and pharmacy
2) Parks
3) Transit stations
4) Retail and recreation
5) Residential
6) Workplaces

County-level data data are available for each day, so these variables have been aggregated by county and MMWR and joined to vaccination and case data on county and week.

The variables for parks and transit stations contain missing values. This is a result of activity being too low upon a a specific day and therefore not achieving the anonymity threshold set by Google (5). Multiple methods were considered for dealing with missing data. As the suppressed cells are related to low activity, missing values are dealt with by identifying the minimum absolute value by county and replacing corresponding NAs with the resulting value.


# SARS-CoV-2 Case Data
County-level time-series case data can be accessed through the CDC's county view site. The CDC reports the 7-day rolling average of new cases per 100,000 population based on 2019 U.S. Census estimates (6). 

As CDC case data did not exist prior to March 2020, and Google social mobility data begins in February 2020, rows of zeros were added to case data so that it could be merged with social mobility and vaccine data, joining on county and *MMWR* week. 

Each county in the CDC case dataset contains suppressed cells. This is due to case numbers falling below the required reporting threshold in the first weeks of the pandemic. Therefore, similar to the approach used for missing values in Google social mobility data, the data were grouped by county, and the minimum observed value of cases was selected to replace the suppressed cells. Of note, 0 values were not included when identifying the minimum number of cases per county.

To deal with the time-series component of the data, the outcome in this analysis is binary: is there an increase in mean cases next week compared to this week? To create this binary outcome variable, the rolling 7-day average of new cases per 100,000 population is used, along with dplyr::lead, which retrieves next week's 7-day average of new cases per 100,000 population. These two values are compared, and the result is 1 = increase, 0 = no increase.


``` {r, eval = TRUE, message = FALSE}

################################################
################################################
# Create dataset for BMIN503 analysis
################################################
################################################

# load libraries
library(tidyverse)
library(lubridate)
library(MMWRweek)
library(data.table)
library(RSocrata)
library(magrittr)
library(ggplot2)
library(broom)
library(GGally)
library(tibble)
library(pROC)
library(car)
library(gtsummary)
library(patchwork)
library(stringr)

##########################
##########################
# Explanatory variables
##########################
##########################

############################
# county-level vaccine data
############################

# import CDC county-level vaccination data for PA, NJ, and DE
cdc_vacc <- read_csv("cdc_vacc_pa_nj_de.csv")

# filter and reformat data
coun_name <- "phila|bucks|chester|montgom|dela|camden|burlin|glouc|new castle" # counties of interest
cdc_coun <- cdc_vacc %>%
  filter(recip_county %ilike% coun_name | (recip_state == "NJ" & 
                                                recip_county %ilike% "Mercer")) %>%
  mutate(series_complete_yes = as.numeric(series_complete_yes),
         date = date %>% ymd_hms) %>%
  mutate(MMWRweek(date)) %>% # reformat based on MMWR week
  rename_at(.vars = vars(contains("MMWR")), .funs = ~ gsub("mmwr", "mmwr_",
                                                           tolower(.x))) %>%
  mutate(year_week = ifelse(mmwr_week < 10, paste0(mmwr_year, " - ", "0", mmwr_week),
                            paste0(mmwr_year, " - ", mmwr_week))) %>% # combine year with
                                                                      # MMWR week
  rename(fully_vaccinated = series_complete_yes,
         fully_vacc_per_pop = series_complete_pop_pct) %>%
  arrange(recip_county, desc(date)) %>%
  mutate(new_vaccinations = fully_vaccinated) %>%
  select(date, recip_county, fully_vacc_per_pop, fully_vaccinated, 
         new_vaccinations, year_week) 


# transform vaccine point prevalence data into time-series data
counties <- c("Philadelphia County", "Bucks County",
              "Chester County", "Delaware County",
              "Montgomery County", "Burlington County",
              "Gloucester County", "Camden County", 
              "Mercer County", "New Castle County")


# subtract yesterday's vaccine numbers from today to get n of new vaccinations 
county_new <- data.frame()
for (county in counties) {
  county_data <- cdc_coun %>% filter(recip_county == county)
  for (i in 1:nrow(county_data) - 1) {
    county_data$new_vaccinations[i] = county_data$fully_vaccinated[i] - county_data$fully_vaccinated[i + 1] 
    } 
  county_new <- rbind(county_new, county_data)
}


# aggregate vaccine data by county and MMWR week 
county_agg <- county_new %>% 
  filter(between(date, "2020-02-15", "2021-10-09")) %>%
  group_by(recip_county, year_week) %>%
  summarize(vacc_incidence_n = mean(new_vaccinations), #mean new fully vaccinated individuals               
            mean_per_pop_fully_vacc = mean(fully_vacc_per_pop), # per pop fully vaccinated 
            mean_fully_vacc_n = mean(fully_vaccinated)) %>% # mean cum. fully vaccinated
  arrange(recip_county, year_week)


##############################
# Google social mobility data
##############################

import_google <- function(url) { # function to read and filter data from URLs
  df <- read_csv(url, col_types = cols(.default = col_character())) %>%
    filter(sub_region_1 %in% c("Pennsylvania", "New Jersey", "Delaware"))
  return(df)
}

# get data from 2020 and 2021 mobility reports
url1 <- "https://www.gstatic.com/covid19/mobility/2020_US_Region_Mobility_Report.csv"
url2 <- "https://www.gstatic.com/covid19/mobility/2021_US_Region_Mobility_Report.csv"

# combine dfs into one
google_df <- bind_rows(import_google(url1), import_google(url2))

# filter and reformat Google data
coun_g <- google_df %>% mutate(date = date %>% ymd) %>%
  filter(between(date, "2020-02-15", "2021-10-09") &
    (sub_region_2 %ilike% coun_name | (sub_region_1 == "New Jersey" & 
                                     sub_region_2 %ilike% "Mercer County"))) %>%
  mutate(MMWRweek(date)) %>%
  rename_at(.vars = vars(contains("MMWR")), .funs = ~ gsub("mmwr", "mmwr_",
                                                           tolower(.x))) %>%
  mutate(year_week = ifelse(mmwr_week < 10, paste0(mmwr_year, " - ", "0", mmwr_week),
                            paste0(mmwr_year, " - ", mmwr_week))) %>%
  select(sub_region_2, year_week, 
         retail_and_recreation_percent_change_from_baseline,
         grocery_and_pharmacy_percent_change_from_baseline,
         parks_percent_change_from_baseline,
         transit_stations_percent_change_from_baseline,
         workplaces_percent_change_from_baseline,
         residential_percent_change_from_baseline) %>%
  arrange(sub_region_2, year_week)

# calculate mean social mobility score by week
coun_g[3:8] <- sapply(coun_g[3:8], as.numeric) # convert social mobility vars to numeric

google_week <- coun_g %>% 
  rename(retail_rec = retail_and_recreation_percent_change_from_baseline,
         grocery_pharm = grocery_and_pharmacy_percent_change_from_baseline,
         parks = parks_percent_change_from_baseline,
         transit_stations = transit_stations_percent_change_from_baseline,
         workplaces = workplaces_percent_change_from_baseline,
         residential = residential_percent_change_from_baseline) %>%
  group_by(sub_region_2, year_week) %>%
  summarize(across(everything(), mean, na.rm = TRUE, # compute mean for each col
                   .names = "mean_{.col}")) %>% # add "mean" to each col name
  arrange(sub_region_2, year_week)
  
# identify counties with missing data
google_miss <- google_week %>%
  filter(mean_parks == "NaN" | mean_transit_stations == "NaN")

# identify minimum absolute value of observed values for each county
coun_min <- google_week %>% filter(mean_parks != "NaN",
                                   mean_transit_stations != "Nan") %>%
  mutate(mean_parks = abs(mean_parks),
         mean_transit_stations = abs(mean_transit_stations)) %>%
  group_by(sub_region_2) %>%
  summarize(parks_min = min(mean_parks),
            transit_min = min(mean_transit_stations))

# replace NAs with county-level minimum absolute value
google_na <- google_week %>% 
  mutate(mean_parks = ifelse(sub_region_2 == "Bucks County" & 
                                 mean_parks == "NaN", 0.5714286,
                      ifelse(sub_region_2 == "Burlington County" &
                                 mean_parks == "NaN", 0.0000000,
                      ifelse(sub_region_2 == "Camden County" &
                                 mean_parks == "NaN", 0.0000000,
                      ifelse(sub_region_2 == "Chester County" &
                                 mean_parks == "NaN", 0.8571429,
                      ifelse(sub_region_2 == "Delaware County" &
                                 mean_parks == "NaN", 0.5714286,
                      ifelse(sub_region_2 == "Gloucester County" &
                                 mean_parks == "NaN", 3.4285714,
                      ifelse(sub_region_2 == "Mercer County" & 
                                 mean_parks == "NaN", 1.7142857,
                      ifelse(sub_region_2 == "Montgomery County" &
                                 mean_parks == "NaN", 0.5714286,
                      ifelse(sub_region_2 == "New Castle County" &
                                 mean_parks == "NaN", 1.4285714,
                      ifelse(sub_region_2 == "Philadelphia County" &
                                 mean_parks == "NaN", 0.5714286, mean_parks))))))))))) %>%
  mutate(mean_parks = as.numeric(mean_parks)) %>%
  mutate(mean_transit_stations = ifelse(sub_region_2 == "Bucks County" & 
                                 mean_transit_stations == "NaN", 1.0000000,
                       ifelse(sub_region_2 == "Chester County" & 
                                 mean_transit_stations == "NaN", 2.1428571,
                       ifelse(sub_region_2 == "Gloucester County" &
                                 mean_transit_stations == "NaN", 1.7142857, mean_transit_stations)))) %>%
  mutate(mean_transit_stations = as.numeric(mean_transit_stations))


################################################
# combine vaccine and social mobility data
################################################

# Add rows of 0s for vaccination variables prior to MMWR week 2020-51
add_vacc <- coun_g %>% distinct(sub_region_2, year_week) %>%
  filter(between(year_week, "2020 - 07", "2020 - 50")) %>%
  rename(recip_county = sub_region_2) %>%
  mutate(vacc_incidence_n = 0,
         mean_per_pop_fully_vacc = 0,
         mean_fully_vacc_n = 0)
  
all_vacc <- add_vacc %>% bind_rows(county_agg) %>%
  arrange(recip_county, year_week)

# join vaccine and Google social mobility data on county and MMWR week
explan <- all_vacc %>% 
  inner_join(google_na, by = c("recip_county" = "sub_region_2",
                                 "year_week" = "year_week")) %>%
  arrange(recip_county, year_week)


#############################################
#############################################
# Outcome data
# Case data by county
# one file for each county (10 total)
# downloaded from CDC website
#############################################
#############################################

# import and combine all CDC case files
case_files <- list.files(pattern = "cdc_cases.*\\.csv") 
cdc_case_data <- rbindlist(sapply(case_files, fread, simplify = FALSE),
                           use.names = TRUE) 

# filter and reformat case data
clean_case <- cdc_case_data %>% rename(state = "State Abbreviation",
                                  county = "County",
                                  cases_7d_avg = "Cases 7-day rolling average",
                                  date = "Date") %>%
  mutate(date = date %>% mdy) %>%
  filter(between(date, "2020-02-15", "2021-10-09")) %>%
  mutate(MMWRweek(date)) %>%
  rename_at(.vars = vars(contains("MMWR")), .funs = ~ gsub("mmwr", "mmwr_",
                                                           tolower(.x))) %>%
  mutate(year_week = ifelse(mmwr_week < 10, paste0(mmwr_year, " - ", "0", mmwr_week),
                            paste0(mmwr_year, " - ", mmwr_week))) %>%
  select(state, county, year_week, date, cases_7d_avg) %>%
  arrange(county, year_week)

# identify minimum number of cases for each county for replacing missing values
supp <- clean_case %>% filter(cases_7d_avg != "suppressed" &
                                cases_7d_avg != 0) %>%
  mutate(cases_7d_avg = as.numeric(cases_7d_avg)) %>%
  group_by(county) %>%
  summarize(min_val = min(cases_7d_avg))
supp

# replace suppressed cells with values from supp
case_na <- clean_case %>% 
  mutate(cases_7d_avg = ifelse(county == "Bucks County" & 
                                 cases_7d_avg == "suppressed", 1.42857,
                        ifelse(county == "Burlington County" &
                                 cases_7d_avg == "suppressed", 1.57143,
                        ifelse(county == "Camden County" &
                                 cases_7d_avg == "suppressed", 1.42857,
                        ifelse(county == "Chester County" &
                                 cases_7d_avg == "suppressed", 1.42857,
                        ifelse(county == "Delaware County" &
                                  cases_7d_avg == "suppressed", 1.85714,
                        ifelse(county == "Gloucester County" &
                                 cases_7d_avg == "suppressed", 1.85714,
                        ifelse(county == "Mercer County" & 
                                 cases_7d_avg == "suppressed", 2.14286,
                        ifelse(county == "Montgomery County" &
                                 cases_7d_avg == "suppressed", 1.85714,
                        ifelse(county == "New Castle County" &
                                 cases_7d_avg == "suppressed", 2.14286,
                        ifelse(county == "Philadelphia County" &
                                 cases_7d_avg == "suppressed", 2.28571, cases_7d_avg))))))))))) %>%
  mutate(cases_7d_avg = as.numeric(cases_7d_avg))

# calculate mean of 7-day rolling case average by county and week
weekly_case <- case_na %>% group_by(county, year_week) %>%
  summarize(case_mean = mean(cases_7d_avg)) %>%
  arrange(county, year_week)

# transform data to get case_mean for next week
# so that this week can be compared to next week
next_case <- weekly_case %>%
  ungroup() %>%
  mutate(next_week_mean = lead(case_mean, 1), # return next week's value
         next_week_mean = replace_na(next_week_mean, 0))
           
# add county population data to case data
all_coun <- read_csv("all_counties_population.csv")
next_case_fi <- next_case %>% inner_join(all_coun, by = "county")


###############################################
# combine explanatory and outcome variables
# to create complete data set for analysis
###############################################
full_df <- next_case_fi %>% mutate(county_pop = population) %>%
  inner_join(explan, by = c("county" = "recip_county",
                            "year_week" = "year_week")) %>%
  mutate(vacc_incidence_per100thou = vacc_incidence_n / county_pop * 100000, # adjust by county population
         case_mean_per100thou = case_mean, 
         next_week_per100thou = next_week_mean, 
         vacc_prevalence_per100thou = mean_fully_vacc_n / county_pop * 100000, # adjust by county population
         next_week_increase = ifelse(next_week_per100thou > case_mean_per100thou, 1, 0)) %>% 
  select(county, year_week, case_mean, case_mean_per100thou, next_week_mean,
         next_week_per100thou, next_week_increase, vacc_incidence_n,
         vacc_incidence_per100thou, mean_per_pop_fully_vacc, mean_fully_vacc_n, 
         vacc_prevalence_per100thou, mean_retail_rec, mean_grocery_pharm, mean_parks, 
         mean_transit_stations, mean_workplaces, mean_residential) %>%
  arrange(county, year_week) %>%
  filter(year_week != "2021 - 40") # this is first week of October; it was needed for 
                                   # comparing the final week of the study (2021-39) to 
                                   # next week, but it will not be included in analysis
```

### Methods
## Descriptive Analysis

After finalizing the analysis dataset, several data quality checks are performed. Specifically, we verify that the dataset contains the expected number of rows, and the start and end dates of the study are correct.

We then note that of the 860 observations in the dataset, 440 saw an increase in cases in the next week, and 420 did not see an increase.


``` {r, eval = TRUE, message = FALSE}

########################################################
########################################################
               # Descriptive Analysis
########################################################
########################################################

# convert outcome variable to factor
covid <- full_df %>%
  mutate(next_week_increase = factor(next_week_increase,
                                     levels = c(0, 1),
                                     labels = c("no increase", "increase")))

# view data
glimpse(covid)

# check that each county has 86 rows
table(covid$county)

# check min and max year_week
min(covid$year_week) # 2020-07
max(covid$year_week) # 2021-39

# next week increase or no increase 
table(covid$next_week_increase) # split is close to 50/50

```

Next, we look at the three vaccination independent variables to determine how the "increase" and "no increase" groups compare.


``` {r, eval = TRUE, message = FALSE}

#################################
# outcome variable x vaccination 
#################################

# view summary stats of vaccine vars - overall
summary_df <- covid %>%
  select(mean_per_pop_fully_vacc, vacc_prevalence_per100thou,
         vacc_incidence_per100thou) %>%
  psych::describe(quant=c(.25,.75)) %>%
  as_tibble(rownames="rowname")  %>%
  select(-vars, -trimmed, -mad, -range, -skew, -kurtosis, -se) %>%
  select(rowname, n, min, Q0.25, median, Q0.75, max, mean, sd) 
summary_df

# observations with increase
summary_inc <- covid %>% filter(next_week_increase == "increase") %>%
  select(mean_per_pop_fully_vacc, vacc_prevalence_per100thou,
         vacc_incidence_per100thou) %>%
  psych::describe(quant=c(.25,.75)) %>%
  as_tibble(rownames="rowname")  %>%
  select(-vars, -trimmed, -mad, -range, -skew, -kurtosis, -se) %>%
  select(rowname, n, min, Q0.25, median, Q0.75, max, mean, sd) 
summary_inc

# observations with no increase
summary_noinc <- covid %>% filter(next_week_increase == "no increase") %>%
  select(mean_per_pop_fully_vacc, vacc_prevalence_per100thou,
         vacc_incidence_per100thou) %>%
  psych::describe(quant=c(.25,.75)) %>%
  as_tibble(rownames="rowname")  %>%
  select(-vars, -trimmed, -mad, -range, -skew, -kurtosis, -se) %>%
  select(rowname, n, min, Q0.25, median, Q0.75, max, mean, sd) 
summary_noinc

```
Interestingly, we observe that in the group that has an increase in next week's mean cases, the means of the prevalence-related vaccination variables are higher ((1) percent of population which are fully vaccinated: mean = 16.13% in "increase" group vs. 13.71% in "no increase" group; and (2) vaccination prevalence per 100,000 population: mean = 16131.71 (increase group) vs. 13714.27 (no increase group)). Please note that these two vaccination variables are essentially the same, just on different scales.

We expected that the group which did not have an increase in mean cases in the following week would have higher means for these two vaccination variables. 

When comparing the vaccine incidence variable (vaccine incidence per 100,000 population), we see the results we would expect: mean vaccine incidence densities are 122.77 and 74 in the "no increase"  and "increase" groups, respectively.

The above findings are visualized in the boxplots below.

``` {r, eval = TRUE, message = FALSE}

# boxplot for mean percentage of population fully vaccinated by outcome
ggplot(data = covid, aes(x = next_week_increase, y = mean_per_pop_fully_vacc)) +
  geom_boxplot(color = "darkorchid4", fill = "mediumpurple2") +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 12)) +
  xlab("Outcome: Next Week's SARS-CoV-2 Cases") +
  ylab("Percent of Population Fully Vaccinated") +
  labs(title = "Vaccination by Outcome Group") 
  

# boxplot for mean vaccine prevalence by outcome
ggplot(data = covid, aes(x = next_week_increase, y = vacc_prevalence_per100thou)) +
  geom_boxplot(color = "magenta4", fill = "thistle") +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 12)) +
  xlab("Outcome: Next Week's SARS-CoV-2 Cases") +
  ylab("Mean Vaccine Prevalence / 100,000 Population") +
  labs(title = "Vaccination by Outcome Group") 


# boxplot for mean vaccine incidence by outcome
ggplot(data = covid, aes(x = next_week_increase, y = vacc_incidence_per100thou)) +
  geom_boxplot(color = "darkblue", fill = "plum3") +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, size = 12)) +
  xlab("Outcome: Next Week's SARS-CoV-2 Cases") +
  ylab("Mean Vaccine Incidence / 100,000 Population") +
  labs(title = "Vaccination by Outcome Group") 

```


Finally, we plot the independent variables against each other, and against the outcome variable to identify existing relationships.

``` {r, eval = TRUE, message = FALSE}

########################
# plot with ggpairs
########################

# limit dataframe to focus on specific predictor variables  
df_clean <- covid %>% filter(complete.cases(.)) %>%
  select(-county, -year_week, -case_mean, -case_mean_per100thou,
         -next_week_mean, -next_week_per100thou, -vacc_incidence_n,
         -vacc_incidence_per100thou, -mean_fully_vacc_n,
         -vacc_prevalence_per100thou) %>%
  rename(case_incr = next_week_increase,
         vacc = mean_per_pop_fully_vacc,
         retail = mean_retail_rec,
         grocery = mean_grocery_pharm,
         parks = mean_parks,
         transit = mean_transit_stations,
         workplace = mean_workplaces,
         residential = mean_residential)

# compare all variables simultaneously
ggpairs(df_clean)

```

We identify strong correlations (both negative and positive) between some pairs of the Google social mobility variables. Additional tests will be used to check for multicollinearity in the subsequent regression models.


### Methods
## Regression Analysis

The primary goal of this analysis is to identify how changes in community mobility, SARS-CoV-2 variants, and vaccination relate to weekly changes in SARS-CoV-2 case incidence using logistic regression. The next step in the analysis is to fit univariate statistical models to find out which variables are individually associated with case increase at a nominally significant level.

Prior to running the logistic regression models, the vaccine incidence per 100,000 population and vaccine prevalence per 100,000 population are standardized. The motivation for this is that all other independent variables in the dataset are percentages, and there is concern about the magnitude of unstandardized vaccine incidence and prevalence affecting the regression coefficients.

``` {r, eval = TRUE, message = FALSE}

########################################################
########################################################
          # Logistic Regression Models
########################################################
########################################################

###############################################
# Fit univariate statistical models 
###############################################

# standardize vaccine variables (without centering)
covid$vacc_inc_per100thou_st <- scale(covid$vacc_incidence_per100thou, center = FALSE)[, 1]
covid$vacc_prev_per100thou_st <- scale(covid$vacc_prevalence_per100thou, center = FALSE)[, 1]

# drop unneeded variables
covid_clean <- covid %>% select(-county, -year_week,
                                -case_mean_per100thou, -case_mean,
                                -next_week_mean, -next_week_per100thou,
                                -vacc_incidence_n, -mean_fully_vacc_n) 

# generate multiple univariate models and save output to df
glm_output <- covid_clean %>%
  select(-next_week_increase, -vacc_incidence_per100thou,
         -vacc_prevalence_per100thou) %>%
  names() %>%
  paste("next_week_increase ~", .) %>%
  map_df(~tidy(glm(as.formula(.x), 
                   data = covid_clean, 
                   family = "binomial"), 
               estimate = TRUE,
               conf.int = TRUE, 
               exponentiate = TRUE)) %>%
  filter(term != "(Intercept)") %>%
  arrange(p.value) %>%
  rename("Odds Ratio" = estimate,
         Variable = term,
         "Standard Error" = std.error,
         Statistic = statistic,
         "P-value" = p.value,
         "95% CI Lower" = conf.low,
         "95% CI Upper" = conf.high) 
glm_output

```

The above table shows that two of the independent variables are significantly associated with case increase: vaccine incidence per 100,000 population and the social mobility variable for retail and recreation.

Based on the above univariate analysis, a multivariate model is fit using the standardized form of vaccine incidence density and retail and recreation as independent variables. Table output is generated using gtsummary::tbl_regression. The model is checked for multicollinearity, which is not an issue.

``` {r, eval = TRUE, message = FALSE}

#####################################
# model using significant predictors
#####################################

# fit model
mod_vacc <- glm(next_week_increase ~ vacc_inc_per100thou_st + mean_retail_rec,
                data = covid, family = "binomial")

# check model output
mod_table <- mod_vacc %>%
  tbl_regression(
    exponentiate = TRUE,
    label = list(vacc_inc_per100thou_st ~ "Vaccine Incidence per 100,000 Population",
                 mean_retail_rec ~ "Mean Retail and Recreation")) %>%
  bold_labels()

# check for multicollinearity
car::vif(mod_vacc) # variance inflation factors are low, so no issues 

# store predicted values of training data
vacc_pred <- predict(mod_vacc, covid, type = "response") 
head(vacc_pred)

```

After fitting the model, 10-fold cross-validation is performed to train and test the model.

``` {r, eval = TRUE, message = FALSE}

########################################################
########################################################
#           10-fold cross validation
########################################################
########################################################

N = nrow(covid)
K = 10
set.seed(1234)
s = sample(1:K, size = N, replace = T)
pred_outputs <- vector(mode = "numeric", length = N)
obs_outputs <- vector(mode = "numeric", length = N)
offset <- 0
for (i in 1:K) {
  train <- filter(covid, s != i)
  test <- filter(covid, s == i)
  obs_outputs[1:length(s[s == i]) + offset] <- test$next_week_increase
  
  # GLM train/test
  glm <- glm(next_week_increase ~ vacc_inc_per100thou_st + mean_retail_rec, 
             data = train, family = "binomial")
  glm_pred_curr <- predict(glm, test, type = "response")
  pred_outputs[1:length(s[s == i]) + offset] <- glm_pred_curr
  
  offset <- offset + length(s[s == i])
}
head(cbind(pred_outputs, obs_outputs))


```

### Methods
## Additional Analysis of Vaccine Incidence

In an effort to identify why vaccine incidence and not vaccine prevalence was significantly associated with an increase in cases next week, time-series graphs are generated.

``` {r, eval = TRUE, message = FALSE,  fig.width=10, fig.height=10}

# reformat df for plots
covid$County <- gsub(paste(stopwords, collapse="|"), "", covid$county)

# vaccine plot
vacc_plot <- ggplot(covid, aes(x = year_week, y = vacc_incidence_per100thou, color = County, group = County)) +
  geom_line(size = 1) + 
  scale_color_viridis(discrete = TRUE) + 
  theme_bw() +
    theme(
          plot.title = element_text(size=rel(1.2), hjust = 0.5, lineheight=.9, face="bold", colour="black"),
          axis.title.x = element_text(size=11, lineheight=.9, face="bold", colour="black"),
          axis.title.y = element_text(size=11, lineheight=.9, face="bold", colour="black"),
          axis.text.x = element_text(colour="black", angle = 60, hjust = 1.00),
          axis.text.y = element_text(colour="black"),
          legend.title = element_text(), 
          legend.text = element_text(size = 10)) +
  labs(title = "Vaccination Incidence in the Delaware Valley", 
       x = "MMWR Week", 
       y = "Mean Vaccination Incidence per 100,000") +
  scale_y_continuous(expand = c(0,0), limit = c(0, 800)) +
  scale_x_discrete(labels = c("2020-07", "", "", "", "", "", "", "2020-14", "", "",
                              "", "", "", "", "2020-21", "", "", "", "", "", "",
                              "2020-28", "", "", "", "", "", "", "2020-35", 
                              "", "", "", "", "", "", "2020-42", "", "", "", "", "", "",
                              "2020-49", "", "", "", "", "", "", "2021-03", "", "", "", 
                              "", "", "", "2021-10", "", "", "", "", "", "", "2021-17",
                              "", "", "", "", "", "", "2021-24", "", "", "", "", "", "",
                              "2021-31", "", "", "", "", "", "", "", "2021-39"))


# case plot
case_plot <- ggplot(covid, aes(x = year_week, y = case_mean_per100thou, color = County, group = County)) +
  geom_line(size = 1) + 
  scale_color_viridis(discrete = TRUE) + 
  theme_bw() +
    theme(
          plot.title = element_text(size=rel(1.2), hjust = 0.5, lineheight=.9, face="bold", colour="black"),
          axis.title.x = element_text(size=11, lineheight=.9, face="bold", colour="black"),
          axis.title.y = element_text(size=11, lineheight=.9, face="bold", colour="black"),
          axis.text.x = element_text(colour="black", angle = 60, hjust = 1.00),
          axis.text.y = element_text(colour="black"),
          legend.title = element_text(), 
          legend.text = element_text(size = 10)) +
  labs(title = "SARS-CoV-2 Case Incidence in the Delaware Valley", 
       x = "MMWR Week", 
       y = "Mean Case Incidence per 100,000") +
  scale_y_continuous(expand = c(0,0), limit = c(0, 1110)) +
  scale_x_discrete(labels = c("2020-07", "", "", "", "", "", "", "2020-14", "", "",
                              "", "", "", "", "2020-21", "", "", "", "", "", "",
                              "2020-28", "", "", "", "", "", "", "2020-35", 
                              "", "", "", "", "", "", "2020-42", "", "", "", "", "", "",
                              "2020-49", "", "", "", "", "", "", "2021-03", "", "", "", 
                              "", "", "", "2021-10", "", "", "", "", "", "", "2021-17",
                              "", "", "", "", "", "", "2021-24", "", "", "", "", "", "",
                              "2021-31", "", "", "", "", "", "", "", "2021-39"))

vacc_plot / case_plot

  


  
  


-> p_vax

bmin %>% qplot(data = ., x = year_week, y = case_mean_per100thou, color = county, geom = c("point", "line"), group = county) + scale_color_viridis_d() + 
  theme(axis.text.x = element_text(angle = 270)) 

library(patchwork)

p_vax / p_case


```


``` {r, eval = TRUE, message = FALSE}



########################################################
########################################################
#           Predictive Models
########################################################
########################################################

# fit model
mod_all <- glm(next_week_increase ~ vacc_inc_per100thou_st + vacc_prev_per100thou_st +
                  mean_retail_rec + mean_grocery_pharm + mean_residential +
                  mean_parks + mean_workplaces + mean_transit_stations, 
               data = covid, family = "binomial")

vif(mod_all)

# store predicted values of training data
all_pred <- predict(mod_all, covid, type = "response") 
head(all_pred)

# use 10-fold cross validation to train and test model
N = nrow(covid)
K = 10
set.seed(1234)
s = sample(1:K, size = N, replace = T)
pred_outputs <- vector(mode = "numeric", length = N)
obs_outputs <- vector(mode = "numeric", length = N)
offset <- 0
for (i in 1:K) {
  train <- filter(covid, s != i)
  test <- filter(covid, s == i)
  obs_outputs[1:length(s[s == i]) + offset] <- test$next_week_increase
  
  # GLM train/test
  glm <- glm(next_week_increase ~ vacc_inc_per100thou_sc + mean_retail_rec +
                mean_grocery_pharm + 
                  mean_parks + mean_workplaces +
                  mean_transit_stations, 
             data = train, family = "binomial")
  glm_pred_curr <- predict(glm, test, type = "response")
  pred_outputs[1:length(s[s == i]) + offset] <- glm_pred_curr
  
  offset <- offset + length(s[s == i])
}
head(cbind(pred_outputs, obs_outputs))


roc(covid$next_week_increase, all_pred, ci = TRUE) # training data
roc(obs_outputs, pred_outputs, ci = TRUE) # test data


```




### Results
Describe your results and include relevant tables, plots, and code/comments used to obtain them. End with a brief conclusion of your findings related to the question you set out to address. You can include references if you'd like, but this is not required.

## Independent Variables
Of particular interest is the finding that vaccine incidence is significantly related to case increase, as the investigators hypothesized that mean vaccine prevalence per population (vacc_prevalence_per100thou_st) would be significantly associated with change in case incidence per population. However, mean vaccine incidence per population (standardized form) was identified as significant at p < 0.05 in the univariate modeling stage. In addition, one Google social mobility variable, mean retail and recreation, was significantly associated with mean case increase or no increase.

``` {r, eval = TRUE, message = FALSE}
glm_output

```

## Main Model
Both independent variables identified as significant in the univariate modeling stage are significant at the <0.001 level when put into the multivariate logistic regression model. When mean retail and recreation was used as a single explanatory variable predicting case increase, it was significant at the <0.05 level, but when used in combination with vaccine incidence density, the p-value decreases.
The odds ratio for vaccine incidence density is 0.62 (95% CI: 0.51 - 0.73). This can be interpreted as for each additional new vaccine in a given week, the odds of a case increase n the following week decrease by almost half.
The odds ratio for mean retail and recreation is 1.02 (95% CI: 1.01 - 1.03). Even though retail and recreation is significantly associated with case increase, the effect is very small (i.e., the odds of cases increasing when retail and recreation activity increases by 1 percentage point are almost the same as they would be if retail and recreation activity did not increase).

``` {r, eval = TRUE, message = FALSE}
mod_table


```

```


As a final step, the areas  under the curve (AUC) for training and test sets are calculated, and the corresponding receiver operating characteristic (ROC) curves are generated. The AUCs are 0.63 (95% CI: 0.59 - 0.66) and 0.62 (95% CI: 0.58 - 0.66) for training and test data, respectively. These numbers indicate that the predictive accuracy is not very good, and therefore, the model does not distinguish well between no case increase and case increase. The plot of the ROC curves illustrate that the model does not have a very good measure of separability. However, Joe Romano commented that because the AUC is better than random guessing, it means the model is learning something and is therefore of potential value.

Additionally, the AUCs for training and test data are very similar, which could indicate that the model is not overfit.


 
``` {r, eval = TRUE, message = FALSE}

#############################################
# evaluate model using ROC curve analysis
#############################################

# calculate area under the ROC curve
roc(covid$next_week_increase, vacc_pred, ci = TRUE) # training data
roc(obs_outputs, pred_outputs, ci = TRUE) # test data

# plot ROC curves for training and test data
plot.roc(covid$next_week_increase, vacc_pred, ci = TRUE, col = "darkblue", lwd = 3)
plot.roc(obs_outputs, pred_outputs, ci = TRUE, col = "mediumorchid2", add = TRUE, lwd = 3) #CV of glm
legend("bottomright", legend = c("GLM Logistic", "GLM Logistic Cross-Validation"), 
       col = c("darkblue", "mediumorchid2"), lwd = 3)

```

# Analysis of Time Series Data 



### References
(1) https://ndc.services.cdc.gov/wp-content/uploads/MMWR_Week_overview.pdf
(2) https://data.cdc.gov/Vaccinations/COVID-19-Vaccinations-in-the-United-States-County/8xkx-amqh
(3) https://www.cdc.gov/coronavirus/2019-ncov/vaccines/distributing/about-vaccine-data.html
(4) https://www.google.com/covid19/mobility/data_documentation.html?hl=en
(5) https://support.google.com/covid19-mobility/answer/9825414?hl=en
(6) https://covid.cdc.gov/covid-data-tracker/#county-view