---
title: "BMIN503 Final Project: Predicting SARS-CoV-2 Cases in the Delaware Valley Region"
author: "Leigh Cressman"
output: 
  html_document:
    theme: paper 
    highlight: tango
---
```{r set-options, echo=FALSE, cache=FALSE}
options(width = 400)
```  
***

### Overview
This analysis seeks to determine how changes in community mobility, SARS-CoV-2 variants, and vaccination relate to weekly changes in SARS-CoV-2 case incidence at the county level. County-level vaccination prevalence and case incidence data are publicly available on the CDC website. Community mobility data is captured using Google's county-level COVID-19 Community Mobility Reports. SARS-CoV-2 variant data is from a study led by Dr. Brendan Kelly and Dr. Rick Bushman in PSOM involving metagenomic viral whole genome sequencing (WGS) performed on COVID-19 tests from Penn Medicine clinical laboratories. 

### Introduction 
Since the start of the SARS-CoV-2 pandemic, scientists have been developing statistical models to predict various epidemiologic outcomes in different areas of the world. This analysis will contribute to that knowledge base by examining how changes in community mobility, vaccine prevalence, and SARS-CoV-2 variants are related to weekly changes in case incidence in Philadelphia and the surrounding counties. As Google social mobility data is available starting February 15, 2020, the analysis spans from then through October 2, 2021, using MMWR week as time intervals. The above-referenced study in PSOM randomly samples SARS-CoV-2 positive specimens collected at UPHS facilities with cycle threshold (Ct) values < 30. Whole genome sequencing is performed on these specimens, which have higher viral loads, to identify the variant. The results of WGS will be used as an additional explanatory variable in this analysis to indicate which SARS-CoV-2 variants were dominant in each MMWR week in the greater Philadelphia metropolitan area during the study period.  

This analysis draws upon microbiology for the identification of SARS-CoV-2 variants, and infectious disease epidemiology, biostatistics, and informatics to analyze and interpret the relationship between dominant SARS-CoV-2 variants, vaccination, and change in case incidence. Geographical epidemiology will also contribute to the analysis in the form of visualizing the change in vaccinations, cases, variants, and community mobility across time in the target geographic areas. In addition, this analysis incorporates the behavioral sciences, as it seeks to identify whether social behavior (i.e., community mobility data) is associated with case incidence. 
One particular difficulty I had in the initial phase of this analysis was data harmonization. I examined a plethora of datasets from the CDC, the Pennsylvania Department of Health, Google, and OpenDataPhilly before I was able to find data that covered the time span and geographic areas of interest. My discussion with Dr. John Holmes was especially helpful for finalizing the data harmonization aspect of this analysis. He explained that if I were trying to publish this project, I would need express written permission from the CDC to link their data to other data sources. However, for a class project, it is fine to link the data to other sources without obtaining permission. In addition, I consulted Dr. Joe Romano regarding the machine learning portion of this analysis. Finally, I spoke with Dr. Sherrie Xie, in geographic epidemiology, to gain insights on creating maps to effectively demonstrate the changes in my study variables over time.

[My final project GitHub repository can be accessed here.](https://github.com/LeighCressman/BMIN503_Final_Project)


### Methods
Describe the data used and general methodological approach. Subsequently, incorporate full R code necessary to retrieve and clean data, and perform analysis. Be sure to include a description of code so that others (including your future self) can understand what you are doing and why. 


The majority of the data for this analysis was publicly available via the Internet. 
[The county-level vaccination data is on the CDC website and can be accessed via the Socrata Open Data API (SODA).](https://data.cdc.gov/Vaccinations/COVID-19-Vaccinations-in-the-United-States-County/8xkx-amqh). The CDC's county-level case data is not accessible through SODA, but can be downloaded manually from the [COVID-19 Integrated County View page](https://covid.cdc.gov/covid-data-tracker/#county-view&list_select_map_data_parent=Risk&map-metrics-cv-comm-transmission=community_transmission_level&list_select_map_data_metro=all).
To obtain county-level time-series case data, each county must be selected individually and downloaded. Google Community Mobility Reports are available for [2020](https://www.gstatic.com/covid19/mobility/2020_US_Region_Mobility_Report.csv) and [2021](https://www.gstatic.com/covid19/mobility/2021_US_Region_Mobility_Report.csv).

The counties of interest in this analysis are:
PA: Bucks, Chester, Delaware, Montgomery, Philadelphia
NJ: Burlington, Camden, Gloucester, Mercer 
DE: New Castle

Each dataset (CDC vaccine, CDC case, and Google community mobility) contains county-level time-series data with days as the interval. This analysis uses MMWR week as the time interval, so the county-level data in each dataset is aggregated by MMWR week, using MMWRweek::MMWRweek. The *MMWR* week is used for disease incidence and public health reporting, with values ranging from 1 through 53, and Sunday being the first day of any *MMWR* week (1). 

The Google Community Mobility Reports date back to February 15, 2020. CDC case data did not exist prior to March 2020, and CDC vaccination data does not pick up fully vaccinated individuals prior to January 2021. Therefore, rows of zeros were added to vaccine and case data so that it could be merged with the social mobility dataset, joining on county and *MMWR* week.

Suppressed values CDC
### Suppressed cells need to be replaced with minimum observed cases by county.
# 0 values are not included when considering minimum number of cases.

Suppressed values Google
### Mean_parks and mean_transit_stations contain NAs.
# [Missing values are a result of activity being too 
# low upon a specific day and therefore not achieving the 
# anonymity threshold set by Google](https://support.google.com/covid19-mobility/answer/9825414?hl=en)


Case and vaccine variables have been adjusted for county population based on estimates from the 2019 U.S. Census.

Multiple vaccine variables

Scaling case incidence and vaccine prevalence after adjusting for population
base::scale 

car::vif for checking variance inflation factor

``` {r, eval = TRUE, message = FALSE}

################################################
################################################
# Create dataset for BMIN503 analysis
################################################
################################################

# load libraries
library(tidyverse)
library(lubridate)
library(MMWRweek)
library(data.table)
library(RSocrata)
library(magrittr)
library(ggplot2)
library(broom)
library(GGally)
library(tibble)
library(pROC)
library(car)


##########################
##########################
# Explanatory variables
##########################
##########################

############################
# county-level vaccine data
############################

# access secret login credentials for connecting to the Socrata Open Data API (SODA)
login <- readLines("../final_project_login.txt")

# import CDC county vaccination data
cdc_vacc <- read.socrata("https://data.cdc.gov/resource/8xkx-amqh.csv",
                       app_token = login[1],
                       email = login[2],
                       password = login[3]
)

# filter and reformat data
coun_name <- "phila|bucks|chester|montgom|dela|camden|burlin|glouc|new castle" # counties of interest
cdc_coun <- cdc_vacc %>%
  filter(recip_state %in% c("PA", "NJ", "DE") &
           (recip_county %ilike% coun_name | (recip_state == "NJ" & 
                                                recip_county %ilike% "Mercer"))) %>%
  mutate(series_complete_yes = as.numeric(series_complete_yes),
         date = date %>% ymd) %>%
  mutate(MMWRweek(date)) %>% # reformat based on MMWR week
  rename_at(.vars = vars(contains("MMWR")), .funs = ~ gsub("mmwr", "mmwr_",
                                                           tolower(.x))) %>%
  mutate(year_week = ifelse(mmwr_week < 10, paste0(mmwr_year, " - ", "0", mmwr_week),
                            paste0(mmwr_year, " - ", mmwr_week))) %>% # combine year with
                                                                      # MMWR week
  rename(fully_vaccinated = series_complete_yes,
         fully_vacc_per_pop = series_complete_pop_pct) %>%
  arrange(recip_county, desc(date)) %>%
  mutate(new_vaccinations = fully_vaccinated) %>%
  select(date, recip_county, fully_vacc_per_pop, fully_vaccinated, 
         new_vaccinations, year_week) 


# transform vaccine point prevalence data into time-series data
counties <- c("Philadelphia County", "Bucks County",
              "Chester County", "Delaware County",
              "Montgomery County", "Burlington County",
              "Gloucester County", "Camden County", 
              "Mercer County", "New Castle County")


# subtract yesterday's # vaccine numbers # from today # to get n of new vaccinations 
county_new <- data.frame()
for (county in counties) {
  county_data <- cdc_coun %>% filter(recip_county == county)
  for (i in 1:nrow(county_data) - 1) {
    county_data$new_vaccinations[i] = county_data$fully_vaccinated[i] - county_data$fully_vaccinated[i + 1] 
    } 
  county_new <- rbind(county_new, county_data)
}


# aggregate vaccine data by county and MMWR week 
county_agg <- county_new %>% 
  filter(between(date, "2020-02-15", "2021-10-09")) %>%
  group_by(recip_county, year_week) %>%
  summarize(vacc_incidence_n = mean(new_vaccinations), #mean new fully vaccinated individuals                     
            mean_per_pop_fully_vacc = mean(fully_vacc_per_pop), # per pop fully vaccinated 
            mean_fully_vacc_n = mean(fully_vaccinated)) %>% # mean cum. fully vaccinated
  arrange(recip_county, year_week)


##############################
# Google social mobility data
##############################

import_google <- function(url) { # function to read and filter data from URLs
  df <- read_csv(url, col_types = cols(.default = col_character())) %>%
    filter(sub_region_1 %in% c("Pennsylvania", "New Jersey", "Delaware"))
  return(df)
}

# get data from 2020 and 2021 mobility reports
url1 <- "https://www.gstatic.com/covid19/mobility/2020_US_Region_Mobility_Report.csv"
url2 <- "https://www.gstatic.com/covid19/mobility/2021_US_Region_Mobility_Report.csv"

# combine dfs into one
google_df <- bind_rows(import_google(url1), import_google(url2))

# filter and reformat Google data
coun_g <- google_df %>% mutate(date = date %>% ymd) %>%
  filter(between(date, "2020-02-15", "2021-10-09") &
    (sub_region_2 %ilike% coun_name | (sub_region_1 == "New Jersey" & 
                                     sub_region_2 %ilike% "Mercer County"))) %>%
  mutate(MMWRweek(date)) %>%
  rename_at(.vars = vars(contains("MMWR")), .funs = ~ gsub("mmwr", "mmwr_",
                                                           tolower(.x))) %>%
  mutate(year_week = ifelse(mmwr_week < 10, paste0(mmwr_year, " - ", "0", mmwr_week),
                            paste0(mmwr_year, " - ", mmwr_week))) %>%
  select(sub_region_2, year_week, 
         retail_and_recreation_percent_change_from_baseline,
         grocery_and_pharmacy_percent_change_from_baseline,
         parks_percent_change_from_baseline,
         transit_stations_percent_change_from_baseline,
         workplaces_percent_change_from_baseline,
         residential_percent_change_from_baseline) %>%
  arrange(sub_region_2, year_week)

# calculate mean social mobility score by week
coun_g[3:8] <- sapply(coun_g[3:8], as.numeric) # convert social mobility vars to numeric

google_week <- coun_g %>% 
  rename(retail_rec = retail_and_recreation_percent_change_from_baseline,
         grocery_pharm = grocery_and_pharmacy_percent_change_from_baseline,
         parks = parks_percent_change_from_baseline,
         transit_stations = transit_stations_percent_change_from_baseline,
         workplaces = workplaces_percent_change_from_baseline,
         residential = residential_percent_change_from_baseline) %>%
  group_by(sub_region_2, year_week) %>%
  summarize(across(everything(), mean, na.rm = TRUE, # compute mean for each col
                   .names = "mean_{.col}")) %>% # add "mean" to each col name
  arrange(sub_region_2, year_week)
  
### Variables Mean_parks and mean_transit_stations contain NAs

# identify counties with missing data
google_miss <- google_week %>%
  filter(mean_parks == "NaN" | mean_transit_stations == "NaN")

# identify minimum absolute value of observed values for each county
coun_min <- google_week %>% filter(mean_parks != "NaN",
                                   mean_transit_stations != "Nan") %>%
  mutate(mean_parks = abs(mean_parks),
         mean_transit_stations = abs(mean_transit_stations)) %>%
  group_by(sub_region_2) %>%
  summarize(parks_min = min(mean_parks),
            transit_min = min(mean_transit_stations))

# replace NAs with county-level minimum absolute value
google_na <- google_week %>% 
  mutate(mean_parks = ifelse(sub_region_2 == "Bucks County" & 
                                 mean_parks == "NaN", 0.5714286,
                      ifelse(sub_region_2 == "Burlington County" &
                                 mean_parks == "NaN", 0.0000000,
                      ifelse(sub_region_2 == "Camden County" &
                                 mean_parks == "NaN", 0.0000000,
                      ifelse(sub_region_2 == "Chester County" &
                                 mean_parks == "NaN", 0.8571429,
                      ifelse(sub_region_2 == "Delaware County" &
                                 mean_parks == "NaN", 0.5714286,
                      ifelse(sub_region_2 == "Gloucester County" &
                                 mean_parks == "NaN", 3.4285714,
                      ifelse(sub_region_2 == "Mercer County" & 
                                 mean_parks == "NaN", 1.7142857,
                      ifelse(sub_region_2 == "Montgomery County" &
                                 mean_parks == "NaN", 0.5714286,
                      ifelse(sub_region_2 == "New Castle County" &
                                 mean_parks == "NaN", 1.4285714,
                      ifelse(sub_region_2 == "Philadelphia County" &
                                 mean_parks == "NaN", 0.5714286, mean_parks))))))))))) %>%
  mutate(mean_parks = as.numeric(mean_parks)) %>%
  mutate(mean_transit_stations = ifelse(sub_region_2 == "Bucks County" & 
                                 mean_transit_stations == "NaN", 1.0000000,
                       ifelse(sub_region_2 == "Chester County" & 
                                 mean_transit_stations == "NaN", 2.1428571,
                       ifelse(sub_region_2 == "Gloucester County" &
                                 mean_transit_stations == "NaN", 1.7142857, mean_transit_stations)))) %>%
  mutate(mean_transit_stations = as.numeric(mean_transit_stations))


################################################
# combine vaccine and social mobility data
################################################

### Google Social Mobility data starts 2/15/2021. 
# Counts for fully vaccinated individuals do not appear until early January 2021. 
# Add rows of 0s for vaccination variables prior to MMWR week 2020-51

add_vacc <- coun_g %>% distinct(sub_region_2, year_week) %>%
  filter(between(year_week, "2020 - 07", "2020 - 50")) %>%
  rename(recip_county = sub_region_2) %>%
  mutate(vacc_incidence_n = 0,
         mean_per_pop_fully_vacc = 0,
         mean_fully_vacc_n = 0)
  
all_vacc <- add_vacc %>% bind_rows(county_agg) %>%
  arrange(recip_county, year_week)

# join vaccine and Google social mobility data on county and MMWR week
explan <- all_vacc %>% 
  inner_join(google_na, by = c("recip_county" = "sub_region_2",
                                 "year_week" = "year_week")) %>%
  arrange(recip_county, year_week)


#############################################
#############################################
# Outcome data
# Case data by county
# one file for each county (10 total)
# downloaded from CDC website
#############################################
#############################################

# import and combine all CDC case files
case_files <- list.files(pattern = "cdc_cases.*\\.csv") 
cdc_case_data <- rbindlist(sapply(case_files, fread, simplify = FALSE),
                           use.names = TRUE) 

# filter and reformat case data
clean_case <- cdc_case_data %>% rename(state = "State Abbreviation",
                                  county = "County",
                                  cases_7d_avg = "Cases 7-day rolling average",
                                  date = "Date") %>%
  mutate(date = date %>% mdy) %>%
  filter(between(date, "2020-02-15", "2021-10-09")) %>%
  mutate(MMWRweek(date)) %>%
  rename_at(.vars = vars(contains("MMWR")), .funs = ~ gsub("mmwr", "mmwr_",
                                                           tolower(.x))) %>%
  mutate(year_week = ifelse(mmwr_week < 10, paste0(mmwr_year, " - ", "0", mmwr_week),
                            paste0(mmwr_year, " - ", mmwr_week))) %>%
  select(state, county, year_week, date, cases_7d_avg) %>%
  #mutate(cases_7d_avg = as.numeric(str_replace_all(cases_7d_avg, "suppressed", "0"))) %>%
  arrange(county, year_week)

### Suppressed cells need to be replaced with minimum observed cases by county.
# 0 values are not included when considering minimum number of cases.
supp <- clean_case %>% filter(cases_7d_avg != "suppressed" &
                                cases_7d_avg != 0) %>%
  mutate(cases_7d_avg = as.numeric(cases_7d_avg)) %>%
  group_by(county) %>%
  summarize(min_val = min(cases_7d_avg))
supp

# replace suppressed cells with values from supp
case_na <- clean_case %>% 
  mutate(cases_7d_avg = ifelse(county == "Bucks County" & 
                                 cases_7d_avg == "suppressed", 1.42857,
                        ifelse(county == "Burlington County" &
                                 cases_7d_avg == "suppressed", 1.57143,
                        ifelse(county == "Camden County" &
                                 cases_7d_avg == "suppressed", 1.42857,
                        ifelse(county == "Chester County" &
                                 cases_7d_avg == "suppressed", 1.42857,
                        ifelse(county == "Delaware County" &
                                  cases_7d_avg == "suppressed", 1.85714,
                        ifelse(county == "Gloucester County" &
                                 cases_7d_avg == "suppressed", 1.85714,
                        ifelse(county == "Mercer County" & 
                                 cases_7d_avg == "suppressed", 2.14286,
                        ifelse(county == "Montgomery County" &
                                 cases_7d_avg == "suppressed", 1.85714,
                        ifelse(county == "New Castle County" &
                                 cases_7d_avg == "suppressed", 2.14286,
                        ifelse(county == "Philadelphia County" &
                                 cases_7d_avg == "suppressed", 2.28571, cases_7d_avg))))))))))) %>%
  mutate(cases_7d_avg = as.numeric(cases_7d_avg))

# calculate mean of 7-day rolling case average by county and week
weekly_case <- case_na %>% group_by(county, year_week) %>%
  summarize(case_mean = mean(cases_7d_avg)) %>%
  arrange(county, year_week)

# transform data to get case_mean for next week
# so that this week can be compared to next week
next_case <- weekly_case %>%
  ungroup() %>%
  mutate(next_week_mean = lead(case_mean, 1), # use dplyr::lead to return next week's value
         next_week_mean = replace_na(next_week_mean, 0))
           
# add county population data to case data (based on 2019 U.S. Census estimates)
all_coun <- read_csv("all_counties_population.csv")
next_case_fi <- next_case %>% inner_join(all_coun, by = "county")


###############################################
# combine explanatory and outcome variables
# to create complete data set for analysis
###############################################
full_df <- next_case_fi %>% mutate(county_pop = population) %>%
  inner_join(explan, by = c("county" = "recip_county",
                            "year_week" = "year_week")) %>%
  mutate(vacc_incidence_per100thou = vacc_incidence_n / county_pop * 100000, 
         case_mean_per100thou = case_mean / county_pop * 100000, # rolling 7-day average of new cases per 100,000 population
         next_week_per100thou = next_week_mean / county_pop * 100000, # rolling 7-day average of next week's new cases per 100,000 population
         vacc_prevalence_per100thou = mean_fully_vacc_n / county_pop * 100000,
         next_week_increase = ifelse(next_week_per100thou > case_mean_per100thou, 1, 0)) %>% # is next week's mean greater than this week's mean?
  select(county, year_week, case_mean, case_mean_per100thou, next_week_mean,
         next_week_per100thou, next_week_increase, vacc_incidence_n,
         vacc_incidence_per100thou, mean_per_pop_fully_vacc, mean_fully_vacc_n, 
         vacc_prevalence_per100thou, mean_retail_rec, mean_grocery_pharm, mean_parks, 
         mean_transit_stations, mean_workplaces, mean_residential) %>%
  arrange(county, year_week) %>%
  filter(year_week != "2021 - 40") # this is first week of October; it was needed for 
                                   # comparing the final week of the study (2021-39) to 
                                   # next week, but it will not be included in analysis




########################################################
########################################################
               # Descriptive Analysis
########################################################
########################################################

covid <- full_df %>%
  mutate(next_week_increase = factor(next_week_increase,
                                     levels = c(0, 1),
                                     labels = c("no increase", "increase")))

# view data
glimpse(covid)

# check that each county has 86 rows
table(covid$county)

# check min and max year_week
min(covid$year_week) # 2020-07
max(covid$year_week) # 2021-39

#################################
# outcome variable x vaccination 
#################################

# next week increase or no increase 
table(covid$next_week_increase) # split is close to 50/50

# view summary stats of vaccine vars - overall
summary_df <- covid %>%
  select(mean_per_pop_fully_vacc, vacc_prevalence_per100thou,
         vacc_incidence_per100thou) %>%
  psych::describe(quant=c(.25,.75)) %>%
  as_tibble(rownames="rowname")  %>%
  select(-vars, -trimmed, -mad) %>%
  print()

# observations with increase
summary_inc <- covid %>% filter(next_week_increase == "increase") %>%
  select(mean_per_pop_fully_vacc, vacc_prevalence_per100thou,
         vacc_incidence_per100thou) %>%
  psych::describe(quant=c(.25,.75)) %>%
  as_tibble(rownames="rowname")  %>%
  select(-vars, -trimmed, -mad) %>%
  print()

# observations with no increase
summary_noinc <- covid %>% filter(next_week_increase == "no increase") %>%
  select(mean_per_pop_fully_vacc, vacc_prevalence_per100thou,
         vacc_incidence_per100thou) %>%
  psych::describe(quant=c(.25,.75)) %>%
  as_tibble(rownames="rowname")  %>%
  select(-vars, -trimmed, -mad) %>%
  print()

### The mean for mean_per_pop_fully_vacc and vacc_prevalence_per100thou
#  in the "increase" group is higher than for the "no increase" group. 
#  We expected the "no increase" group to have higher means for these variables.

### The mean for vacc_incidence_per100thou is higher in "no increase" group.

# boxplot for mean percentage of population fully vaccinated by outcome
ggplot(data = covid, aes(x = next_week_increase, y = mean_per_pop_fully_vacc)) +
  geom_boxplot(color = "darkorchid4", fill = "mediumpurple2")

# boxplot for mean vaccine prevalence by outcome
ggplot(data = covid, aes(x = next_week_increase, y = vacc_prevalence_per100thou)) +
  geom_boxplot(color = "magenta4", fill = "thistle")

# boxplot for mean vaccine incidence by outcome
ggplot(data = covid, aes(x = next_week_increase, y = vacc_incidence_per100thou)) +
  geom_boxplot(color = "darkblue", fill = "plum3")



########################
# plot with ggpairs
########################
df_clean <- covid %>% filter(complete.cases(.))

# limit dataframe to focus on specific predictor variables  
df_clean2 <- df_clean %>% 
  select(-county, -year_week, -case_mean, -case_mean_per100thou,
         -next_week_mean, -next_week_per100thou, -vacc_incidence_n,
         -vacc_incidence_per100thou, -mean_fully_vacc_n,
         -vacc_prevalence_per100thou) %>%
  rename(case_incr = next_week_increase,
         vacc = mean_per_pop_fully_vacc,
         retail = mean_retail_rec,
         grocery = mean_grocery_pharm,
         parks = mean_parks,
         transit = mean_transit_stations,
         workplace = mean_workplaces,
         residential = mean_residential)

# compare outcome and mean_per_pop_fully_vacc only
ggpairs(df_clean, mapping = aes(col = next_week_increase),
        columns = c("mean_per_pop_fully_vacc"),
        axisLabels = "show")

# compare all variables at once
ggpairs(df_clean2)


########################################################
########################################################
          # Logistic Regression Models
########################################################
########################################################

###############################################
# Fit univariate statistical models to find out 
# which variables are individually associated 
# with next_week_increase at a 
# nominally significant level.
###############################################

# scale vaccine variables (without centering)
covid$vacc_inc_per100thou_sc <- scale(covid$vacc_incidence_per100thou, center = FALSE)[, 1]
covidvacc_prev_per100thou_sc <- scale(covid$vacc_prevalence_per100thou, center = FALSE)[, 1]

covid_clean <- covid %>% select(-county, -year_week,
                                -case_mean_per100thou, -case_mean,
                                -next_week_mean, -next_week_per100thou,
                                -vacc_incidence_n, -mean_fully_vacc_n) 


# generate multiple models and save output to df
glm_output <- covid_clean %>%
  select(-next_week_increase, -vacc_incidence_per100thou,
         -vacc_prevalence_per100thou) %>%
  names() %>%
  paste("next_week_increase ~", .) %>%
  map_df(~tidy(glm(as.formula(.x), 
                   data = covid_clean, 
                   family = "binomial"), 
               estimate = TRUE,
               conf.int = TRUE, 
               exponentiate = TRUE)) %>%
  filter(term != "(Intercept)") %>%
  rename(odds.ratio = estimate) %>%
  arrange(p.value)


#####################################
# model using significant predictors
#####################################

# fit model
mod_vacc <- glm(next_week_increase ~ vacc_inc_per100thou_sc + mean_retail_rec,
                data = covid, family = "binomial")

# check model output
tidy(mod_vacc, conf.int = TRUE, exponentiate = TRUE)

# check for multicollinearity
car::vif(mod_vacc) # variance inflation factors are low, so no issues 

# store predicted values of training data
vacc_pred <- predict(mod_vacc, covid, type = "response") 
head(vacc_pred)


########################################################
########################################################
#           10-fold cross validation
########################################################
########################################################

# use 10-fold cross validation to train and test model
N = nrow(covid)
K = 10
set.seed(1234)
s = sample(1:K, size = N, replace = T)
pred_outputs <- vector(mode = "numeric", length = N)
obs_outputs <- vector(mode = "numeric", length = N)
offset <- 0
for (i in 1:K) {
  train <- filter(covid, s != i)
  test <- filter(covid, s == i)
  obs_outputs[1:length(s[s == i]) + offset] <- test$next_week_increase
  
  # GLM train/test
  glm <- glm(next_week_increase ~ vacc_inc_per100thou_sc + mean_retail_rec, 
             data = train, family = "binomial")
  glm_pred_curr <- predict(glm, test, type = "response")
  pred_outputs[1:length(s[s == i]) + offset] <- glm_pred_curr
  
  offset <- offset + length(s[s == i])
}
head(cbind(pred_outputs, obs_outputs))



########################################################
########################################################
#           Predictive Models
########################################################
########################################################

# fit model
mod_all <- glm(next_week_increase ~ vacc_inc_per100thou_sc + mean_retail_rec +
                  mean_grocery_pharm + 
                  mean_parks + mean_workplaces +
                  mean_transit_stations, data = covid, family = "binomial")

vif(mod_all)

# store predicted values of training data
all_pred <- predict(mod_all, covid, type = "response") 
head(all_pred)

# use 10-fold cross validation to train and test model
N = nrow(covid)
K = 10
set.seed(1234)
s = sample(1:K, size = N, replace = T)
pred_outputs <- vector(mode = "numeric", length = N)
obs_outputs <- vector(mode = "numeric", length = N)
offset <- 0
for (i in 1:K) {
  train <- filter(covid, s != i)
  test <- filter(covid, s == i)
  obs_outputs[1:length(s[s == i]) + offset] <- test$next_week_increase
  
  # GLM train/test
  glm <- glm(next_week_increase ~ vacc_inc_per100thou_sc + mean_retail_rec +
                mean_grocery_pharm + 
                  mean_parks + mean_workplaces +
                  mean_transit_stations, 
             data = train, family = "binomial")
  glm_pred_curr <- predict(glm, test, type = "response")
  pred_outputs[1:length(s[s == i]) + offset] <- glm_pred_curr
  
  offset <- offset + length(s[s == i])
}
head(cbind(pred_outputs, obs_outputs))


roc(covid$next_week_increase, all_pred, ci = TRUE) # training data
roc(obs_outputs, pred_outputs, ci = TRUE) # test data


```




### Results
Describe your results and include relevant tables, plots, and code/comments used to obtain them. End with a brief conclusion of your findings related to the question you set out to address. You can include references if you'd like, but this is not required.

### Independent Variables
The investigators hypothesized that mean vaccine prevalence per population (vacc_prevalence_per100thou) would be significantly associated with change in case incidence per population. However, mean vaccine incidence per population was identified as significant at p < 0.05 in the bivariate modeling stage. In addition, one Google social mobility variable, mean retail and recreation, was significantly associated with mean case increase or no increase.


``` {r, eval = TRUE, message = FALSE}

# table of individual predictors of case increase
glm_output



```


As a final step, the areas  under the curve (AUC) for training and test sets are calculated, and the corresponding receiver operating characteristic (ROC) curves are generated. The AUCs are 0.63 and 0.62 for training and test data, respectively. These numbers indicate that the predictive accuracy is not very good, and therefore, the model does not distinguish well between no case increase and case increase. The plot of the ROC curves illustrate that the model does not have a very good measure of separability.

Additionally, the AUCs for training and test data are very similar.
 
``` {r, eval = TRUE, message = FALSE}

#############################################
# evaluate model using ROC curve analysis
#############################################

# calculate area under the ROC curve
roc(covid$next_week_increase, vacc_pred, ci = TRUE) # training data
roc(obs_outputs, pred_outputs, ci = TRUE) # test data

# plot ROC curves for training and test data
plot.roc(covid$next_week_increase, vacc_pred, ci = TRUE, col = "darkblue", lwd = 3)
plot.roc(obs_outputs, pred_outputs, ci = TRUE, col = "mediumorchid2", add = TRUE, lwd = 3) #CV of glm
legend("bottomright", legend = c("GLM Logistic", "GLM Logistic Cross-Validation"), 
       col = c("darkblue", "mediumorchid2"), lwd = 3)

```


### References
https://ndc.services.cdc.gov/wp-content/uploads/MMWR_Week_overview.pdf