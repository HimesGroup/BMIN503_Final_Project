---
title: "BMIN503/EPID600 Bulk RNA Sequencing Project"
author: "Hongbo Wen"
output: 
  html_document:
    theme: paper 
    highlight: tango
---
```{r set-options, echo=FALSE, cache=FALSE}
options(width = 400)
```  
***
Use this template to complete your project throughout the course. Your Final Project presentation will be based on the contents of this document. Replace the title/name above and text below with your own, but keep the headers.

### Overview
The topic of this project focuses on bulk RNA-sequencing of lung alveolar type II cells from hyperoxia-injuryed mice. The goal is to see what is the difference in gene expression between alveolar type II cells derived from alveolar type I cells and the rest of the alveolar type II cells. The unpublished sequencing data used in this project comes from Dr. David B. Frank's lab which I currently work in. I first talked with my PI Dr. David B Frank who is a pediatrian at Children's Hospital of Philadelphia focusing on pulmonary diseases to have a better understanding of the motivation behind this preliminary bulk RNA-sequencing and how the results of this experiment can be applied in the medical field. Then I talked with Dr. Prashant Chandrasekaran who is a PhD in Dr. Frank lab with a lot of wet lab experience with mice to learn the details of the experimental procedures. Finally, I talked with Dr. Mengyuan Kan, a postdoctoral in the Department of Biostatistics, Epidemiology and Informatics, at the University of Pennsylvania, working with Dr. Blanca E. Hime, who guides me to analyze the bulk RNA-sequencing data and obtain differential gene expression results. The link to my final project GitHun repository is below: 

https://github.com/wenhongbo18/BMIN503_Final_Project


### Introduction 
Bronchopulmonary dysplasia (BPD) is a chronic lung disease common in premature infants caused by aggressive mechanical ventilator approach on a relatively mature lung lacking surfactant (Davidson et al., 2017; Thebaud et al., 2019). The additional pressure from the ventilation will damage the alveoli, where the gas exchange takes place. Short-term symptoms of BPD include rapid, labored breathing, difficult feeding, repeated lung infections and can eventually lead to asthma-like symptoms, exercise intolerance, and pulmonary arterial hypertension. Almost 50,000 infants were born with less than 28 weeksâ€™ gestation each year in the USA, and approximately 35% of these children develop BPD (Thebaud et al., 2019). Due to the lack of understanding on the mechanisms of BPD, choices of prevention and treatment remain limited and inefficient. Lung alveoli are composed of two types of cells: elongated alveolar type I (AT1) cells which are the site of gas exchange and cuboidal alveolar type II (AT2) cells whose major role is to produce surfactant which lowers the surface tension of alveoli and makes sure they do not collpase when expanding. Previous studies have demonstrated the plasticity of AT2 progenitor cells and how they can differentiate and proliferate to heal the injuried alveoli in adult mice (Barkauskas et al., 2013). Compared to AT2 cells, AT1 cells were previously believed to lack plasticity and cannot change their cell fates. However, a recent study shows that upon acute neonatal lung injury, AT1 cells reprogram into AT2 cells, promoting alveolar regeneration. Considering these background information, our research group asks the question what signaling pathways govern the plasticity of AT1 cells. The answer to this question will have great application in treating BPD. Researchers can find ways to upregulate or downregulate these signaling pathways to increase plasticity of AT1 cells, thereby promoting the healing of alveolar damage caused by BPD.

An interdisciplinary approach is needed to solve this problem. A strong biology and chemistry background is needed to design the experiment, choose the right mice model, and obtain the specific types of cells. Afterwards, biomedical informatics knowledge comes in to help organize the data, perform statistical analysis, and locate the genes that have the highest difference in expression between two population of the cells. Then, a good interpretation of the data requires a comprehensive understanding of genetics. After finding relevant genes, the search of existing medications that target related signaling pathway and the determination of the effectiveness of such medications need perspectives from the clinical side.

### Methods
Describe the data used and general methodological approach. Subsequently, incorporate full R code necessary to retrieve and clean data, and perform analysis. Be sure to include a description of code so that others (including your future self) can understand what you are doing and why. 

The mouse model used in this experiment was the HopXCre R26Rtdtomato SPC-GFP mice. Due to the gentic design, all the AT2 cells were marked with a green color by the green fluroscent protein (GFP), but only the AT1-derived AT2 cells also expressed a red color (tdtomato) from the Cre-LoxP lineage tracing design. Because ths is only a preliminary experiment conducted in my lab, only two mice were used named 927_1 and 980_3. Since we were interested in exploring the AT1 and AT2 cells fate after injury, the two mice were put in the hyperoxia chamber at 90% of oxygen level for four days to mimic the conditions of BPD. The mice were then transported to live in normal condition until postnatal day 42. The lungs were then harvested, single cell suspension was achieved, and samples were submitted to flow cytometry after appropriate antibody staining.Two cell populations were harvested through flow cytometry: AT1-derived AT2 cells (GFP-tdtomato) and other AT2 cells (GFP). Bulk RNA-sequencing is performed on these two sets of cells to see what difference in gene expression explains this phenotype. The two different groups of cells underwent cell lysis, mRNA extraction, mRNA fragmentation, reverse transcription to cDNA, PCR amplification, ligation of sequence adaptors, and size selection. Afterwards, the samples were put into the flow cells of Illumina sequencer to obtain the sequence of all the cDNAs, and the data was stored in a hard drive. 

All the data was processed on a remote server at Dr. Himes lab, so the first step is to transfer all the data into the remote server. A PMACS account was set up for me to use. Linux command is used below. 

1. Login to the server, use the command:

ssh hwen@bhimes.pmacs.upenn.edu

2. Under the RNASeq folder, create a folder called Lung_AT2: 

mkdir -p /projects/RNASeq/Lung_AT2

3. Transfer all the sequencing data into this folder:

scp -r (full path of the data folder on my computer) hwen@bhimes.pmacs.upenn.edu:/projects/RNASeq/Lung_AT2
df -h

4. Initialize the python 2.7: 

conda activate py2

5. Create a folder named files and inside that folder create a txt file called Lung_AT2_Phenotype_withoutQC.txt. 

The Lung_AT2_Phenotype_withoutQC.txt file has 8 columes: 

Sample: Sample name
Donor: Names of the mice that the samples were from
Tissue: Type of the tissue the cells came from. Here it is alveolar type 2 cells from lung tissues. 
Treatment: Hyperoxia injury
Disease: All mice were healthy beforehand
Status: This used for comparison. We have two groups: AT2 cells derived from AT1 cells (AT2_AT1) and other AT2 cells (AT2)
R1: directory of the R1 read (5' direction of the top strand)
R2: directory of the R2 read (5' direction of the bottom strand)

mkdir -p /projects/RNASeq/Lung_AT2/files

cd /projects/RNASeq/Lung_AT2/files

cat > Lung_AT2_Phenotype_withoutQC.txt

```{r eval = TRUE, message = FALSE}
library(readr)
withoutQC <- read_csv("~/Downloads/RNASeq.csv")
head(withoutQC)
```



6.  Run pipeline scripts/rnaseq align and qc.py to: 1) trim adapter and primer sequences if index information is available, 2) run FastQC for (un)trimmed .fastq files, 3) align reads and quantify reads mapped to genes/transcripts, and 4) obtain various QC metrics from .bam files. At the end of these steps, the readcount file was generated: 

mkdir -p /projects/RNASeq/Lung_AT2/scripts/align

cd /projects/RNASeq/Lung_AT2/scripts/align

rnaseq_align_and_qc.py --project_name Lung_AT2 --samples_in /projects/RNASeq/Lung_AT2/files/Lung_AT2_Phenotype_withoutQC.txt --aligner star --ref_genome mm10 --library_type PE --strand nonstrand --path_start /projects/RNASeq/Lung_AT2 --template_dir /projects/pipelines/RNASeq

mk_lsf2bashsub.py --path /projects/RNASeq/Lung_AT2/scripts/align --lsf_dir /projects/RNASeq/Lung_AT2/scripts/align --job_name align --nthread 1 & 
echo $! > /projects/RNASeq/Lung_AT2/scripts/align/align.jobid

jobid=`cat /projects/RNASeq/Lung_AT2/scripts/align/align.jobid`
ps -A | grep $jobid

7. create an HTML report of QC and alignment summary statistics for RNA-seq samples:

mkdir -p /projects/RNASeq/Lung_AT2/scripts/qc_report

cd /projects/RNASeq/Lung_AT2/scripts/qc_report

rnaseq_align_and_qc_report.py --project_name Lung_AT2 --samples_in /projects/RNASeq/Lung_AT2/files/Lung_AT2_Phenotype_withoutQC.txt --aligner star --ref_genome mm10 --library_type PE --strand nonstrand --path_start /projects/RNASeq/Lung_AT2 --template_dir /projects/pipelines/RNASeq

bash /projects/RNASeq/Lung_AT2/scripts/qc_report/Lung_AT2_qc.lsf > Lung_AT2_qc.log 2>&1 & echo $! > /projects/RNASeq/Lung_AT2/scripts/qc_report/qc_report.jobid

jobid=`cat /projects/RNASeq/Lung_AT2/scripts/qc_report/qc_report.jobid`
ps -A | grep $jobid

8. Inside the file folder create two txt files called Lung_AT2_Phenotype_withQC.txt, and Lung_AT2_comp_file.txt.

The Lung_AT2_Phenotype_withoutQC.txt file has 9 columes: 

Sample: Sample name
Donor: Names of the mice that the samples were from
Tissue: Type of the tissue the cells came from. Here it is alveolar type 2 cells from lung tissues. 
Treatment: Hyperoxia injury
Disease: All mice were healthy beforehand
Status: This used for comparison. We have two groups: AT2 cells derived from AT1 cells (AT2_AT1) and other AT2 cells (AT2)
R1: directory of the R1 read (5' direction of the top strand)
R2: directory of the R2 read (5' direction of the bottom strand)
QC_Pass: 1 if the sample QC is good and can be included in the following DE analysis; 0 if the sample QC is bad and should be excluded in the following DE analysis. (Note: this is done after the QC report is generated. All the samples have good QCs and can be used in the following DE analysis)

The Lung_AT2_comp_file.txt file has 3 columes: 

Condition1: AT2 cells derived from AT1 cells (AT2_AT1)
Condition0: other AT2 cells (AT2)
Design: paired:Donor. This specifies whether this sample is paired with another sample for comparison. All of the 4 samples used were paired. 

mkdir -p /projects/RNASeq/Lung_AT2/files

cd /projects/RNASeq/Lung_AT2/files

cat > Lung_AT2_Phenotype_withQC.txt

cat > Lung_AT2_comp_file.txt

```{r eval = TRUE, message = FALSE}
library(readr)
withQC <- read_csv("~/Downloads/withQC.csv")
head(withQC)

comp <- read_csv("~/Downloads/comp.csv")
head(comp)
```

9. Perform DE analysis and create an HTML report of differential expression summary statistics. At the end of these steps, the readcount file was generated: 

mkdir -p /projects/RNASeq/Lung_AT2/scripts/deseq2

cd /projects/RNASeq/Lung_AT2/scripts/deseq2

rnaseq_de_report.py --project_name Lung_AT2 --samples_in /projects/RNASeq/Lung_AT2/files/Lung_AT2_Phenotype_withQC.txt --comp /projects/RNASeq/Lung_AT2/files/Lung_AT2_comp_file.txt --de_package deseq2 --ref_genome mm10 --path_start /projects/RNASeq/Lung_AT2 --template_dir /projects/pipelines/RNASeq

bash /projects/RNASeq/Lung_AT2/scripts/deseq2/Lung_AT2_deseq2.lsf > Lung_AT2_deseq2.log 2>&1 &
echo $! > /projects/RNASeq/Lung_AT2/scripts/deseq2/Lung_AT2_deseq2.jobid

jobid=`cat /projects/RNASeq/Lung_AT2/scripts/deseq2/Lung_AT2_deseq2.jobid`
ps -A | grep $jobid

10. Copy all the files needed from the remote server to my laptop: 

scp -r hwen@bhimes.pmacs.upenn.edu:/projects/RNASeq/Lung_AT2/Lung_AT2_deseq2_out/ /Users/tony/Downloads

scp -r hwen@bhimes.pmacs.upenn.edu:/projects/RNASeq/Lung_AT2/scripts /Users/tony/Downloads

scp -r hwen@bhimes.pmacs.upenn.edu:/projects/RNASeq/Lung_AT2/files /Users/tony/Downloads

scp -r hwen@bhimes.pmacs.upenn.edu:/projects/RNASeq/Lung_AT2/Lung_AT2_Alignment_QC_Report_star /Users/tony/Downloads

### Results

**Quality Control**

**Project:** Lung_AT2

**Aligner:** STAR (2.7.6a)

**Genome:** For mouse, the UCSC mm10 assembly available in iGenomes was used.


**Informatics tools used:**

* Trimmomatic (0.39)
* FastQC (v0.11.9)
* STAR (2.7.6a)
* samtools (1.10)
* bamtools (2.5.1)
* Picard Tools (2.22.0)


**Sequencing parameters:**

* library_type = PE
* strand = nonstrand
* ref_genome = mm10

For each sample, the following programs were run to generate the data necessary to create this report. Written as for unstranded paired-end data. For single-end reads, R2s and insert size metrics would be omitted. <br> 

> java -Xmx1024m TrimmomaticPE -phred33 [raw_sample_R1] [raw_sample_R2] [sample_R1] [sample_R1_unpaired] [sample_R2] [sample_R2_unpaired] HEADCROP:[bases to trim, if any] ILLUMINACLIP:[sample_primer_fasta]:2:30:10 MINLEN:50<br> <br>
> fastqc [sample_R1] [sample_R2] <br> <br>
> cat [sample_R1/R2] | awk '((NR-2)%4==0){read=$1;total++;count[read]++}END{for(read in count){if(count[read]==1){unique++}};print total,unique,unique*100/total}' <br>


The following STAR options were used: <br>

> STAR --genomeDir [ref_genome_index] --runThreadN 12 --outReadsUnmapped Fastx --outMultimapperOrder Random --outSAMmultNmax 1 --outFilterIntronMotifs RemoveNoncanonical --outSAMstrandField intronMotif --outSAMtype BAM SortedByCoordinate --readFilesIn [sample_R1] [sample_R2] <br>


Using aligned output files accepted_hits.bam and unmapped.bam:<br>

> samtools sort accepted_hits.bam accepted_hits.sorted <br><br>
> samtools index accepted_hits.sorted.bam <br><br>
> samtools idxstats accepted_hits.sorted.bam > accepted_hits.sorted.stats <br><br>
> bamtools stats -in accepted_hits.sorted.bam > accepted_hits.sorted.bamstats <br><br>
> bamtools filter -in accepted_hits.sorted.bam -script cigarN.script | bamtools count <br><br>
> samtools view -c unmapped.bam <br><br>
> java -Xmx2g -jar CollectRnaSeqMetrics.jar REF_FLAT=[ref_flat file] STRAND_SPECIFICITY=NONE INPUT=accepted_hits.bam OUTPUT=RNASeqMetrics <br><br>
> java -Xmx2g -jar CollectInsertSizeMetrics.jar HISTOGRAM_FILE=InsertSizeHist.pdf INPUT=accepted_hits.sorted.bam OUTPUT=InsertSizeMetrics (for paired-end library) <br>

The following R codes generate the readcounts.

```{r vars, echo=F}
project_name="Lung_AT2"
path.start="/projects/RNASeq/Lung_AT2/Lung_AT2_Alignment_QC_Report_star/"
sample.names.orig <- c('DF_927_1_GFP_tdt', 'DF_927_1_GFP', 'DF_980_3_GFP_tdt', 'DF_980_3_GFP')
sample.names <- sample.names.orig
genome="mm10"
library_type="PE"
aligner="star"
sample_info_file='/projects/RNASeq/Lung_AT2/files/Lung_AT2_Phenotype_withoutQC.txt'
count_data_file='/projects/RNASeq/Lung_AT2/Lung_AT2_Alignment_QC_Report_star/Lung_AT2_htseq_gene.txt'
```

```{r, eval=T, echo=F, message=F}
setwd("/Users/tony/BMIN503_Final_Project/Lung_AT2_Alignment_QC_Report_star")
metrics.data <- read.table(paste(project_name,"_rnaseqmetrics_hist.txt", sep=""), header=T)
counts.data <- read.table(paste(project_name,"_counts.txt", sep=""), header=T, sep="\t")
#ercc.data <- read.table(paste(project_name,"_ERCC.txt", sep=""), header=T, as.is=T)
summary.data <- read.table(paste(project_name,"_rnaseqmetrics_summary.txt", sep=""), header=T, as.is=T, sep="\t")
bamstats.data <- read.table(paste(project_name,"_bamstats_counts.txt", sep=""), header=T, as.is=T, sep="\t")
if (library_type %in% c("PE")) {
  insert.summary.data <- read.table(paste(project_name,"_insertmetrics_summary.txt", sep=""), header=T, as.is=T, sep="\t")
  insert.metrics.data <- data.frame(c(0:1))
  names(insert.metrics.data) <- "Insert_Size"
  for (i in c(1:length(sample.names))){
    curr.hist.data <- read.table(paste(project_name,"_",sample.names[i],"_insertmetrics_hist.txt", sep=""), header=T, as.is=T, sep="\t")
    insert.metrics.data <- merge(insert.metrics.data, curr.hist.data, all=TRUE)
  }
  write.table(insert.metrics.data,paste(project_name,"_insertmetrics_hist.txt", sep=""), col.names=T, row.names=F, sep='\t', quote=F)
}
unique.counts.data <- read.table(paste(project_name,"_unique_counts.txt", sep=""), header=T, sep="\t")
duplicates <- read.table(paste(project_name,"_duplicates.txt", sep=""), header=T, sep="\t", as.is=T)
```

```{r lib, echo=F, message=F, warnings=F}
library(tidyr)
library(RColorBrewer)
library(DT)
library(ggplot2)
library(gplots)
library(viridis)
library(DESeq2)
library(biomaRt)
library(fgsea)
library(pander)
options(width = 1000)
```

## Summary Read Numbers 

The number of raw reads correspond to those that passed Casava QC filters, were trimmed to remove adaptors by Trimmomatic, and were aligned by STAR to ref_genome+ERCC transcripts as reported in .info files. Unique read counts were obtained by using awk on trimmed fastq files. FastQC estimates of percentage of sequences remaining after deduplication were retrieved from fastqc_data.txt files. Bamtools statistics were based on sorted and indexed bam files. The mapped reads were those that mapped to reference and were output by STAR to accepted_hits.bam. The unmapped reads were output by STAR to unmapped.bam. Some reads may be mapped to multiple locations in the genome so that the number of total reads reported by bamstats may be greater than the number of raw reads. The Junction spanning reads are computed based on accepted_hits.bam CIGAR entries containing "N." Related text files that were saved:

```{r, eval=T, echo=F, message=FALSE, results='asis'}
cat(project_name, "_read_counts.txt\n\n", project_name, "_duplicates.txt\n\n", project_name, "_unique_counts.txt\n\n", project_name, "_bamstats_counts.txt\n\n")
```

### Total Number of Raw Reads Summary

Read counts are shown by per million reads.


```{r, eval=T, echo=F, message=FALSE}
if (library_type %in% c("PE")) {	
    R1_dups <- unname(unlist(duplicates[which(duplicates$Read_Number=="Total Deduplicated Percentage"),which(grepl("_R1$",names(duplicates)))])) # extract total duplicate reads for R1
    unique.counts.data.2 <- cbind(unique.counts.data, R1_dups)
    R2_dups <- unname(unlist(duplicates[which(duplicates$Read_Number=="Total Deduplicated Percentage"),which(grepl("_R2$",names(duplicates)))])) # extract total duplicate reads for R2
    unique.counts.data.2 <- cbind(unique.counts.data.2, R2_dups)
    unique.counts.data.2$Fastqc_Total_Deduplicated_Percentage_R1 <- unique.counts.data.2$R1_dups
    unique.counts.data.2$Fastqc_Total_Deduplicated_Percentage_R2 <- unique.counts.data.2$R2_dups
    unique.counts.data.2$R1_dups <- NULL
    unique.counts.data.2$R2_dups <- NULL
    # format the table
    pct_cols <- c("R1_Percent_Unique","R2_Percent_Unique","Fastqc_Total_Deduplicated_Percentage_R1","Fastqc_Total_Deduplicated_Percentage_R2")
    unique.counts.data.2[,pct_cols] <- round(unique.counts.data.2[,pct_cols],2)
    ct_cols <- c("R1_Raw_Reads","R1_Unique_Reads","R2_Raw_Reads","R2_Unique_Reads")
    unique.counts.data.2[,ct_cols] <- round(unique.counts.data.2[,ct_cols]/1000000,2)
} else {
    R1_dups <- unname(unlist(duplicates[which(duplicates$Read_Number=="Total Deduplicated Percentage"),which(grepl("_R1$",names(duplicates)))])) # extract total duplicate reads for R1
    unique.counts.data.2 <- cbind(unique.counts.data, R1_dups)
    unique.counts.data.2$Fastqc_Total_Deduplicated_Percentage <- unique.counts.data.2$R1_dups
    unique.counts.data.2$R1_dups <- NULL
    # format the table
    pct_cols <- c("Percent_Unique","Fastqc_Total_Deduplicated_Percentage")
    unique.counts.data.2[,pct_cols] <- round(unique.counts.data.2[,pct_cols],2)
    ct_cols <- c("Raw_Reads","Unique_Reads")
    unique.counts.data.2[,ct_cols] <- round(unique.counts.data.2[,ct_cols]/1000000,3)
}
DT::datatable(unique.counts.data.2, rownames = FALSE, options = list(pageLength = 25))
```


### Plot: Percentage of Unique Reads in Original Fastq File

```{r, eval=T, echo=F, message=FALSE, warning=FALSE, , fig.width=13, fig.height=10}
if (library_type %in% c("PE")) {
	unique.counts.only <- unique.counts.data[,c("Sample","R1_Percent_Unique","R2_Percent_Unique")]	
	#if sample names start with a number, append "x" to names - else get an error.
	if (substring(unique.counts.only$Sample[1], 1, 1) %in% c("0","1","2","3","4","5","6","7","8","9")) { # only need to test one sample name
		unique.counts.only$Sample <- paste0("x",unique.counts.only$Sample)
	}
	unique.counts.only <- unique.counts.only %>% tidyr::gather(variable, value, -Sample)
	ggplot(unique.counts.only, aes(x=Sample, y=value, fill=variable))+ 
		geom_bar(stat="identity", position="dodge") +
		scale_fill_manual(values=c("navy", "firebrick")) +
		labs(title=project_name, x="Sample", y="Percentage of Unique Reads in Original Fastq File") +
		ylim(0, 100) +
		theme_bw() +
		theme(axis.text.x = element_text(angle = 90, hjust = 1, size=14),
		legend.title = element_blank(),
		legend.text = element_text(size = 16),
            	axis.text.y = element_text(size=14),
            	plot.title = element_text(size=18, hjust=0.5, face="bold"),
            	axis.title = element_text(size=18))
} else {
	ggplot(data = unique.counts.data, aes(x = Sample, y = Percent_Unique)) + 
		geom_bar(stat="identity", fill="firebrick") +
		labs(title=project_name, x="Sample", y="Percentage of Unique Reads in Original Fastq File") +
		ylim(0, 100) +
		theme_bw() +
		theme(axis.text.x = element_text(angle = 90, hjust = 1, size=14),
            	axis.text.y = element_text(size=14),
            	plot.title = element_text(size=18, hjust=0.5, face="bold"),
		axis.title = element_text(size=18))
}
```

### Plot: Sequence Duplication Level

```{r dup_plot, eval=T, echo=F, message=FALSE, fig.width=12, fig.height=10}
dup.data <- duplicates
dup.data <- dup.data[which(dup.data$Read_Number!="Total Deduplicated Percentage"),]
dup.data$Read_Number <- 1:(nrow(duplicates)-1)
dup.data <- dup.data %>% tidyr::gather(Sample,value,-Read_Number)
# dup.data$Sample2 <- sapply(as.character(dup.data$Sample), function(x){strsplit(x, "_R1|_R2")[[1]]}) # this command does not work for samples with _R1 and _R2 already in the sample name
# create a temperaray sample data frame
sampleframe_R1=data.frame(Sample2=sample.names, Sample=paste0(sample.names,"_R1"))
sampleframe_R2=data.frame(Sample2=sample.names, Sample=paste0(sample.names,"_R2"))
sampleframe = rbind(sampleframe_R1, sampleframe_R2)
# create Sample2 column without read "_R1" or "_R2" suffix
dup.data <- merge(sampleframe, dup.data, by="Sample", all.y=T)

nsamp=ncol(duplicates)-1
# dup.org <- 1:(nrow(duplicates)-1)
# shift=unlist(lapply(1:nsamp, function(i){dup.org+delta*(i-1)}))
# dup.data$Read_Number <- shift
c <- rep(brewer.pal(12,"Paired"), nsamp)
# plot
ggplot(dup.data, aes(x=Read_Number,y=value,group=Sample2,color=Sample2)) +
    geom_line() +
    ggtitle(project_name) +
    xlab("Sequence Duplication Level") +
    ylab("Percentage of Total Sequences") +
    scale_x_continuous(breaks=seq(0,nrow(duplicates)-1,by=2)) +
    ylim(0, 100) +
    #scale_y_continuous(breaks=seq(0,100,by=20)) +
    scale_color_manual(values = c) +
    theme_bw() +
    theme(
        plot.title = element_text(size=18, hjust=0.5, face="bold"),
        legend.title = element_blank(),
        legend.text = element_text(size = 16),
        axis.text.y = element_text(size=16),
        axis.text.x  = element_text(size=16),
        axis.title = element_text(size=18))
```

### Bamtools Reads Summary

```{r, eval=T, echo=F, message=FALSE}
bamstats.summary <- bamstats.data
row.names(bamstats.summary)=bamstats.summary$Type
bamstats.summary$Type=NULL
if (library_type %in% c("PE")) { # total read counts from fastq
  total_reads=unique.counts.data$R1_Raw_Reads+unique.counts.data$R2_Raw_Reads
  bamstats.summary <- bamstats.summary[!row.names(bamstats.summary)%in%c("Failed QC","Duplicates"), , drop=FALSE]
} else {
  # total read counts from fastq
  total_reads=unique.counts.data$Raw_Reads
  bamstats.summary <- bamstats.summary[!row.names(bamstats.summary)%in%c("Failed QC","Duplicates","Paired-end reads"), , drop=FALSE]
}
bamstats.summary["Total reads",]=total_reads
unmapped_reads <- bamstats.summary["Total reads",] - bamstats.summary["Mapped reads",]
row.names(unmapped_reads) <- "Unmapped reads"
bamstats.summary <- rbind(bamstats.summary, unmapped_reads)
DT::datatable(bamstats.summary, options = list(pageLength = 25))
```


### Bamtools Reads Summary As Percentage of Mapped Reads

```{r, eval=T, echo=F, message=FALSE}
bamstats.percent.table=do.call(rbind,apply(bamstats.summary,1,function(x){round(x/bamstats.summary[1,]*100,2)}))
DT::datatable(bamstats.percent.table, options = list(pageLength = 25))
```

### Percentage of Mapped/Unmapped Reads

```{r, eval=T, echo=F, message=FALSE}
DT::datatable(bamstats.percent.table[c("Mapped reads","Unmapped"),], options = list(pageLength = 25))
```

### Plot: Percentage of Mapped/Unmapped Reads

```{r, eval=T, echo=F, message=FALSE,fig.width=10, fig.height=8}
mapped.percent.for.plot <- rbind(
  data.frame(
    variable=colnames(bamstats.percent.table),
    value=as.numeric(bamstats.percent.table["Mapped reads",]),
    Type=rep("Mapped",ncol(bamstats.percent.table))),
  data.frame(
    variable=colnames(bamstats.percent.table),
    value=as.numeric(bamstats.percent.table["Unmapped reads",]),
    Type=rep("Unmapped",ncol(bamstats.percent.table)))
)
mapped.percent.for.plot$Type <- factor(mapped.percent.for.plot$Type, levels=c("Unmapped", "Mapped")) # order so mapped reads are at the bottom 

ggplot(data = mapped.percent.for.plot, aes(x = variable, y = value, fill=Type)) + 
	geom_bar(stat="identity") +
	scale_fill_manual(values=c("navy", "firebrick")) +
	labs(title=project_name, x="Sample", y="Percentage of Total Reads") +
	ylim(0, 100) +
	theme_bw() +
	theme(axis.text.x = element_text(angle = 90, hjust = 1, size=14),
		legend.title = element_blank(),
		legend.text = element_text(size = 16),
           	axis.text.y = element_text(size=16),
         	plot.title = element_text(size=18, hjust = 0.5, face="bold"),
           	axis.title.x = element_text(size=18),
         	axis.title.y = element_text(size=18))
```

### Plot: Percentage of Junction Spanning Reads Among Mapped Reads

```{r junc_plot, eval=T, echo=F, message=FALSE, warning=F, fig.width=8, fig.height=10}

junc.for.table <- data.frame(
	Sample=colnames(bamstats.percent.table),
	value=as.numeric(bamstats.percent.table["Junction Spanning Reads",])
)

ggplot(data = junc.for.table, aes(x = Sample, y = value)) + 
	geom_bar(stat="identity", fill="firebrick") +
	labs(title=project_name, x="Sample", y="Percentage of Junction Spanning Reads Among Mapped Reads") +
	ylim(0, ceiling(max(junc.for.table$value, na.rm=T))) +
	theme_bw() +
	theme(axis.text.x = element_text(angle = 90, hjust = 1, size=14),
		legend.title = element_blank(),
		legend.text = element_text(size = 16),
           	axis.text.y = element_text(size=16),
         	plot.title = element_text(size=18, hjust = 0.5, face="bold"),
           	axis.title.x = element_text(size=18),
         	axis.title.y = element_text(size=18))
```


## RnaSeqMetrics Summary

The Picard Tools RnaSeqMetrics function computes the number of bases assigned to various classes of RNA. It also computes the coverage of bases across all transcripts (normalized to a same-sized reference). Computations are based on comparison to a refFlat file. Related text files that were saved:

```{r, eval=T, echo=F, message=FALSE, results='asis'}
cat(project_name, "_rnaseqmetrics_summary.txt\n\n", project_name, "_rnaseqmetrics_hist.txt\n\n")
```

The Picard Tools RnaSeqMetrics function computes the number of bases assigned to various classes of RNA. It also computes the coverage of bases across all transcripts (normalized to a same-sized reference). Computations are based on comparison to a refFlat file. Related text files that were saved:

```{r, eval=T, echo=F, message=FALSE, results='asis'}
cat(project_name, "_rnaseqmetrics_summary.txt\n\n", project_name, "_rnaseqmetrics_hist.txt\n\n")
```

### Reference Genome Mapped Reads Summary

```{r, eval=T, echo=F, message=FALSE}
sum.data <- summary.data
row.names(sum.data) <- sum.data$Type
sum.data$Type <- NULL
# exclude rows
row_excl <- !row.names(sum.data)%in%c("RIBOSOMAL_BASES", "PCT_RIBOSOMAL_BASES", "SAMPLE", "LIBRARY", "READ_GROUP")
sum.data <- sum.data[row_excl,]
# row numbers that contain percentage
pct_nrow <- grepl("PCT",row.names(sum.data))
# replace percentage with round 2
sum.data[pct_nrow,] <- apply(sum.data[pct_nrow,], 2, function(x){round(as.numeric(x)*100,2)})
DT::datatable(sum.data, options = list(pageLength = 25))
```

### Plot: Percentages of Total Mapped Bases Mapping to mRNA, Intronic and Intergenic Regions

```{r, eval=T, echo=F, message=FALSE, fig.width=10, fig.height=10}
sum.data.for.plot <- sum.data[c("PCT_INTERGENIC_BASES", "PCT_INTRONIC_BASES", "PCT_MRNA_BASES"),]
rownames(sum.data.for.plot) <- c("Intergenic", "Intronic", "mRNA")
sum.data.for.plot$which  <- rownames(sum.data.for.plot)
sum.data.melted <- sum.data.for.plot %>% tidyr::gather(Sample,value,-which)
sum.data.melted$value <- as.numeric(sum.data.melted$value)
sum.data.melted$which <- factor(sum.data.melted$which, levels=c("mRNA", "Intronic", "Intergenic")) # desired order

ggplot(data = sum.data.melted, aes(x = Sample, y = value, fill=which)) + 
	geom_bar(stat="identity", position = "dodge") +  #note stacked is default for ggplot2, so must specify "dodge" to get side-by-side bars
	scale_fill_manual(values=c("firebrick", "darkblue", "darkgreen")) +
	labs(title=project_name, x="Sample", y="Percentage of Total Mapped Bases") +
	ylim(0, 100) +
	theme_bw() +
	theme(axis.text.x = element_text(angle = 90, hjust = 1, size=16),
		legend.title = element_blank(),
		legend.text = element_text(size = 16),
           	axis.text.y = element_text(size=16),
         	plot.title = element_text(size=20, hjust = 0.5, face="bold"),
           	axis.title.x = element_text(size=18),
         	axis.title.y = element_text(size=18))
```

### Plot: Normalized Coverage

```{r, eval=T, echo=F, message=FALSE, fig.width=14, fig.height=10}
pos.data <- metrics.data %>% tidyr::gather(Sample,coverage,-Normalized_Position)
nsamp=ncol(metrics.data)-1
# add slight shift to normalized position
delta <- 1/(4*length(nsamp-1))
pos.org <- metrics.data$Normalized_Position
shift=unlist(lapply(1:nsamp, function(i){pos.org+delta*(i-1)}))
pos.data$Normalized_Position <- shift
# plot parameters
x.max <- max(metrics.data$Normalized_Position)
y.max <- max(metrics.data[ ,c(2:ncol(metrics.data)), drop=FALSE])
c <- rep(brewer.pal(12,"Paired"), nsamp) 
ggplot(pos.data, aes(x=Normalized_Position,y=coverage,group=Sample,color=Sample)) + 
    geom_line() +
    theme_bw() +
    ggtitle(project_name) +
    xlab("Normalized Position") +
    ylab("Normalized Coverage") +
    scale_x_continuous(breaks=seq(0,x.max,by=20)) +
    scale_y_continuous(breaks=seq(0,y.max,by=0.2)) +
    scale_color_manual(values = c) +
    theme(
    	legend.title = element_blank(),
	legend.text = element_text(size = 16),
	plot.title = element_text(size=20, hjust = 0.5, face="bold"),
        axis.text = element_text(size=16),
        axis.title = element_text(size=18)
    )
```

```{r setup, echo=FALSE}
library(knitr)
pair_ended <- if (library_type %in% c("PE")) {TRUE} else {FALSE}   #use this to replace all the if conditions in subsequent code chunks
```

```{r, eval = pair_ended, echo=FALSE}
knitr::asis_output("## InsertSizeMetrics Summary<br>") 
```

```{r, eval = pair_ended, echo=FALSE}
knitr::asis_output("For paired-end data, the Picard Tools CollectInsertSizeMetrics function was used to compute the distribution of insert sizes in the accepted_hits.bam file and create a histogram. Related text files that were saved: ")
```


```{r, eval=pair_ended, echo=F, message=FALSE, results='asis'}
cat(project_name, "_insertmetrics_summary.txt\n\n")
```

```{r insert_sum, eval=pair_ended, echo=F, message=FALSE, warning=F}
# Insert Size Summary
row.names(insert.summary.data) <- insert.summary.data$Type
insert.summary.data$Type <- NULL
metrics_row <- c("MEDIAN_INSERT_SIZE", "MEDIAN_ABSOLUTE_DEVIATION", "MIN_INSERT_SIZE", "MAX_INSERT_SIZE", "MEAN_INSERT_SIZE", "STANDARD_DEVIATION", "READ_PAIRS")
insert.summary.data <- insert.summary.data[metrics_row, ]
DT::datatable(insert.summary.data, options = list(pageLength = 25))
```

### Plot: Median of Insert Size

```{r, median_insert_plot, eval=pair_ended, echo=F, message=FALSE, warning=F, fig.width=10, fig.height=10}
insert.size <- data.frame(
    value=as.numeric(as.character(unlist(insert.summary.data["MEDIAN_INSERT_SIZE",]))),
    Sample=colnames(insert.summary.data))
ggplot(insert.size, aes(x=Sample, y=value)) + geom_bar(stat="identity",fill="firebrick") +
    ggtitle(project_name) +
    xlab("Sample") +
    ylab("Median Insert Size") +
    theme_bw() +
    theme(
        plot.title = element_text(size=20, hjust = 0.5, face="bold"),
	legend.title = element_blank(),
	legend.text = element_text(size = 16),
        axis.text.y = element_text(size=16),
	axis.text.x  = element_text(angle=90, hjust=1, size=16),
        axis.title = element_text(size=18))
```

### Plot: Insert Size Distribution

```{r insert_distri_plot, eval=pair_ended, echo=F, message=FALSE, warning=F, fig.width=14, fig.height=10}
# modify data from wide to long
size.data <- insert.metrics.data %>% tidyr::gather(Sample,count,-Insert_Size)
nsamp=ncol(insert.metrics.data)-1
# add slight shift to normalized position
delta <- 1/(4*length(nsamp-1))
size.org <- insert.metrics.data$Insert_Size
shift=unlist(lapply(1:nsamp, function(i){size.org+delta*(i-1)}))
size.data$Insert_Size <- shift
# plot parameters
x.max <- max(insert.metrics.data$Insert_Size)
y.max <- max(insert.metrics.data[ ,c(2:ncol(insert.metrics.data)), drop=FALSE], na.rm=T)
c <- rep(brewer.pal(12,"Paired"), nsamp)
# plot
ggplot(size.data, aes(x=Insert_Size,y=count,group=Sample,color=Sample)) +
    geom_line() +
    ggtitle(project_name) +
    xlab("Insert Size") +
    ylab("Read Count") +
    scale_color_manual(values = c) +
    theme_bw() +
    theme(
        plot.title = element_text(size=18, hjust=0.5, face="bold"),
        legend.title = element_blank(),
        legend.text = element_text(size = 16),
        axis.text.y = element_text(size=16),
        axis.text.x  = element_text(size=16),
        axis.title = element_text(size=18))
```

## Reads per Chromosome

Samtools produces a summary document that includes the number of reads mapped to each chromosome. Related text files that were saved:
```{r, eval=T, echo=F, message=FALSE, results='asis'}
cat("\n\n", project_name, "_counts.txt\n\n")
```

```{r, eval=T, echo=F, message=FALSE}

sample.names <- names(counts.data)[3:length(names(counts.data))]
if (genome=="hg19") {
	chr_order=c(1:22, "X", "Y", "Other", "rRNA")
	counts.data.ordered.by.chr <- do.call(rbind,lapply(chr_order,function(x){counts.data[which(counts.data$Chromosome==x),]}))
	counts.data.ordered.by.chr$Chromosome <- factor(counts.data.ordered.by.chr$Chromosome, levels = chr_order)
	#cat("For human, the hg19 assembly was used. We estimate the number of rRNA reads as those mapped to chrM plus chrUn_gl000220, corresponding to 12S, 16S and 5.8S rRNA. The 'Other' category contains all other chr*_random and chrUn_* available. If using the 2014 updated version of the hg19 files, these categories are no longer present.")
} else if (genome=="hg38") {
	chr_order=c(1:22, "X", "Y", "Other", "rRNA")
	counts.data.ordered.by.chr <- do.call(rbind,lapply(chr_order,function(x){counts.data[which(counts.data$Chromosome==x),]}))
	counts.data.ordered.by.chr$Chromosome <- factor(counts.data.ordered.by.chr$Chromosome, levels = chr_order)
	#cat("For human, the hg38 assembly was used. We estimate the number of rRNA reads as those mapped to chrM plus chrUn_GL000220v1, corresponding to 12S, 16S and 5.8S rRNA. The 'Other' category contains all other chr*_random and chrUn_* available.")
 } else if (genome %in% c("mm38", "mm10")) {
	counts.data[,1] <- sapply(counts.data[,1], function(x) gsub("chr", "", x))
	counts.data.chr.order <- order(as.numeric(counts.data[1:19,1]))
	counts.data.ordered.by.chr <- counts.data[1:19, ][counts.data.chr.order, ]
	counts.data.ordered.by.chr <- rbind(counts.data.ordered.by.chr, counts.data[c(20:23), ])
	#cat("For mouse, the ENSEMBL GRCm38 assmembly available in iGenomes was used.")
} else if (genome=="rn6") {
	counts.data[,1] <- sapply(counts.data[,1], function(x) gsub("chr", "", x))
	counts.data.chr.order <- order(as.numeric(counts.data[1:20,1]))
	counts.data.ordered.by.chr <- counts.data[1:20, ][counts.data.chr.order, ]
	counts.data.ordered.by.chr <- rbind(counts.data.ordered.by.chr, counts.data[c(22,23,21), ])
	#cat("For rat, the rn6 assembly was used.")
} else if (genome=="susScr3"){
	counts.data[,1] <- sapply(counts.data[,1], function(x) gsub("chr", "", x))
	counts.data.chr.order <- order(as.numeric(counts.data[1:18,1]))
	counts.data.ordered.by.chr <- counts.data[1:18, ][counts.data.chr.order, ]
	counts.data.ordered.by.chr <- rbind(counts.data.ordered.by.chr, counts.data[c(19:22), ]) # "Error:  chunk 23 (label = count.plot) Error in plot.window(...) : need finite 'ylim' values" means incorrect number of chromosomes listed here
	#cat("For pig, the susScr3 assembly was used.")
    }else if (genome=="Zv9") {
	counts.data <- counts.data[order(counts.data[, 1]), ]
	counts.data.chr.order <- order(as.numeric(levels(counts.data[1:25,1])[as.integer(counts.data[1:25,1])]))
	counts.data.ordered.by.chr <- counts.data[1:25, ][counts.data.chr.order, ]
	counts.data.ordered.by.chr <- rbind(counts.data.ordered.by.chr, counts.data[26:27, ])
	#cat("For zebrafish, the Zv9 assembly comprises a sequence length of 1.4 Gb in 26 chromosomes (labels 1-25 and MT) and 1,107 scaffolds (merged into label 'Other').")
}
# remove Length column
counts.data.ordered.by.chr$Length <- NULL
```

```{r readbychr_plot, eval=T, echo=F, message=FALSE, fig.width=14, fig.height=10}
c <- rep(brewer.pal(12,"Paired"), length(sample.names))
counts.data.melted <- counts.data.ordered.by.chr %>% tidyr::gather(Sample,value,-Chromosome)
ggplot(data = counts.data.melted, aes(x = Chromosome, y = value, fill=Sample)) + 
    geom_bar(stat="identity", position = "dodge") +  #note stacked is default for ggplot2, so must specify "dodge" to get side-by-side bars
    labs(title=project_name, x="Chromosome", y="Read Counts") +
    scale_fill_manual(values = c) +
    theme_bw() +
    theme(
	legend.title = element_blank(),
	legend.text = element_text(size = 16),
	axis.text = element_text(size=16),
        plot.title = element_text(size=20, hjust = 0.5, face="bold"),
	axis.title = element_text(size=18))
```

### Mapped Reads to Reference Genome

```{r, eval=T, echo=F, message=FALSE}
count.total.table <- counts.data.ordered.by.chr
row.names(count.total.table) <-count.total.table$Chromosome
count.total.table$Chromosome <- NULL
#Add in the total row at bottom
count.total <- colSums(count.total.table)
count.total.table["Total",] <- count.total
DT::datatable(count.total.table, options = list(pageLength = 30))
```

### Percent of Total Reads Mapped to Reference Genome
 
```{r, eval=T, echo=F, message=FALSE}
counts.percent.table <- do.call(rbind,apply(count.total.table,1,function(x){x/count.total.table["Total",]*100}))
counts.percent.table[-nrow(counts.percent.table),] <- round(counts.percent.table[-nrow(counts.percent.table),], 2)
counts.percent.table["Total",] <- round(counts.percent.table["Total",],0)
DT::datatable(counts.percent.table, options = list(pageLength = 30))
```

```{r setup_ercc, echo=FALSE}
library(knitr)
ercc.exist <- exists("ercc.mixes")
```

```{r, eval = ercc.exist, echo=FALSE}
knitr::asis_output("## ERCC Spike-in Dose Response Plots<br>") 
```

```{r, eval = ercc.exist, echo=FALSE}
knitr::asis_output("For samples that contained External RNA Controls Consortium (ERCC) Spike-Ins, dose response curves (i.e. plots of ERCC transcript FPKM vs. ERCC transcript molecules) were created. Ideally, the slope and R2 would equal 1.0.")
```

```{r erccplot_func, eval=T, echo=F}
erccplot_func=function(conc,count,colname){
  conc=as.numeric(conc[which(count>0)])
  count=as.numeric(count[which(count>0)])
  dat=data.frame(logconc=log2(conc), logcount=log2(count))
  linear.fit <- lm(logcount ~ logconc, data=dat)
  r2 <- summary(linear.fit)$r.squared
  slope <- as.numeric(linear.fit$coefficients[2])
  if (grepl("count_",colname)) {ylab="Count"} else if (grepl("tpm_",colname)) {ylab="TPM"} else if (grepl("fpkm_",colname)) {ylab="FPKM"}
  p=ggplot(data=dat,aes(x=logconc,y=logcount))+geom_point() +
    geom_smooth(method='lm', se=FALSE, color="red") +
    theme_bw() +
    ggtitle(colname) +
    xlab("Expected concentration (log2 scale)")+
    ylab(paste0("Observed ",ylab," (log2 scale)")) +
    theme(plot.title = element_text(hjust = 0.5))
  if (grepl("FPKM|fpkm", colname)) {
    p=p+annotate('text', 7.5, 0, label=paste0("R-sq =", round(r2,3))) +
      annotate('text', 7.5, -1, label=paste0("slope =", round(slope,3)))}
  else if (grepl("Count|count",colname)) {
    p=p+annotate('text', 5, 0, label=paste0("R-sq =", round(r2,3))) +
      annotate('text', 5, -0.8, label=paste0("slope =", round(slope,3)))}
  else if (grepl("TPM|tpm",colname)) {
    p=p+annotate('text', 5, 0, label=paste0("R-sq =", round(r2,3))) +
      annotate('text', 5, -0.8, label=paste0("slope =", round(slope,3)))}
  print(p)
  return(data.frame(r2=r2, slope=slope))
}
```

```{r, ercc_fit, eval=ercc.exist, echo=F, message=F, results="asis", fig.height=4, fig.width=4} 
if ("1" %in% ercc.mixes | "2" %in% ercc.mixes) {
	sample.names <- sample.names.orig
	if (!file.exists(ambion_file)) {stop("ERCC concentration file", ambion_file, " does not exist")}

	# read in ambion file
	ambion=read.table(ambion_file,header=T, as.is=T, sep='\t')
	ambion=ambion[order(ambion$ERCC.ID),c("ERCC.ID","concentration.in.Mix.1..attomoles.ul.")]
	dilution.factor <- 0.02
	
	ercc.fit.table <- data.frame() # ERCC concordance results
	# select mix type
	for (i in c(1:length(sample.names))){
		curr.sample.name <- names(ercc.data)[grepl(sample.names[i],names(ercc.data))]
		curr.ercc.mix <- ercc.mixes[i]
		# choose mix type
		if (curr.ercc.mix=="1") {
			ambion.sub=ambion[order(ambion$ERCC.ID),c("ERCC.ID","concentration.in.Mix.1..attomoles.ul.")]
		} else if (curr.ercc.mix=="2") {
			ambion.sub=ambion[order(ambion$ERCC.ID),c("ERCC.ID","concentration.in.Mix.2..attomoles.ul.")]
		} else {
			next
		}
	 
		names(ambion.sub)=c("ERCC_ID","Concentration")
		ambion.sub$Concentration=ambion.sub$Concentration*dilution.factor

		# combine ambion concentration with read counts
		dat = merge(ambion.sub, ercc.data[,c("Gene",curr.sample.name)],by.x="ERCC_ID",by.y="Gene" )
		curr.count=dat[,curr.sample.name]
		if (length(curr.count[which(curr.count>0)])>0) { # if not all ERCC counts equal zero, compute correlation
		  curr.res=erccplot_func(conc=dat[,"Concentration"],count=dat[,curr.sample.name],colname=curr.sample.name)
		  ercc.fit.table=rbind(ercc.fit.table,data.frame(Sample=sample.names[i],curr.res))
		}
	}
	if (exists("ercc.fit.table")) {
		write.table(ercc.fit.table, file=paste(project_name,"_ercc_fit.txt",sep=""), row.names=F, quote=F, sep="\t")
	} else {cat("All ERCC read counts equal zero\n")}
}
```


```{r, ercc_fit_tb, eval=ercc.exist, echo=F, message=F, results='asis'}
if (exists("ercc.fit.table")) {
  ercc.fit.table[,c("r2","slope")] <- round(ercc.fit.table[,c("r2","slope")],2)
  try(HTML(print(xtable(ercc.fit.table, caption="ERCC Spike-in Dose Response Fit Details"), type="html", label="tab:nine", table.placement="tbp", caption.placement="top", floating=FALSE))) #added "try()" when doing pig_lung - else was getting thrown out of loop with 'Error: could not find function "HTML"'
  DT::datatable(ercc.fit.table,rownames = FALSE, options = list(pageLength = 25))
}
```

**Differential Expression Analysis**

Reads were aligned to the mm10 assembly using STAR (2.7.6a).  The following alignment QC report was produced:<br>

> Lung_AT2_QC_RnaSeqReport.html<br>

HTSeq (0.11.3) function htseq-count was used to count reads. Counts for all samples were concatenated into the following text file:<br>

> Lung_AT2_htseq_gene.txt<br>

DESeq2 (1.28.1) was used for differential gene expression analaysis, based on the HTSeq counts matrix and the phenotype file provided.  Normalized counts from DESeq2 are saved in the following text file:<br>

> Lung_AT2_counts_normalized_by_DESeq2.txt<br>

Normalized counts are obtained from DESeq2 function estimateSizeFactors(), which divides counts by the geometric mean across samples; this function does not correct for read length. The normalization method is described in detail here: https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-10-r106<br>

Differential gene expression analysis was done for all comparisons provided in the comparisons file.  The following design was used:<br>

> design = ~  + Donor + Status<br>

If desired, the design can be modified to include more independent variables. In addition to the partial results displayed in this report, the full set of DESeq2 results for each comparison was saved down in separate text files, with names of the form:<br>

> Lung_AT2_CASE_vs_CONTROL_DESeq2_results.txt<br>

where CASE and CONTROL are pairs of conditions specified in the comparisons file.<br>

```{r, eval=T, echo=F}
project_name="Lung_AT2"
path.start='/Users/tony/BMIN503_Final_Project/'
housekeeping_genes <- c('Actb','Gapdh','B2m','Rpl19','Gabarap')
house_list=list() # create an empty list to save results of house-keeping genes
ref_genome <- 'mm10'
convert_dataset <- 'mmusculus_gene_ensembl'
fav_genes <- c('ACE2', 'TMPRSS2')
fav_list <- list()
getwd()
coldata <- read.table('/Users/tony/BMIN503_Final_Project/files/Lung_AT2_Phenotype_withQC.txt', sep='\t', header=TRUE)
coldata <- subset(coldata, QC_Pass==1)
countdata <- read.table(paste0(path.start, project_name,'_Alignment_QC_Report_star/', project_name, '_htseq_gene.txt'), sep='\t', header=TRUE, check.names=FALSE)
names(countdata) <- gsub('count_','',names(countdata))
countdata <- countdata[,c('Gene',as.character(coldata$Sample))]

row.names(countdata) <- countdata$Gene
is_ensg <- if (substr(rownames(countdata)[1], 1, 4) == 'ENSG') {TRUE} else {FALSE}
countdata$Gene <- sapply(strsplit(as.character(countdata$Gene), '\\.'), '[[', 1) # remove .5 in transcript ENSG00000000005.5
mart <- useMart(biomart='ENSEMBL_MART_ENSEMBL', host='jan2019.archive.ensembl.org', path='/biomart/martservice' ,dataset='mmusculus_gene_ensembl')
genes <- biomaRt::getBM(attribute=c('ensembl_gene_id', 'mgi_symbol'), values=countdata$Gene, mart=mart)
genes <- genes[!duplicated(genes$ensembl_gene_id),]
if (is_ensg) {countdata <- merge(countdata, genes, by.x='Gene', by.y='ensembl_gene_id')} else {countdata <- countdata}
if (is_ensg) {countdata <- rename(countdata, c('mgi_symbol'='gene_symbol'))} else {countdata$gene_symbol <- countdata$Gene}
if (is_ensg) {row.names(countdata) <- countdata$Gene} else {row.names(countdata) <- row.names(countdata)}
if (is_ensg) {countdata$gene_symbol[which(countdata$gene_symbol=='')] <- NA} # assign NA to genes without gene_symbol
```

Convert KEGG and REACTOME pathway files in .gmt format provided by MSigDB into a pathway list
```{r createpathwaylist, eval=T, echo=F}
pathways.msigkegg <- gmtPathways("/Users/tony/Downloads/c2.cp.kegg.v7.4.symbols.gmt")
pathways.msigreactome <- gmtPathways("/Users/tony/Downloads/c2.cp.reactome.v7.4.symbols.gmt")
pathways.msigkeggreac <- c(pathways.msigkegg,pathways.msigreactome)
```




```{r normcount, eval=T, echo=F, message=F, warnings=F, results="hide"}
# this part is only for getting normalized counts (this way all samples normalized together)
# unpaired design, testing for effect of Status
ddsFullCountTable <- DESeqDataSetFromMatrix(countData = countdata[,2:(ncol(countdata)-1)], colData = coldata, design = ~ Status)
dds <- DESeq(ddsFullCountTable)
norm.counts <- counts(dds, normalized=TRUE)
norm.counts <- merge(norm.counts, countdata[,c('Gene','gene_symbol')], by='row.names')
norm.counts <- norm.counts[,2:ncol(norm.counts)] #else end up with a column called 'Row.names'
```

```{r normcount_save, eval=T, echo=F}
write.table(norm.counts, paste0(project_name,'_counts_normalized_by_DESeq2.txt'), sep='\t', quote=F, row.names=F, col.names=T)
```

```{r, eval=T, echo=F}
case <- 'AT2_AT1'
ctrl <- 'AT2'
```

## AT2_AT1 vs. AT2

### Samples in this comparison
```{r, eval=T, echo=F, message=F}
#conditions from file - select the portion of the info sheet relevant to the two conditions being tested
coldata_curr <- coldata[which(coldata$Status==case | coldata$Status==ctrl),]
#for paired design, want each unique value of control variable to correspond to an equal number of case and control samples -- else toss all samples with that value of control variable.
donors_case=as.character(coldata_curr$Donor)[which(coldata_curr$Status==case)]
donors_ctrl=as.character(coldata_curr$Donor)[which(coldata_curr$Status==ctrl)]
for (i in unique(coldata_curr$Donor)) {
	if (!(i%in%donors_case&i%in%donors_ctrl)) {
		coldata_curr <- coldata_curr[-which(coldata_curr$Donor==i),]
		cat('Samples with Donor==', i, 'were removed from the AT2_AT1 vs. AT2 comparison because there was an unequal number of case and control samples')
}
}
coldata_curr <- coldata_curr[order(as.character(coldata_curr$Sample)), ]
coldata_curr$Status <- factor(coldata_curr$Status, levels = c(ctrl,case)) # make sure that control is being used as reference level (else DESeq2 does it alphabetically)
DT::datatable(coldata_curr, rownames=FALSE, options = list(columnDefs = list(list(className = 'dt-center', targets = '_all')))) # dom = 't' removes search box
rownames(coldata_curr) <- coldata_curr$Sample
coldata_curr$Sample <- NULL
```

### DE analysis
```{r, eval=T, echo=F, message=F}
#select the portion of the HTSeq output matrix relevant to the two conditions being tested
a <- colnames(countdata)
b <- rownames(coldata_curr)
countdata_curr <- countdata[,which(a %in% b)] # subset countdata and coldata
countdata_curr <- countdata_curr[ ,order(as.character(names(countdata_curr)))] #columns of countdata & rows of coldata must be ordered in the same way
#pre-filter low count genes before running the DESeq2 functions. Keep only genes (rows) that have at least 10 reads total.
keep <- rowSums(countdata_curr)>=10
countdata_curr <- countdata_curr[keep,]
#combine HTSeq counts and info from info sheet
#in spedifying design, order matters: test for the effect of condition (the last factor), controlling for the effect of individual (first factor)
# paired design, testing for effect of Status while controlling for Donor
ddsFullCountTable <- DESeqDataSetFromMatrix(countData = countdata_curr, colData = coldata_curr, design = ~ Donor + Status)

# DESeq analysis
dds <- DESeq(ddsFullCountTable)
# obtain normalized counts
dds_count <- counts(dds, normalize=T)

# output results
res <- results(dds, cooksCutoff=FALSE, independentFiltering=FALSE)
res$gene_id <- row.names(res) 
  
#rlog transformations - used later in sample correlation heatmap and PCA plot
#in transformations, blind=FALSE means tells it to use the design info
#using blind=TRUE just uses the data with no background info
rld<- rlogTransformation(dds, blind=FALSE)

# add gene symbols for DE results
res_df <- as.data.frame(res)
res_df <- merge(countdata[which(countdata$Gene%in%res_df$gene_id),c("Gene","gene_symbol")],res_df,by.x="Gene",by.y="gene_id")
res_df <- res_df[order(res_df$pvalue, decreasing=FALSE),]

# gather counts in one column
res_ct_df <- as.data.frame(dds_count)
res_ct_df$Gene <- rownames(res_ct_df)
res_ct_df <- res_ct_df %>% gather(Sample, count, -Gene)

# add gene symbol and sample Status for normalized counts
res_ct_df <- merge(countdata[which(countdata$Gene%in%res_ct_df$Gene),c("Gene","gene_symbol")],res_ct_df,by="Gene")
res_ct_df <- merge(res_ct_df,coldata[which(coldata$Sample%in%res_ct_df$Sample),c("Sample","Status")],by="Sample")
res_ct_df$Status <- factor(res_ct_df$Status, levels = c(ctrl,case))
```

```{r, eval=T, echo=F}
#save down ALL DESeq2 results in the directory... this is not really going into the report so much as for reference
res_fn=paste0(project_name,"_",case,"_vs_",ctrl,"_full_DESeq2_results.txt")
write.table(res_df[order(res_df$pvalue, decreasing=FALSE),], res_fn, quote=FALSE, row.names=FALSE, sep='\t')
```

```{r, eval=F, echo=F}
# save normalized counts results. Stop save counts for two sample comparisons.
res_ct_fn=paste0(project_name,"_",case,"_vs_",ctrl,"_counts_normalized_by_DESeq2.txt")
write.table(res_ct_df, res_ct_fn, quote=F, row.names=F, col.names=T, sep='\t')
```

```{r, eval=T, echo=F}
# assign colours to comparison status
colour_status <- c("navy","red")
names(colour_status) <- c(ctrl,case) # assign red to case and navy to control
colour_status_list <- unlist(lapply(coldata_curr$Status,function(x){colour_status[x]}))
colours=c("#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666", "#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#CCEBC5", "#FFED6F") # first 8 colour names derived from Dark2, and last 12 names from Set3
```

```{r, eval=T, echo=F}
if (exists("housekeeping_genes")) {
  comp=paste0(case,"_vs_",ctrl)
  # save padj for house-keeping genes if defined
  house_list[[comp]]=res_df[which(res_df$gene_symbol%in%housekeeping_genes),]
}
```


```{r, eval=T, echo=F, results="asis"}
summ_tb=as.data.frame(table(droplevels(coldata_curr$Status)))
names(summ_tb) <- c("Status","Count")
pandoc.table(summ_tb, split.tables=Inf, caption="Comparison Summary")
```

```{r, eval=T, echo=F}
if (exists("fav_genes")&any(fav_genes%in%res_df$gene_symbol)) {
  comp=paste0(case,"_vs_",ctrl)
  # save padj for house-keeping genes if defined
  fav_list[[comp]]=res_df[which(res_df$gene_symbol%in%fav_genes),]
}
```

### Top 50 genes by p-value
```{r, eval=T, echo=F}
#output table for report
#select top 50 by pvalue
#then round to 2 decimal points for output table
res_df_outp <- head(res_df[order(res_df$pvalue, decreasing=FALSE),], 50)
res_df_outp[,c("baseMean", "log2FoldChange", "lfcSE", "stat")] <- round(res_df_outp[,c("baseMean", "log2FoldChange", "lfcSE", "stat")], 2)   
res_df_outp[,c("pvalue")] <- formatC(res_df_outp[,c("pvalue")], format = "e", digits = 2) # do this in 2 steps, else get "Error in is.finite(x) : default method not implemented for type 'list'"
res_df_outp[,c("padj")] <- formatC(res_df_outp[,c("padj")], format = "e", digits = 2) 
DT::datatable(res_df_outp, rownames=FALSE, options = list(columnDefs = list(list(className = 'dt-center', targets = "_all"))))
```

### Description of DESEq2 output 

```{r, eval=T, echo=F}
info_table <- as.data.frame(mcols(res, use.names=TRUE))
info_table$`Output Column` <- rownames(info_table)
info_table <- info_table[1:6, c("Output Column", "description")]
colnames(info_table) <- c("Output Column", "Description")
info_table$Description <- paste0(info_table$Description, ", computed by DESeq2")
info_table <- rbind(c("gene_symbol", "Official Gene Symbol, obtained using biomaRt if first column has Ensembl Gene IDs - else same as first column"), info_table)
info_table <- rbind(c("Gene", "Official Gene Symbol or Ensembl Gene ID, depending on reference files used for alignment"), info_table)

DT::datatable(info_table, rownames = FALSE, options = list(dom = 't', columnDefs = list(list(className = 'dt-left', targets = "_all"))))
```

### Volcano plots

Volcano plot (probes with a q-value <0.05 are present in red)

```{r, echo=F}
# The volplot_func function generates volcano plots
volplot_func <- function(df,qval_column,title) {
  # get qvalue column
  qval <- df[,qval_column]
  if (all(is.na(qval))) {message("The batch and status are highly confounded. Batch effect is not adjusted.")} else {         
    df <- df[!is.na(qval),] # remove NA values
    qval <- df[,qval_column]
    if (min(df[,qval_column])>=0.05) {
      df$sig <- "black" # assign colors to DE and non-DE genes
    } else {
      # assign colors to DE and non-DE genes
      df$sig <- rep(NA,nrow(df))
      df$sig[qval<0.05] <- "red"
      df$sig[qval>=0.05] <- "black"
    }
    df$sig <- as.factor(df$sig)
    color <- levels(df$sig)
    # log10 transformed q values
    df$logqval <- -log10(qval)
    diffgenes <- df$Gene[qval<0.05] #Create list of all DEG's
    signum = paste0(length(diffgenes), " differentially expressed genes")
    #cat(length(diffgenes), "differentially expressed genes have been identified based on", qval_column)
    if (missing(title)) {title=signum}
    print(
    ggplot(df, aes(x = log2FoldChange, y = logqval, color=sig)) + geom_point(size=0.5) +
      theme_bw() +
      labs(title=title,x="log2FoldChange",y=paste0("-log10(",qval_column,")")) +
      scale_color_manual(values=color) +
      theme(legend.position="none")
    )
  }
}
```


```{r, eval=T, echo=F, fig.height=4, fig.width=4}
for (qval in c("pvalue","padj")) {volplot_func(df=res_df, qval_column=qval)}
```

### MA plot

```{r, eval=T, echo=F}
plotMA(dds,ylim=c(-2,2))
```

### Distribution of adjusted p-values

```{r, eval=T, echo=F}
hist(res$padj, main=" ", xlab="adjusted p-value", breaks=50, col="deepskyblue4", xaxp  = c(0, 1, 20))
```

### Dendrogram based on sample distance of regularized log transformed data

```{r, echo=F}
# The dist2 estimates distance between samples
dist2 <- function (x,fun = function(a, b) mean(abs(a - b), na.rm = TRUE),diagonal = 0) {
  if (!(is.numeric(diagonal) && (length(diagonal) == 1)))
    stop("'diagonal' must be a numeric scalar.")

  if (missing(fun)) {
    res = apply(x, 2, function(w) colMeans(abs(x-w), na.rm=TRUE))
  } else {
    res = matrix(diagonal, ncol = ncol(x), nrow = ncol(x))
    if (ncol(x) >= 2) {
      for (j in 2:ncol(x))
        for (i in 1:(j - 1))
          res[i, j] = res[j, i] = fun(x[, i], x[, j])
    } # if
  } # else
  colnames(res) = rownames(res) = colnames(x)
  return(res)
}

distplot_func <- function(m) {
  dend = as.dendrogram(hclust(as.dist(m), method = "single"))
  ord = order.dendrogram(dend)
  array_name=colnames(m)
  heatmap.2(m,Rowv=dend,Colv=dend,
    col=viridis(256, option="B"),ColSideColors=colour_status_list,RowSideColors=colour_status_list,
    labCol=array_name,labRow=array_name,
    trace="none",
    margins=c(12,20), # (bottom margin, left margin)
    cexRow = 1,cexCol = 1,
    keysize=1.5,key.title=NA,key.xlab="Dist2",key.ylab="Counts")
  legend("bottomleft",legend=names(colour_status),fill=colour_status,cex=0.6)
}
```

```{r, eval=T, echo=F, fig.height=10, fig.width=12}
distplot_func(m=dist2(assay(rld)))
```

### Heatmaps for top 30 significant genes

Genes were ranked by adjusted p-values.

```{r, echo=F}
# The heatmap_topgene_func function for top gene heatmap plots
heatmap_topgene_func <- function(tb, topnum=30, main="") {
  m=log2(dds_count+1)
  top.mat <- m[rownames(m)%in%tb[1:topnum,"Gene"],] # plot heatmap for top genes
  array_name <- colnames(m)
  gene_symbol=tb[1:topnum,"gene_symbol"]
  heatmap.2(na.omit(top.mat), col=viridis(256, option="B"),
    ColSideColors=colour_status_list, # use predefined colour_status_list, assign colors to status
    labCol=array_name, labRow=gene_symbol, # take out gene probe id
    trace="none",
    margins=c(12,20), # (bottom margin, left margin)
    cexRow=1,cexCol=1,
    keysize=1.5,key.title=NA,key.xlab="Log2-normalized counts",key.ylab="Counts",
    main=main)
  legend("bottomleft",legend=names(colour_status),fill=colour_status,cex=0.8) # use predifined colour_status
}
```

```{r , eval=T, echo=F, fig.height=10, fig.width=12}
heatmap_topgene_func(tb=res_df, topnum=30, main="")
```

### Principal component analysis (PCA) Plot based on regularized log transformed data

```{r, echo=F, warning=F, message=F}
# The pcastat_func function computes principal components
pcastat_func <- function(m, ntop=500) {
  # calculate the variance for each gene
  rv <- rowVars(m)
  # select the ntop genes by variance
  select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
  m=m[select,]
  # obtain original expression data
  raw.data.pca <- na.omit(apply(m,2,function(x)replace(x,is.infinite(x),NA))) # replace infinite values to NAs and omit NAs
  # As scale function divides by the variance, the probe with the expression sd=0 across samples must be removed.
  sd <- apply(raw.data.pca,1,sd)
  raw.data.pca <- raw.data.pca[!sd==0,]
  # compute pcs
  pca <- prcomp(t(raw.data.pca), retx = TRUE, center = TRUE, scale = TRUE)
  pc <- data.frame(pca$x)
  # compute variance explained by each PC
  vars <- pca$sdev^2
  pcs <- t(pc)
  pvars <- vars*100.0/sum(vars) # proportion of variance (%) explained by each PC
  cumsum_pvars <- cumsum(pvars) # Cumulative Proportion of Variance (%)
  if (nrow(pcs)>10) {nres <- 10} else {nres=nrow(pcs)} # select top 10 PCs if number of PCs >10
  res <- data.frame(rownames(pcs),pvars,cumsum_pvars)[1:nres,]
  names(res) <- c("PC","Proportion of Variance (%)","Cumulative Proportion of Variance (%)")
  return(list(tb=res,pc=pc))
}

# The pcaplot_func creates plots for pc1 and pc2
pcaplot_func <- function(pc, group_var) { # group_var: column name for a specific group
  df <- data.frame(
    PC1=pc$PC1,
    PC2=pc$PC2,
    group=coldata_curr[,group_var]
  )
  ggplot(df,aes(PC1,PC2,color=group)) + geom_point() + theme_bw()
}

# The pca_func function generates multiple pca plots for scan date, disease, treatment, and Donor
pca_func <- function(pc) {
  group_vars=c("Tissue", "Donor")
  idx_exist=c(1:length(group_vars))[group_vars%in%names(coldata_curr)] # obtain index of existing variables
  plot_list=list() # store plots in a list
  for (i in idx_exist) {
    group_var=group_vars[i]
    coldata_curr[,group_var] <- as.factor(coldata_curr[,group_var])
    nlevel=nlevels(coldata_curr[,group_var]) # levels of the variable
    if (group_var=="ScanDate_Group"|(nlevel>=2&nlevel<=20)) {
      plot_list[[group_var]]=pcaplot_func(pc, group_var=group_var)+scale_color_hue(name=group_var)
    }
  }
  return(plot_list)
}
```

Compute PCs and variance explained by the first 10 PCs

```{r, eval=T, echo=F, warning=F, message=F, results="asis"}
res_pca <- pcastat_func(m=assay(rld))
pandoc.table(res_pca$tb, split.tables=Inf, caption="Variance explained")
```

PCA plots are generated using the first two principle components colored by known factors (e.g. Status, Tissue, or Donor)

```{r, eval=T, echo=F, message=F, warning=F}
pcaplot_func(pc=res_pca$pc,group_var="Status")+scale_color_manual("Status",values=colour_status,na.value="grey")
```

```{r, eval=T, echo=F, message=F, warning=F}
plot_list=pca_func(pc=res_pca$pc)
for (i in plot_list) {print(i)}
```


### Dispersion plot

```{r, eval=T, echo=F}
plotDispEsts(dds)

```

### Plot of the maximum Cook's distance per gene over the rank of the Wald statistics for the condition

```{r, eval=T, echo=F}
W <- res$stat
maxCooks <- apply(assays(dds)[['cooks']],1,max)
idx <- !is.na(W)
plot(rank(W[idx]), maxCooks[idx], xlab='rank of Wald statistic', ylab='maximum Cooks distance per gene', ylim=c(0,5), cex=.4, col=rgb(0,0,0,.3))

```

### Boxplots for top 20 differentially expressed genes

Genes were ranked by pvalue.  Counts have been normalized by sequencing depth, with pseudocount of 0.5 added to allow for log scale plotting, using DESeq2 function plotCounts().

```{r, echo=F}
boxplot_func <- function(df) {
    gene_symbol=unique(df$gene_symbol)
    gene_id=unique(df$Gene)
    ggplot(df, aes(x = Status, y = count, fill=Status)) +
    geom_boxplot(outlier.colour=NA, lwd=0.2, color="grey18") + 
    stat_boxplot(geom ='errorbar', color="grey18") + 
    expand_limits(y=0) +
    geom_jitter(size=0.5, width=0.2) + 
    guides(fill=FALSE) +
    theme_bw() +  
    labs(title=paste0(gene_id, " ", gene_symbol)) +
    #labs(x="condition") +
    labs(y="Normalized counts") +
    theme(text = element_text(size=9), 
          strip.text.x = element_text(size = 10),
	  #axis.text.x = element_text(size=12),
          axis.text.x = element_text(angle = 90, hjust = 1, size=12),
          axis.text.y = element_text(size=9),
          plot.title = element_text(size=12),
          axis.title.x = element_blank(),
          axis.title.y = element_text(size=12))
}
```

```{r, eval=T, echo=F, message=F, cache=F, warning=F, fig.height=4, fig.width=4}
topnum=20
for (i in 1:topnum) {
  gene_id <- res_df[i,"Gene"]
  gene_symbol <- res_df[i,"gene_symbol"]
  curr_data <- res_ct_df[which(res_ct_df$Gene==gene_id),]
  print(boxplot_func(df=curr_data)+scale_fill_manual(values=colour_status,na.value="grey"))
}

```

### Favorite genes

Boxplots for user-defined favorite genes if they exist, and show DE results

```{r, eval=T, echo=F, cache=FALSE, warning=F, message=F, fig.height=4, fig.width=4}
sel_fav_genes=fav_genes[fav_genes%in%as.character(res_df$gene_symbol)] # select favorite genes within the current results
if (length(sel_fav_genes)==0) {cat("None of user-defined genes are found in current DE results.\n")} else {
  for (i in sel_fav_genes) {
    gene_symbol=i
    gene_id <- res_df[which(res_df$gene_symbol==gene_symbol),"Gene"][1] # choose Ensembl gene with smallest p-values
    curr_data <- res_ct_df[which(res_ct_df$Gene==gene_id),]
    print(boxplot_func(df=curr_data)+scale_fill_manual(values=colour_status,na.value="grey"))
  }
}
```

```{r, eval=T, echo=F, message=F}
if (length(sel_fav_genes)>0) {
  fav_tb=data.frame()
  for (i in sel_fav_genes) {
    gene_symbol=i
    curr_data <- res_df[which(res_df$gene_symbol==gene_symbol),][1,] # choose Ensembl gene with smallest p-values
    fav_tb=rbind(fav_tb, curr_data)
  }
  fav_tb[,c("baseMean", "log2FoldChange", "lfcSE", "stat")] <- round(fav_tb[,c("baseMean", "log2FoldChange", "lfcSE", "stat")], 2)   
  fav_tb[,c("pvalue")] <- formatC(fav_tb[,c("pvalue")], format = "e", digits = 2) # do this in 2 steps, else get "Error in is.finite(x) : default method not implemented for type 'list'"
  fav_tb[,c("padj")] <- formatC(fav_tb[,c("padj")], format = "e", digits = 2) 
  DT::datatable(fav_tb, rownames=FALSE, options = list(columnDefs = list(list(className = 'dt-center', targets = "_all"))))
}
```

### Gene-set enrichment analysis


```{r eval=T, echo=F}
convertspeciesGeneList <- function(x){
  human 	<- useEnsembl("ensembl", dataset = "hsapiens_gene_ensembl", mirror = "useast")
  species 	<- useEnsembl("ensembl", dataset = convert_dataset, mirror = "useast")
  tmp 	<- getLDS(attributes = c("mgi_symbol"), filters = "mgi_symbol", values = x , mart = species, attributesL = c("hgnc_symbol"), martL = human, uniqueRows=TRUE)
  return(tmp)
}
if (ref_genome!="hg38") {
  nonhuman_symbol <- convertspeciesGeneList(x=as.character(norm.counts$gene_symbol))
  res_df <- merge(res_df, nonhuman_symbol, by.x="gene_symbol", by.y="MGI.symbol", all.x=T) %>%
    dplyr::rename(nonhuman_symbol=gene_symbol, gene_symbol=HGNC.symbol) %>%
    dplyr::arrange(padj)
}
```


```{r eval=T, echo=F}
# generate the list of z-score statistics
de_modi <- res_df %>%
  dplyr::filter(gene_symbol!="") %>% # remove Ensemble ID cannot be mapped to genes
  dplyr::filter(gene_symbol!="NA") %>% # remove Ensemble ID cannot be mapped to genes
  dplyr::arrange(gene_symbol, padj, -abs(log2FoldChange)) %>% # order by gene name, p-values and descending absolute logFC values
  dplyr::group_by(gene_symbol) %>% # group by gene name
  dplyr::filter(dplyr::row_number()==1) %>% # select first row in each gene
  dplyr::ungroup() %>%
  dplyr::select(gene_symbol,stat) %>% # replace column names
  dplyr::arrange(stat) %>%
  as.data.frame()
gene_stat <- de_modi$stat
names(gene_stat) <- de_modi$gene_symbol
```

```{r eval=T, echo=F, message=F, warning=F}
# run fgsea
res <- fgsea(pathways=pathways.msigkeggreac, stats=gene_stat, minSize=15, maxSize=500, nperm=10000, gseaParam=1)
# collapse dependent pathways. create a list of mainPathways and parentPathways
collapsedPathways <- collapsePathways(fgseaRes=res[order(pval),], pathways=pathways.msigkeggreac, stats=gene_stat, gseaParam=1)
mainPathways <- collapsedPathways$mainPathways
parentPathways <- collapsedPathways$parentPathways
res=res %>% dplyr::arrange(padj) # order by padj value
# annotate main pathways to fgsea results
res$main_pathway <- sapply(res$pathway, function(x){if (x%in%mainPathways) {"main"} else {parentPathways[[x]]}})
```

```{r eval=T, echo=F}
# convert the list column leadingEdge into character
convtleadingEdge_func <- function(fgsea_res) {
  leadingEdge <- rep(NA, nrow(fgsea_res))
  leadingEdge <- sapply(fgsea_res$leadingEdge, function(x)paste(x,collapse=","))
  fgsea_res$leadingEdge <- NULL
  fgsea_res <- as.data.frame(do.call(cbind,lapply(fgsea_res,unlist)))
  fgsea_res$leadingEdge <- leadingEdge
  return(fgsea_res)
}
res_save <- convtleadingEdge_func(res)
res_fn <- paste0(project_name,"_",case,"_vs_",ctrl,"_fgsea_results.csv")
write.csv(res_save, res_fn, row.names = F)
```

View top pathways in fgsea results. Only include the first five leading genes

```{r eval=T, echo=F}
res_show <- res[padj<0.05&main_pathway=="main"]
cat(nrow(res_show), "main pathways are significant.\n")
```

```{r eval=T, echo=F}
if (nrow(res_show)==0) {
  res_show <- res[main_pathway=="main"][1:10] # if no significant pathway, take the top 10 main pathways
}
res_show <- res_show %>%
  dplyr::mutate(pval=round(pval,4), padj=round(padj,4), ES=round(ES,3), NES=round(NES,3))
leadingEdge <- rep(NA, nrow(res_show))
leadingEdge <- sapply(res_show$leadingEdge, function(x)paste(x[1:5],collapse=","))
res_show$leadingEdge <- NULL
res_show$leadingEdge <- leadingEdge
DT::datatable(res_show[1:50], rownames=FALSE, options = list(columnDefs = list(list(className = 'dt-center', targets = "_all"))))
```


Generate barplot if pathways with absoluate NES>=2 or top 10 pathways if no pathways pass the threshold

```{r eval=T, echo=F}
#Generate data barplots for top pathways
res_barplot <- res[padj<0.05&abs(NES)>2]
if (nrow(res_barplot)==0) {
  res_barplot <- res[1:10]
}
if (nrow(res_barplot)<=10) {height=8} else {height=15/50*nrow(res_barplot)}
```


```{r, echo=F}
textconv4plot_func <- function(x) {
  if (x=="REACTOME_ACTIVATION_OF_THE_MRNA_UPON_BINDING_OF_THE_CAP_BINDING_COMPLEX_AND_EIFS_AND_SUBSEQUENT_BINDING_TO_43S") {x <- "REACTOME_MRNA_ACTIVATION_CAP_BINDING_COMPLEX_EIFS_43S_BINDING"}
  if (x=="REACTOME_ANTIGEN_PRESENTATION_FOLDING_ASSEMBLY_AND_PEPTIDE_LOADING_OF_CLASS_I_MHC") {x<-"REACTOME_ANTIGEN_PRESENTATION_CLASS_I_MHC"}
  if (x=="REACTOME_BIOSYNTHESIS_OF_THE_N_GLYCAN_PRECURSOR_DOLICHOL_LIPID_LINKED_OLIGOSACCHARIDE_LLO_AND_TRANSFER_TO_A_NASCENT_PROTEIN") {x <- "REACTOME_BIOSYNTHESIS_OF_N_GLYCAN_PRECURSOR_AND_TRANSFER_TO_A_NASCENT_PROTEIN"}
  if (x=="REACTOME_TRANSPORT_OF_GLUCOSE_AND_OTHER_SUGARS_BILE_SALTS_AND_ORGANIC_ACIDS_METAL_IONS_AND_AMINE_COMPOUNDS") {x <- "REACTOME_TRANSPORT_OF_BILE_SALTS"}
  if (x=="REACTOME_NEUROTRANSMITTER_RECEPTOR_BINDING_AND_DOWNSTREAM_TRANSMISSION_IN_THE_POSTSYNAPTIC_CELL") {x <- "REACTOME_NEUROTRANSMITTER_RECEPTORS"}
  if (x=="REACTOME_RESPIRATORY_ELECTRON_TRANSPORT_ATP_SYNTHESIS_BY_CHEMIOSMOTIC_COUPLING_AND_HEAT_PRODUCTION_BY_UNCOUPLING_PROTEINS"){x<-"REACTOME_RESPIRATORY_ELECTRON_TRANSPORT_ATP_SYNTHESIS"}
  return(x)
}

textconv_func <- function(x) {
  x=tolower(x)
  x=gsub("_"," ",x)
  x=gsub("27 hydroxycholesterol", "27-hydroxycholesterol", x)
  x=gsub("43s", "43S", x)
  x=gsub("apc c mediated", "APC/C-mediated", x)
  x=gsub("atp","ATP",x)
  x=gsub("b cell","B cell",x)
  x=gsub("bcr","BCR",x)
  x=gsub("bmp","BMP",x)
  x=gsub("ca2","Ca2",x)
  x=gsub("cap binding complex", "cap-binding complex", x)
  x=gsub("cct", "CCT", x)
  x=gsub("CCT tric", "CCT/TriC", x)
  x=gsub("class i mhc", "class I MHC", x)
  x=gsub("class iii", "class III", x)
  x=gsub("class ii", "class II", x)
  x=gsub("class i", "class I", x)
  x=gsub("c type lectin receptors clrs", "C-type lectin receptors (CLRs)",x)
  x=gsub("c mediated","C mediated",x)
  x=gsub("cdk2","Cdk2",x)
  x=gsub("ddx58 ifih1", "DDX58/IFIH1", x)
  x=gsub("dna", "DNA", x)
  x=gsub(" eifs"," eIFs", x)
  x=gsub("fceri", "FCERI", x)
  x=gsub("g1 s","G1/S",x)
  x=gsub("g alpha i","G alpha (i)",x)
  x=gsub("gpcr","GPCR",x)
  x=gsub("gtp","GTP",x)
  x=gsub("hiv", "HIV", x)
  x=gsub("ikks", "IKKs", x)
  x=gsub("inf", "INF", x)
  x=gsub("INFection","infection",x)
  x=gsub("INFluenza","influenza",x) # convert INF back to inf
  x=gsub("jak stat", "JAK-STAT", x)
  x=gsub(" llo", " LLO", x) # DOLICHOL_LIPID_LINKED_OLIGOSACCHARIDE_LLO
  x=gsub("kegg","KEGG:",x)
  x=gsub("ksrp","KSRP",x) # archived
  x=gsub(" m phase"," M phase",x)
  x=gsub("ncam1","NCAM1",x)
  x=gsub(" n glycan", " N glycan", x)
  x=gsub("nfkb", "NFkB", x)
  x=gsub("nf kb", "NFkB", x)
  x=gsub("nod1 2", "NOD1/2", x)
  x=gsub("nod like","NOD-like",x)
  x=gsub("non lymphoid","non-lymphoid",x)
  x=gsub("o linked", "O-linked",x)
  x=gsub("orc1", "Orc1", x)
  x=gsub("p 27 p21","p21/27",x)
  x=gsub("p450","P450",x)
  x=gsub("parkinsons", "Parkinson's", x)
  x=gsub("perk", "PERK", x)
  x=gsub("phospholipase c","phospholipase C",x)
  x=gsub("phase iii","phase III",x)
  x=gsub("phase ii","phase II",x)
  x=gsub("phase i","phase I",x)
  x=gsub("pol iii","pol III",x)
  x=gsub("pol ii","pol II",x)
  x=gsub("pol i","pol I",x)
  x=gsub("pre initiation","pre-initiation",x)
  x=gsub("pre mrna", "pre-mRNA",x)
  x=gsub("reactome","Reactome:",x)
  x=gsub("runx3","RUNX3",x)
  x=gsub("mhc","MHC",x)
  x=gsub("rho","Rho",x)
  x=gsub("rig i like", "RIG-I-like", x)
  x=gsub("rig i mda5", "RIG-I/MDA5", x)
  x=gsub("rna","RNA",x)
  x=gsub("teRNAry","ternary",x) # fix words replaced by RNA
  x=gsub(" s phase"," S phase",x)
  x=gsub("slits","SLITs",x)
  x=gsub("robo","ROBO",x)
  x=gsub("srp dependent","SRP-dependent",x)
  x=gsub("scf skp2", "SCF(Skp2)", x)
  x=gsub("tak1", "TAK1", x)
  x=gsub("tca","TCA",x)
  x=gsub("tcr signaling", "TCR signoaling", x)
  x=gsub("tgf","TGF",x)
  x=gsub("tp53","TP53",x)
  x=gsub("3 utr","3' UTR",x)
  x=gsub("cytokine cytokine receptor","cytokine-cytokine receptor",x)
  return(x)
}

checkvar_func <- function(variable) {
  if (variable!="") {
    if (!file.exists(get(variable))) {
      stop(variable,"='",get(variable),"' does not exist")
    }
  }
}
```

```{r eval=T, echo=F, fig.height=height, fig.width=15}
dat_barplot <- data.frame(pathway=res_barplot$pathway, NES=res_barplot$NES)
dummies=paste0(rep(LETTERS,each=length(LETTERS)),rep(LETTERS,length(LETTERS)))
dummy <- data.frame(pathway=c(dat_barplot[order(-dat_barplot$NES),"pathway"]),dummy=dummies[1:nrow(dat_barplot)])
dat_barplot <- merge(dat_barplot,dummy,by="pathway")
labels <- as.character(dummy$pathway)
labels <- unname(sapply(labels,textconv_func))
ggplot(dat_barplot,aes(y=NES,x=dummy)) + geom_bar(width=0.8, position=position_dodge(width=0.8), stat="identity", fill="#006d2c") + 
  coord_flip() +
  scale_x_discrete(labels=labels) +
  ylab("normalized enrichment score")+
  theme_bw()+
  theme(
    axis.title.y=element_blank(),
    axis.text.y=element_text(size=11),
    axis.title.x=element_text(size=9))
```

View leading edges in top pathways. Select top five pathways with positive and negative NES respectively

```{r, eval=T, echo=F}
res_pos = res_show[NES>=0]
if (nrow(res_pos)>0) {
  top_pos = res_pos[order(-NES)]$pathway[1:5]
  for (i in top_pos[!is.na(top_pos)]) {
    print(plotEnrichment(pathway = pathways.msigkeggreac[[i]], stats = gene_stat) + labs(title=i))
  }
}
```
             
```{r, eval=T, echo=F}
res_neg = res_show[NES<=0]
if (nrow(res_neg)>0) {
  top_neg = res_neg[order(NES)]$pathway[1:5]
  for (i in top_neg[!is.na(top_neg)]) {
    print(plotEnrichment(pathway = pathways.msigkeggreac[[i]], stats = gene_stat) + labs(title=i))
  }
}
```
             


## Housekeeping genes
Counts have been normalized by estimated size factors using DESeq2. Obtain the count matrix using function DESeq2::counts.

The table shows p-values of house-keeping genes for each comparison. Generally, house-keeping gene expressions do not change significantly in different conditions.

```{r, eval=T, echo=F, cache=F, warning=F, message=F}
if (exists("housekeeping_genes")) {
  sel_ids=as.character() # save selected Ensembl ID for house-keeping genes
  for (i in housekeeping_genes) {
    gene_symbol <- i
    gene_ids <- norm.counts[which(norm.counts$gene_symbol==i),'Gene']
    curr_data <- norm.counts[which(norm.counts$gene_symbol==i),names(norm.counts)[names(norm.counts)%in%coldata$Sample]]
    curr_data <- curr_data[which.max(rowSums(curr_data)),]
    gene_id <- gene_ids[which.max(rowSums(curr_data))] # choose Ensembl gene with the most counts
    sel_ids <- c(sel_ids, gene_id)
    curr_data <- data.frame(Sample=colnames(curr_data),Gene=rep(gene_id,ncol(curr_data)),gene_symbol=rep(gene_symbol,ncol(curr_data)),count=as.numeric(curr_data))
    curr_data <- merge(curr_data,coldata[which(coldata$Sample%in%curr_data$Sample),c('Sample','Status')],by='Sample')
    print(boxplot_func(df=curr_data))  }
  dat <- do.call(rbind,lapply(1:length(house_list),function(x){dat=house_list[[x]];dat$Comparison=names(house_list)[x];dat[which(dat$Gene%in%sel_ids),c('gene_symbol','pvalue','Comparison')]})) # obtain all p-value for house-keeping genes
  dat[,c('pvalue')] <- formatC(dat[,c('pvalue')], format = "e", digits = 2)
  dat <- dat %>% spread(gene_symbol, pvalue)
  DT::datatable(dat, rownames=FALSE, options = list(columnDefs = list(list(className = 'dt-center', targets = "_all"))))
}
```

## Favorite gene expressions in all conditions

```{r, eval=T, echo=F, cache=F, warning=F, message=F}
if (exists("fav_genes")&any(fav_genes%in%norm.counts$gene_symbol)) {
  sel_ids=as.character() # save selected Ensembl ID for favorite genes
  for (i in fav_genes) {
    gene_symbol <- i
    gene_ids <- norm.counts[which(norm.counts$gene_symbol==i),'Gene']
    curr_data <- norm.counts[which(norm.counts$gene_symbol==i),names(norm.counts)[names(norm.counts)%in%coldata$Sample]]
    curr_data <- curr_data[which.max(rowSums(curr_data)),]
    gene_id <- gene_ids[which.max(rowSums(curr_data))] # choose Ensembl gene with the most counts
    sel_ids <- c(sel_ids, gene_id)
    curr_data <- data.frame(Sample=colnames(curr_data),Gene=rep(gene_id,ncol(curr_data)),gene_symbol=rep(gene_symbol,ncol(curr_data)),count=as.numeric(curr_data))
    curr_data <- merge(curr_data,coldata[which(coldata$Sample%in%curr_data$Sample),c('Sample','Status')],by='Sample')
    print(boxplot_func(df=curr_data))  }
  dat <- do.call(rbind,lapply(1:length(fav_list),function(x){dat=fav_list[[x]];dat$Comparison=names(fav_list)[x];dat[which(dat$Gene%in%sel_ids),c('gene_symbol','pvalue','Comparison')]})) # obtain all p-value for favorite genes
  dat[,c('pvalue')] <- formatC(dat[,c('pvalue')], format = "e", digits = 2)
  dat <- dat %>% spread(gene_symbol, pvalue)
  DT::datatable(dat, rownames=FALSE, options = list(columnDefs = list(list(className = 'dt-center', targets = "_all"))))
}
```

```{r session_info, eval=T, echo=F}
pander(sessionInfo())
```