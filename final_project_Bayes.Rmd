---
title: "BMIN503 Final Project: Air Quality in American Communities"
author: "BayesB"
output: 
  html_document:
    toc: false 
    depth: 3 
    theme: paper 
    highlight: tango
---
```{r set-options, echo=FALSE, cache=FALSE}
options(width = 400)
```  

```{r eval=TRUE}
library(httr)
library(jsonlite)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(tigris)
library(sf)
library(tidycensus)
```

***

### Overview
*Give a brief a description of your project and its goal(s), what data you are using to complete it, and what three faculty/staff in different fields you have spoken to about your project with a brief summary of what you learned from each person. Include a link to your final project GitHub repository.*

This project considers the burdens of poor air quality and its health consequences, and how they fall on different American communities. To explore and understand these relationships, I use daily site-level testing data from the EPA's Air Quality System for small particulate matter (PM2.5) from 2019, linked with census data for the tract surrounding each testing site. I am still determining how I can best incorporate data on the near-term health effects of poor air quality, although my main goal is not to use air quality to predict those health outcomes, but rather to determine whether there are differences (e.g. in extent/significance) between how community characteristics predict air quality and how those same characteristics predict the prevalence of events like emergency department presentations for asthma exacerbation. In developing a plan for this project I met with Drs. Anil Vachani, Gary Weissman, and John P. Reilly, who provided insights on the causal pathway from pollution sources to specific EPA-measured pollutants to short- and long-term health outcomes; potential data sources and analytic approaches; the ways in which "natural experiments" related to major changes in pollutant generation have been used to compare the effects of perturbation from a steady state; and more. Materials for this project can be found in [this GitHub repository](https://github.com/bayesb/BMIN503_Final_Project). 

### Introduction 
*Describe the problem addressed, its significance, and some background to motivate the problem. Explain why your problem is interdisciplinary, what fields can contribute to its understanding, and incorporate background related to what you learned from meeting with faculty/staff.*

Poor air quality can have a substantial negative influence on health and quality of life, but different people will have different resources, incentives, and tradeoffs to consider in determining where to live, and we might expect that the relationship between who lives where and air quality is more complex than people with more wealth, income, and social power concentrating in places with better air quality. By considering many different community characteristics in building models to predict poor air quality, it is possible to learn which factors are most strongly associated with air quality and how successfully models trained on community characteristics can predict poor air quality and related health events.

### Methods
*Describe the data used and general methodological approach. Subsequently, incorporate full R code necessary to retrieve and clean data, and perform analysis. Be sure to include a description of code so that others (including your future self) can understand what you are doing and why.* 

Retrieve daily PM2.5 pollutant data for the lower 48 states for 2019 from the EPA's Air Quality System database via their API.

```{r eval=TRUE}
# Retrieve environment variables with EPA AQS API credentials
api.email <- Sys.getenv("EPA_AQS_EMAIL")
api.key   <- Sys.getenv("EPA_AQS_KEY")

# Function to create a data frame based on an API call
download.AQS <- function(whichData,customParams) { 
  rootpath <- "https://aqs.epa.gov/data/api/"
  morepath <- paste0(rootpath,whichData)
  fullParams <- append(list(email = api.email, key = api.key),customParams)
  step1.json <- httr::GET(url = morepath, query = fullParams)
  step2.parsed <- jsonlite::fromJSON(content(step1.json, "text"), simplifyVector = FALSE)
  step3.df <- tibble(Data = step2.parsed$Data) %>% unnest_wider(.,Data)
  return(step3.df)
}

# Fetch documentation for daily data summaries, state code list
dailyData.dictionary <- download.AQS("metaData/fieldsByService",list(service = "dailyData"))
list.states <- download.AQS("list/states",list())

# Omitting state codes other than 48 states + D.C.
list.states.lower48 <- list.states %>% filter(!(code %in% c("02","15","66","72","78","80","CC")))
list.states.lower48
lower48.codes <- as.vector(as.matrix(list.states.lower48[,1]))
```

```{r eval=FALSE}
# Pull daily PM2.5 (parameter 88101) data for these states, with arguments for date range
get.daily.lower48 <- function(b,e){
collector <- data.frame()
for (s in seq_along(lower48.codes)) {
  newstate <- download.AQS("dailyData/byState", list(param="88101", bdate=b, edate=e, state=list.states.lower48[s,1]))
  collector <- bind_rows(collector,newstate)
  }
  return(collector)
}

# Run in monthly batches
dailyPM2.5_201901 <- get.daily.lower48("20190101","20190131")
dailyPM2.5_201902 <- get.daily.lower48("20190201","20190228")
dailyPM2.5_201903 <- get.daily.lower48("20190301","20190331")
dailyPM2.5_201904 <- get.daily.lower48("20190401","20190430")
dailyPM2.5_201905 <- get.daily.lower48("20190501","20190531")
dailyPM2.5_201906 <- get.daily.lower48("20190601","20190630")
dailyPM2.5_201907 <- get.daily.lower48("20190701","20190731")
dailyPM2.5_201908 <- get.daily.lower48("20190801","20190831")
dailyPM2.5_201909 <- get.daily.lower48("20190901","20190930")
dailyPM2.5_201910 <- get.daily.lower48("20191001","20191031")
dailyPM2.5_201911 <- get.daily.lower48("20191101","20191130")
dailyPM2.5_201912 <- get.daily.lower48("20191201","20191231")
 
# Concatenate monthly batch files into a single file for 2019
all.2019.dailyPM2.5 <- bind_rows( dailyPM2.5_201901
                                 ,dailyPM2.5_201902
                                 ,dailyPM2.5_201903
                                 ,dailyPM2.5_201904
                                 ,dailyPM2.5_201905
                                 ,dailyPM2.5_201906
                                 ,dailyPM2.5_201907
                                 ,dailyPM2.5_201908
                                 ,dailyPM2.5_201909
                                 ,dailyPM2.5_201910
                                 ,dailyPM2.5_201911
                                 ,dailyPM2.5_201912)

# Save full 2019 raw file
saveRDS(all.2019.dailyPM2.5, file = "all2019dailyPM25.RDS")

```


Create a unique list of testing site locations and a corresponding `site_id`. 

```{r eval=TRUE}
# Load the full 2019 raw file
all.2019.dailyPM2.5 <- readRDS("all2019dailyPM25.RDS")
str(all.2019.dailyPM2.5)

# Create a file of all unique combinations of geographic indicators for testing sites
testing.sites <- all.2019.dailyPM2.5 %>%
                      select(state_code, state, 
                             county_code, county,
                             city, cbsa_code, cbsa,
                             site_number, local_site_name, site_address,
                             latitude, longitude) %>%
                      unique() %>%
                      arrange(state_code,county_code,site_number)
dim(testing.sites)
# 965 combinations

# Create a single unique ID column for site
testing.sites %>% select(site_number) %>% unique() %>% dim()
testing.sites %>% select(state_code,site_number) %>% unique() %>% dim()
testing.sites %>% select(state_code,county_code,site_number) %>% unique() %>% dim()
# Only 253 unique site numbers. 770 state-site combos. 
# State + county + site number *is* unique (965 combos)

clean.2019.dailyPM2.5 <- all.2019.dailyPM2.5 %>%
  mutate(site_id = paste0(state_code,county_code,site_number))

```

```{r eval=FALSE}
# Prepare for spatial merge. Create sf file from testing site coordinates
testing.sites.sf.points <- st_as_sf(testing.sites, coords = c('longitude','latitude'), crs = 4269)

# Download census tract sf shapefiles, one state at a time.
# Perform spatial joins one state at a time to avoid having to build the national tract shapefile.
for (s in seq_along(lower48.codes)) {
  newstate <- lower48.codes[s]
  newtracts <- tracts(newstate)
  newjoin <- st_join(newtracts, testing.sites.sf.points, join = st_contains, left=FALSE)
  if (s==1){
    testing.sites.tracts <- newjoin
  } else {
    testing.sites.tracts <- bind_rows(testing.sites.tracts,newjoin)
  }
}

# Save file with testing sites <> census tract
saveRDS(testing.sites.tracts, file = "testing_sites_tracts.RDS")
```

```{r eval=TRUE}
testing.sites.tracts <- readRDS("testing_sites_tracts.RDS")
head(testing.sites.tracts)

census.1yr.vars <- load_variables(dataset = "acs1",year = 2019)
head(census.1yr.vars)

census.1yr.concept.counts <- 
  census.1yr.vars %>% 
  mutate(root.concept = str_split_fixed(concept," BY",2)[,1]) %>%
  mutate(root.concept = str_split_fixed(root.concept," \\(",2)[,1]) %>% 
    # Double escape needed to match open parenthesis!
  group_by(root.concept) %>%
  summarise(obs=n(), .groups="keep") %>%
  arrange(-obs)

# head(census.1yr.concept.counts)
View(census.1yr.concept.counts)
```












```{r eval=FALSE}
# sf.AL <- tracts('01')
# st_crs(sf.AL) # NAD83, 4269
# 
# sf.16 <- tracts('16')
# getwd()
# 
# 
# sf.AL.join <- st_join(sf.AL, testing.sites.sf.points, join = st_contains, left=FALSE)
# testing.sites %>% filter(state_code == '01')
# 
# 
# head(sf.AL.join)
# 
# ?st_join
# 
# testing.sites.sf.xform  <- st_transform(testing.sites.sf.points, 4269)
# st_crs(testing.sites.sf.points) # WGS84, 4326 
# st_crs(testing.sites.sf.xform)  # NAD83, 4269
# 
# ?st_transform






?tracts

install.packages('tigris')
library(tigris)

?st_as_sf



get.daily.lower48 <- function(b,e){
collector <- data.frame()
for (s in seq_along(lower48.codes)) {
  newstate <- download.AQS("dailyData/byState", list(param="88101", bdate=b, edate=e, state=list.states.lower48[s,1]))
  collector <- bind_rows(collector,newstate)
  }
  return(collector)
}

?tracts
https://rdrr.io/cran/tigris/man/tracts.html



head(testing.sites)
head(testing.sites.sf.points)

#Instead of data.frame of class "sp", create "simple features"-data.frame 

sf_df = st_as_sf(df, coords = c("longitude", "latitude"), crs = 4326)

#You'll have to convert your shapefile to sf, too. 
#Depending what class it is you can use "st_as_sf()"


#Then join the shapefile with sf_df via the "st_contains" which merges two rows 
#if a point from sf_df falls within a polygon from the shapefile.

shape_df <- st_join(shapefile, sf_df , join = st_contains)



?st_join



View(testing.sites)




cbsa.counts <- testing.sites %>% group_by(cbsa) %>% summarise(obs=n(),.groups="keep") %>% arrange(-obs)
View(cbsa.counts)

??tigris


testme <- testing.sites[1:2,]

testme.out <- testme %>%
                mutate(census.block = call_geolocator_latlon(latitude, longitude))


install.packages('tidygeocoder')
library('tidygeocoder')
?tidygeocoder::geocode

full <- some_addresses %>%
  geocode(addr, method = 'census', full_results = TRUE, return_type = 'geographies')


testing.sites.geocode1 <- testing.sites %>%
                            geocode(site_address
                                  ,method = 'census'
                                  ,full_results = TRUE
                                  ,return_type = 'geographies')

View(testing.sites.geocode1)


testing.sites.geocode2 <- testing.sites %>%
                            rename(latitude.orig = latitude, longitude.orig = longitude) %>%
                            filter(county_code == '001') %>%
                            geocode(street = site_address
                                  ,city = city
                                  ,state = state
                                  # ,lat = latitude.orig
                                  # ,long = longitude.orig
                                  ,method = 'census'
                                  ,full_results = TRUE
                                  ,return_type = 'geographies')

```


Join testing site locations data with census tracts. (Still to come)
Label the PM2.5 data with census tract. (Still to come)
Create outcomes summarized by census tract based on PM2.5 readings for the year.

```{r eval=TRUE}
# Look at attributes of arithmetic_mean
summary(clean.2019.dailyPM2.5$arithmetic_mean)
dim(clean.2019.dailyPM2.5)
sum(!is.na(clean.2019.dailyPM2.5$arithmetic_mean))
sum(clean.2019.dailyPM2.5$arithmetic_mean >= 0)

#################################################
# More data cleaning and exploration needed here! Including plots
#################################################

# Create summary metrics
site.summary.PM2.5 <- clean.2019.dailyPM2.5 %>%
                        mutate(arithmetic_mean = case_when(arithmetic_mean < 0 ~ 0, TRUE ~ arithmetic_mean)) %>%
                        group_by(site_id,
                             state_code, state, 
                             county_code, county,
                             city, cbsa_code, cbsa,
                             site_number, local_site_name, site_address,
                             latitude, longitude) %>%
                        summarise(pm2.5_mean = mean(arithmetic_mean),
                                    pm2.5_p10 = quantile(arithmetic_mean, 0.10), 
                                    pm2.5_p25 = quantile(arithmetic_mean, 0.25), 
                                    pm2.5_p50 = quantile(arithmetic_mean, 0.50), 
                                    pm2.5_p75 = quantile(arithmetic_mean, 0.75), 
                                    pm2.5_p90 = quantile(arithmetic_mean, 0.90), 
                                    .groups = "keep") %>%
                        arrange(-pm2.5_p50)

head(site.summary.PM2.5)
tail(site.summary.PM2.5)
          
```


Visualizations of 2019 air quality summaries across the U.S.

```{r eval=TRUE}

library(maps)

ggplot(data = site.summary.PM2.5, aes(x = longitude, y = latitude, color = pm2.5_p50)) + 
    geom_point() + 
    borders("state") + 
    scale_color_gradient(low = "#ffff00", high = "#0000ff") +
    labs(title = "Median daily PM2.5 reading for 2019 by testing site") +
    labs(x = "Longitude", y = "Latitude") + 
    theme_bw() 

ggplot(data = site.summary.PM2.5, aes(x = longitude, y = latitude, color = pm2.5_p90)) + 
    geom_point() + 
    borders("state") + 
    scale_color_gradient(low = "#ffff00", high = "#ff0000") +
    labs(title = "90th percentile daily PM2.5 reading for 2019 by testing site") +
    labs(x = "Longitude", y = "Latitude") + 
    theme_bw() 

```



```{r eval=FALSE, echo=FALSE}

#################################################
# Scraps from previous attempts I'm keeping in case I need them later...
#################################################

table(all.2019.dailyPM2.5$units_of_measure, useNA = TRUE)
# All Micrograms/cubic meter (LC) 

table(round(all.2019.dailyPM2.5$sample_measurement))

# Plot distribution of time-of-day-of-measurement by testing site, 
# to determine whether an overall plot of measurement x time of day will be representative



# Try getting 1 month of state-level daily summary data - Jan 2017, Pennsylvania

# 88101	: PM2.5 - Local Conditions

dSum.PA201701.PM2.5Local <- get.AQS.data(
    "/data/api/dailyData/byState?email=api.email&key=api.key&param=88101&bdate=20170101&edate=20170131&state=42"
)

head(dSum.PA201701.PM2.5Local)
table(dSum.PA201701.PM2.5Local$county_code)
summary(dSum.PA201701.PM2.5Local)
View(dSum.PA201701.PM2.5Local)

table(dSum.PA201701.PM2.5Local$local_site_name,useNA="ifany") 
# 1,445 NA
dSum.PA201701.PM2.5Local %>% filter(is.na(local_site_name)) %>% View()

dSum.PA201701.PM2.5Local %>% 
  group_by(county_code,site_number,cbsa_code,site_address,local_site_name) %>% 
  summarise(count=n(), .groups="keep")

length(unique(dSum.PA201701.PM2.5Local$local_site_name))
# 38 unique sites

table(dSum.PA201701.PM2.5Local$observation_count)
# Ranges from 1 to 24
table(dSum.PA201701.PM2.5Local$units_of_measure) 
# Micrograms/cubic meter (LC) for all




dSum.PA201701.PM2.5Local %>% filter(observation_count > 20) %>% View()


# Site_number is not unique. Is county (or county_code) x site_number unique? 
PA.testing.sites %>% 
  select(county, site_number) %>%
  unique() %>%
  dim()

# Yes. Create county (1st 4 letters) + site_number to have something unique and also sort of readable.

PA.testing.sites <- PA.testing.sites %>%
                      mutate(site_cty = paste0(substring(toupper(county),1,4),site_number))

table(PA.testing.sites$site_cty)
length(unique(PA.testing.sites$site_cty))

# Apply to full data set

all.2019.dailyPM2.5 <- all.2019.dailyPM2.5 %>%
                  mutate(site_cty = paste0(substring(toupper(county),1,4),site_number))

table(all.2019.dailyPM2.5$site_cty)

# What do the counts look like by site?

PA.site.counts <- all.2019.dailyPM2.5 %>%
                    group_by(site_cty) %>%
                    summarize(obs = n(), .groups = "keep") %>%
                    arrange(-obs)

head(PA.site.counts)

PA.site.counts %>% filter(obs > 10000)
# WASH0005	17885			
# CAMB0011	17520	

# Look more closely - should these actually be 2 sites (with the same long/lat?)?
all.2019.dailyPM2.5 %>% filter(site_cty == "WASH0005") %>% View()

table(all.2019.dailyPM2.5$method_code,all.2019.dailyPM2.5$site_cty)
# Some sites use different methods at different points in the year
# The 2 highest-count sites appear to use 2 methods simultaneously throughout the year
# One method appears seems likely to be a daily measurement which should be ignored 
# in considering trends by time of day

ggplot(data = all.2019.dailyPM2.5, aes(x = factor(substring(time_local,1,2)), fill = factor(method_code))) + 
    geom_bar(position = "stack")

# Yes. Ignore method_code = "145" for considering time-of-day. Also ignore time_local = "00:14"

all.2019.dailyPM2.5 %>%
  filter(method_code != "145" & time_local != "00:14") %>%
  ggplot(data = ., aes(x = site_cty, fill = factor(substring(time_local,1,2)))) + 
    geom_bar(position = "stack")

# Also drop sites that have less than approx 1 measurement/hour for the year (365 x 24 = 8760)
PA.site.counts %>% filter(obs < 8000)
# LYCO0419	3840			
# WYOM0010	672			
# ALLE0067	121			
# ALLE1008	121			
# ALLE1301	121			
# ALLE0093	61			
# ALLE3007	61	

all.2019.dailyPM2.5 %>%
  filter(method_code != "145" & time_local != "00:14" & !(site_cty %in% c("LYCO0419","WYOM0010"))) %>%
  ggplot(data = ., aes(x = site_cty, fill = factor(substring(time_local,1,2)))) + 
    geom_bar(position = "stack")

# Now, ready to make violin plots for sample_measurement by time_local

# #########################################
# NEED TO REMOVE NA MEASUREMENT VALUES!!!
# #########################################

all.2019.dailyPM2.5 %>% filter(is.na(sample_measurement) == TRUE) %>% View()
# Consider the `qualifier` field - seems to explain why no measurement was collected 

# table(all.2019.dailyPM2.5$qualifier,useNA = "always")
# all.2019.dailyPM2.5 %>% select(qualifier) %>% unique() %>% arrange(qualifier)

PA.qualifier.counts <- all.2019.dailyPM2.5 %>% 
                        mutate(any_measure = !is.na(sample_measurement)) %>%
                        group_by(any_measure,qualifier) %>% 
                        summarize(obs = n(), .groups = "keep") %>% 
                        arrange(-any_measure, -obs)

PA.qualifier.counts

all.2019.dailyPM2.5 %>% filter(!is.na(qualifier) & !is.na(sample_measurement)) %>% View()
# Not many in total and most are type 145 anyway

all.2019.dailyPM2.5 %>% filter(!is.na(qualifier) & !is.na(sample_measurement) & method_code != "145") %>% View()
# 5 records, all flagged as "Outlier" - no need to exclude here

all.2019.dailyPM2.5 %>%
  filter(method_code != "145" & time_local != "00:14" & !(site_cty %in% c("LYCO0419","WYOM0010"))) %>%
  select(sample_measurement) %>%
  summary()


table(round(all.2019.dailyPM2.5$sample_measurement))

# 75th pct 11.0 but max 217.9 !! 
# And negative concentrations are impossible; code to 0

all.2019.dailyPM2.5 %>%
  filter(method_code != "145" & time_local != "00:14" & !(site_cty %in% c("LYCO0419","WYOM0010")) & sample_measurement < 0) %>% 
  View()

all.2019.dailyPM2.5 %>%
  filter(method_code != "145" & time_local != "00:14" & !(site_cty %in% c("LYCO0419","WYOM0010")) & sample_measurement >= 100) %>% 
  View()

clean.all.2019.dailyPM2.5 <- all.2019.dailyPM2.5 %>%
                        filter(method_code != "145" 
                               & time_local != "00:14" 
                               & !(site_cty %in% c("LYCO0419","WYOM0010"))
                               & !is.na(sample_measurement)) %>%
                        mutate(sample_measurement = case_when(sample_measurement < 0 ~ 0, TRUE ~ sample_measurement))

dim(clean.all.2019.dailyPM2.5)
table(round(clean.all.2019.dailyPM2.5$sample_measurement),useNA = "always")

ggplot(data = clean.all.2019.dailyPM2.5, aes(x = site_cty, fill = factor(substring(time_local,1,2)))) + 
    geom_bar(position = "stack")

ggplot(data = clean.all.2019.dailyPM2.5, aes(x = factor(substring(time_local,1,2)), y = sample_measurement)) + 
    geom_violin(fill = "lightblue", draw_quantiles = c(0.10,0.30, 0.50, 0.70, 0.90)) +
    ylim(c(0,25))

# There is some fluctuation by time of day -- 
# But, all of the site left in have ~hourly readings throughout the year. 
# So it would still be reasonable to compute annual percentiles and means by site 
# for an overall sense of typical particulate conditions by geography. 

clean.PA.site.summary <- clean.all.2019.dailyPM2.5 %>%
                          group_by(site_cty,county,county_code,site_number,latitude,longitude) %>%
                          summarise(pm2.5_mean = mean(sample_measurement),
                                    pm2.5_p10 = quantile(sample_measurement, 0.10), 
                                    pm2.5_p25 = quantile(sample_measurement, 0.25), 
                                    pm2.5_p50 = quantile(sample_measurement, 0.50), 
                                    pm2.5_p75 = quantile(sample_measurement, 0.75), 
                                    pm2.5_p90 = quantile(sample_measurement, 0.90), 
                                    .groups = "keep") %>%
                          arrange(-pm2.5_p50)

View(clean.PA.site.summary)
summary(clean.PA.site.summary$longitude)
summary(clean.PA.site.summary$latitude)

# more to come
```

Retrieve a range of census descriptive data by census tract. 
Join with air quality summary data.

```{r eval=FALSE}

# still to come 

```


### Results
*Describe your results and include relevant tables, plots, and code/comments used to obtain them. End with a brief conclusion of your findings related to the question you set out to address. You can include references if you'd like, but this is not required.*

Perform bivariate tests of community characteristics vs air quality (continous measures and 1/0 for poor air quality above threshold). Create multivariate models to predict air quality from community characteristics. Construct a classifier using community characteristics and evaluate its performance against the real data. 

```{r eval=FALSE}

# still to come

```




