---
title: "BMIN503 Final Project: Air Quality in American Communities"
author: "BayesB"
output: 
  html_document:
    toc: false 
    depth: 3 
    theme: paper 
    highlight: tango
---
```{r set-options, echo=FALSE, cache=FALSE}
options(width = 400)
```  

```{r all-libraries, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE}
library(httr)
library(jsonlite)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(tigris)
library(sf)
library(tidycensus)
library(leaflet)
library(randomForest)
library(e1071)
```

***

### Overview
*Give a brief a description of your project and its goal(s), what data you are using to complete it, and what three faculty/staff in different fields you have spoken to about your project with a brief summary of what you learned from each person. Include a link to your final project GitHub repository.*

This project considers the burdens of poor air quality and its health consequences, and how they fall on different American communities. To explore and understand these relationships, I use daily site-level testing data from the EPA's Air Quality System for small particulate matter (PM2.5) from 2019, linked with census data for the tract surrounding each testing site. I am still determining how I can best incorporate data on the near-term health effects of poor air quality, although my main goal is not to use air quality to predict those health outcomes, but rather to determine whether there are differences (e.g. in extent/significance) between how community characteristics predict air quality and how those same characteristics predict the prevalence of events like emergency department presentations for asthma exacerbation. In developing a plan for this project I met with Drs. Anil Vachani, Gary Weissman, and John P. Reilly, who provided insights on the causal pathway from pollution sources to specific EPA-measured pollutants to short- and long-term health outcomes; potential data sources and analytic approaches; the ways in which "natural experiments" related to major changes in pollutant generation have been used to compare the effects of perturbation from a steady state; and more. Materials for this project can be found in [this GitHub repository](https://github.com/bayesb/BMIN503_Final_Project). 

### Introduction 
*Describe the problem addressed, its significance, and some background to motivate the problem. Explain why your problem is interdisciplinary, what fields can contribute to its understanding, and incorporate background related to what you learned from meeting with faculty/staff.*

Poor air quality can have a substantial negative influence on health and quality of life, but different people will have different resources, incentives, and tradeoffs to consider in determining where to live, and we might expect that the relationship between who lives where and air quality is more complex than people with more wealth, income, and social power concentrating in places with better air quality. By considering many different community characteristics in building models to predict poor air quality, it is possible to learn which factors are most strongly associated with air quality and how successfully models trained on community characteristics can predict poor air quality and related health events.

### Methods
*Describe the data used and general methodological approach. Subsequently, incorporate full R code necessary to retrieve and clean data, and perform analysis. Be sure to include a description of code so that others (including your future self) can understand what you are doing and why.* 

I begin by defining a function to create a data frame from the results of a GET call to the EPA's Air Quality System API. I create objects with relevant reference lists and define a vector for the "lower 48" U.S. states and Washington, D.C. for later use. 

```{r get-AQS-setup, eval=TRUE}
# Retrieve environment variables with EPA AQS API credentials
api.email <- Sys.getenv("EPA_AQS_EMAIL")
api.key   <- Sys.getenv("EPA_AQS_KEY")

# Function to create a data frame based on an API call
download.AQS <- function(whichData,customParams) { 
  rootpath <- "https://aqs.epa.gov/data/api/"
  morepath <- paste0(rootpath,whichData)
  fullParams <- append(list(email = api.email, key = api.key),customParams)
  step1.json <- httr::GET(url = morepath, query = fullParams)
  step2.parsed <- jsonlite::fromJSON(httr::content(step1.json,"text"), simplifyVector = FALSE)
  step3.df <- tibble(Data = step2.parsed$Data) %>% unnest_wider(.,Data)
  return(step3.df)
}

# Fetch documentation for daily data summaries, state code list
dailyData.dictionary <- download.AQS("metaData/fieldsByService",list(service = "dailyData"))
list.states <- download.AQS("list/states",list())

# Omitting state codes other than 48 states + D.C.
list.states.lower48 <- list.states %>% filter(!(code %in% c("02","15","66","72","78","80","CC")))
list.states.lower48
lower48.codes <- as.vector(as.matrix(list.states.lower48[,1]))
```

To manage downloading daily PM2.5 data for each state for all of 2019, I define another function to loop through the state FIPS codes for given date parameters. Executing this step with 1 call per month of data takes roughly 90 minutes, so I save the resulting data frame and load it in the chunk below.
```{r download-AQS-2019, eval=FALSE, echo=TRUE}
# Pull daily PM2.5 (parameter 88101) data for these states, with arguments for date range
get.daily.lower48 <- function(b,e){
collector <- data.frame()
for (s in seq_along(lower48.codes)) {
  newstate <- download.AQS("dailyData/byState", list(param="88101", bdate=b, edate=e, state=list.states.lower48[s,1]))
  collector <- bind_rows(collector,newstate)
  }
  return(collector)
}

# Run in monthly batches
dailyPM2.5_201901 <- get.daily.lower48("20190101","20190131")
dailyPM2.5_201902 <- get.daily.lower48("20190201","20190228")
dailyPM2.5_201903 <- get.daily.lower48("20190301","20190331")
dailyPM2.5_201904 <- get.daily.lower48("20190401","20190430")
dailyPM2.5_201905 <- get.daily.lower48("20190501","20190531")
dailyPM2.5_201906 <- get.daily.lower48("20190601","20190630")
dailyPM2.5_201907 <- get.daily.lower48("20190701","20190731")
dailyPM2.5_201908 <- get.daily.lower48("20190801","20190831")
dailyPM2.5_201909 <- get.daily.lower48("20190901","20190930")
dailyPM2.5_201910 <- get.daily.lower48("20191001","20191031")
dailyPM2.5_201911 <- get.daily.lower48("20191101","20191130")
dailyPM2.5_201912 <- get.daily.lower48("20191201","20191231")
 
# Concatenate monthly batch files into a single file for 2019
all.2019.dailyPM2.5 <- bind_rows( dailyPM2.5_201901
                                 ,dailyPM2.5_201902
                                 ,dailyPM2.5_201903
                                 ,dailyPM2.5_201904
                                 ,dailyPM2.5_201905
                                 ,dailyPM2.5_201906
                                 ,dailyPM2.5_201907
                                 ,dailyPM2.5_201908
                                 ,dailyPM2.5_201909
                                 ,dailyPM2.5_201910
                                 ,dailyPM2.5_201911
                                 ,dailyPM2.5_201912)

# Save full 2019 raw file
saveRDS(all.2019.dailyPM2.5, file = "all2019dailyPM25.RDS")

```

I test combinations of testing site location identifiers and add a single `site_id` variable to the 2019 PM2.5 data set by concatenating location identifiers. I also create a data frame with one observation per testing site.
```{r unique-AQS-sites, eval=TRUE}
# Load the full 2019 raw file
all.2019.dailyPM2.5 <- readRDS("all2019dailyPM25.RDS")
str(all.2019.dailyPM2.5)

# Create a file of all unique combinations of geographic indicators for testing sites
testing.sites <- all.2019.dailyPM2.5 %>%
                      dplyr::select(state_code, state, 
                             county_code, county,
                             city, cbsa_code, cbsa,
                             site_number, local_site_name, site_address,
                             latitude, longitude) %>%
                      unique() %>%
                      arrange(state_code,county_code,site_number)
dim(testing.sites)
# 965 combinations

# Create a single unique ID column for site
testing.sites %>% dplyr::select(site_number) %>% unique() %>% dim()
testing.sites %>% dplyr::select(state_code,site_number) %>% unique() %>% dim()
testing.sites %>% dplyr::select(state_code,county_code,site_number) %>% unique() %>% dim()
# Only 253 unique site numbers. 770 state-site combos. 
# State + county + site number *is* unique (965 combos)

clean.2019.dailyPM2.5 <- all.2019.dailyPM2.5 %>%
  mutate(site_id = paste0(state_code,county_code,site_number))

```

Using the `tigris::tracts` function, I retrieve the geometries, GEOIDs, and other spatial information for census tracts and join each AQS testing site to the data for the tract within which it lies, based on the latitude and longitude from AQS. I looping through the state FIPS codes one at a time and stack the results into a single crosswalk file. This step is time-consuming so I save the resulting file and load it in the next step.  

```{r spatial-join, eval=FALSE, echo=TRUE}
# Prepare for spatial merge. Create sf file from testing site coordinates
testing.sites.sf.points <- st_as_sf(testing.sites, coords = c('longitude','latitude'), crs = 4269)

# Download census tract sf shapefiles, one state at a time.
# Perform spatial joins one state at a time to avoid having to build the national tract shapefile.
for (s in seq_along(lower48.codes)) {
  newstate <- lower48.codes[s]
  newtracts <- tracts(newstate)
  newjoin <- st_join(newtracts, testing.sites.sf.points, join = st_contains, left=FALSE)
  if (s==1){
    testing.sites.tracts <- newjoin
  } else {
    testing.sites.tracts <- bind_rows(testing.sites.tracts,newjoin)
  }
}

# Save file with testing sites <> census tract
saveRDS(testing.sites.tracts, file = "testing_sites_tracts.RDS")
```

From `tidycensus` I now retrieve the variable list for the 2018 5-year American Community Survey. After reviewing the concepts from those variables as well as the [questionnaire](http://www2.census.gov/programs-surveys/acs/methodology/questionnaires/2018/quest18.pdf), I create an object with a set of variables to test for associations with the AQS data.

```{r set-ACS-var-list, eval=TRUE}
testing.sites.tracts <- readRDS("testing_sites_tracts.RDS")
head(testing.sites.tracts)

# Load a data frame with all 5-year ACS variables
census.1yr.vars <- load_variables(dataset = "acs5",year = 2018)
head(census.1yr.vars)

# Simplify the variable list to make it easier to review the major concepts represented
census.1yr.concept.counts <- 
  census.1yr.vars %>% 
  mutate(root.concept = str_split_fixed(concept," BY",2)[,1]) %>%
  mutate(root.concept = str_split_fixed(root.concept," \\(",2)[,1]) %>% 
      # Double escape needed to match open parenthesis!
  mutate(root.name = substring(name,1,6)) %>%
  group_by(root.name,root.concept) %>%
  summarise(obs=n(), .groups="keep") %>%
  arrange(root.name,-obs)

# View(sort(unique(census.1yr.concept.counts$root.concept)))

# After reviewing the variable list, create an object with the ones of interest
final.acs.var.list <- census.1yr.vars %>% filter(name %in% c(
     "B01002_001" # median age
    ,"B03002_003","B03002_001" # Hon-Hisp-White-alone // Denom
    ,"B02009_001","B02001_001" # Black race, alone or in combination // Denom
    ,"B06008_003","B06008_001" # Now married // Denom
    ,"B23007_002","B23007_001" # Children under 18yrs in household // Denom
    ,"B15003_022","B15003_023","B15003_024","B15003_025","B15003_001" # Bachelors // Masters // Professional // Doctorate // Denom
    ,"B23022_027","B23022_026","B23022_003","B23022_002" # Worked in past 12 months-Female // Denom-Female // p12-Male // Denom-Male
    ,"B21001_002","B21001_001" # Veteran // Denom
    ,"B17001_002","B17001_001" # Past 12mo income at or below poverty level, Denom
    ,"B22010_002","B22010_001" # Received SNAP in past 12mo, Denom
    ,"B22008_001"  # Median household income, past 12mo
    ,"B25008_003","B25008_001" # Renter occupied, Denom
    ,"B25024_002","B25024_003","B25024_001" # Single-fam, detached // single-fam, attached // Denom
    ,"B25064_001" # Median gross rent
    ,"B25088_002" # Median monthly owner costs for households with a mortgage
    ,"B08126_004","B08126_002","B08126_001" # INDUSTRY: Manufacturing // Agriculture, fishing, mining // Denom
    ,"B08006_003","B08006_001" # Drove to work alone // Denom
    ,"B08013_001" # Aggregate travel time to work in minutes
  )) %>% arrange(name)

final.acs.var.list

```

Once more I loop through the state FIPS codes, retrieving the ACS variables of interest by tract as a flat file using `tidycensus::get_acs` and preserving the data only for the census tracts that contain AQS testing sites. As this is another slow step, I save the resulting data frame. 

```{r download-ACS-for-tracts, eval=FALSE, echo=TRUE}
head(testing.sites.tracts)

# Keep only what is needed to make the ACS calls in a small data frame
tst.minimal <- testing.sites.tracts %>% 
                mutate(site_id = paste0(state_code,county_code,site_number)) %>%
                dplyr::select(site_id, GEOID, STATEFP, COUNTYFP)
st_geometry(tst.minimal) <- NULL

# Loop through existing list of state codes
lower48.codes

# Make ACS calls one state at a time, only for counties with AQS testing sites
# Preserve estimate columns, ditch MOE
# Join to testing site list
# Stack ACS data together in a single data frame

acs.loop <- function(){
  for (st in seq_along(lower48.codes)) {
    
    newstate <- lower48.codes[st]
    
    county.list <- tst.minimal %>% 
                  filter(STATEFP==newstate) %>% 
                  dplyr::select(COUNTYFP) %>%
                  arrange(COUNTYFP) %>%
                  as.matrix() %>% as.vector() %>% as.list()
    
    results.acs <- get_acs( geography = "tract"
                          ,variables=as.list(final.acs.var.list$name)
                          ,state = newstate
                          ,county = county.list
                          ,output = "wide")
    
    smaller.acs <- results.acs %>% dplyr::select(GEOID,matches(".*_.*E$"))
  
    linked.acs <- tst.minimal %>% 
                filter(STATEFP==newstate) %>%
                left_join(.,smaller.acs,by="GEOID")
    
    if (st==1){
      collect <- linked.acs
    } else {
      collect <- bind_rows(collect,linked.acs)
    }
  }
  return(collect)
}

testing.sites.acs <- acs.loop()
testing.sites.acs

saveRDS(testing.sites.acs, file = "testing_sites_acs.RDS")
```

With all the ACS data I need, I can create clean versions of the variables to be included in the analysis. I exclude tracts that do not have complete data for all 19 ACS-based variables or with fewer than 500 respondents in the sample (using the denominator from the set of race variables).

```{r ACS-data-cleaning, eval=TRUE}
testing.sites.acs <- readRDS("testing_sites_acs.RDS")
head(testing.sites.acs)

# Create percentage variables and scaled medians/totals to use in modeling
testing.sites.acs.ready <- testing.sites.acs %>%
  dplyr::rename( age.median       = B01002_001E
                ,income.hh.median = B22008_001E 
                ,rent.median      = B25064_001E
                ,home.pmt.median  = B25088_002E
                ,commute.time.agg = B08013_001E) %>%
  mutate( race.black.any          = 100*B02009_001E/B02001_001E
         ,ethn.nhisp.white.alone  = 100*B03002_003E/B03002_001E
         ,married                 = 100*B06008_003E/B06008_001E
         ,kids                    = 100*B23007_002E/B23007_001E
         ,bachelor.plus           = 100*(B15003_022E + B15003_023E + B15003_024E + B15003_025E)/B15003_001E
         ,veteran                 = 100*B21001_002E/B21001_001E
         ,manufacturing           = 100*B08126_004E/B08126_001E
         ,farm.fish.mining        = 100*B08126_002E/B08126_001E
         ,commutes.car.alone      = 100*B08006_003E/B08006_001E
         ,renter                  = 100*B25008_003E/B25008_001E
         ,single.fam.home         = 100*(B25024_002E + B25024_003E)/B25024_001E
         ,worked.12mo             = 100*(B23022_027E + B23022_003E)/(B23022_026E + B23022_002E) 
         ,poverty.12mo            = 100*B17001_002E/B17001_001E
         ,snap.12mo               = 100*B22010_002E/B22010_001E
         ,denominator             = B02001_001E) %>%
  dplyr::select(-matches("^B[012].*"))

head(testing.sites.acs.ready)
summary(testing.sites.acs.ready)
# testing.sites.acs.ready %>% dplyr::filter(denominator < 1000) %>% View()
# testing.sites.acs.ready %>% dplyr::filter(denominator < 500 | !complete.cases(.)) %>% View()

length(unique(testing.sites.acs.ready$GEOID))
# 953 - not unique by tract

# 34 tracts to exclude based on incomplete data and total denominator
# Bring the aggregates and medians to a comparable scale
testing.sites.acs.complete <- 
  testing.sites.acs.ready %>% 
  mutate(commute.time.agg  = commute.time.agg/10000
         ,income.hh.median = income.hh.median/10000
         ,rent.median      = rent.median/100
         ,home.pmt.median  = home.pmt.median/100
         ) %>%
  dplyr::rename(commute.time.agg.10k  = commute.time.agg
                ,income.hh.median.10k = income.hh.median
                ,rent.median.100      = rent.median
                ,home.pmt.median.100  = home.pmt.median) %>%
  dplyr::filter(denominator >= 500 & complete.cases(.))

summary(testing.sites.acs.complete)
length(unique(testing.sites.acs.complete$GEOID))
```

I join the census tract GEOIDs to the daily PM2.5 data, and clean and summarize the PM2.5 data by tract. Tracts with fewer than 50 days of valid data are excluded.

```{r AQS-outcomes, eval=TRUE}
summary(clean.2019.dailyPM2.5)

# Create a file of site IDs with GEOIDs that have complete ACS data.
site_id.GEOID.xwalk <- testing.sites.acs.complete %>%
                        dplyr::select(site_id,GEOID) %>%
                        unique()

GEOID.dailyPM2.5 <- inner_join( site_id.GEOID.xwalk
                               ,clean.2019.dailyPM2.5
                               ,by="site_id")

dim(GEOID.dailyPM2.5)
# 1,396,734 rows

dim(unique(GEOID.dailyPM2.5[,c("GEOID","date_local")]))
# 243,809 tract-days

table(GEOID.dailyPM2.5$event_type, useNA="always")
# Included, Excluded, None
table(GEOID.dailyPM2.5$validity_indicator, useNA="always")
table(GEOID.dailyPM2.5$validity_indicator, GEOID.dailyPM2.5$event_type, useNA="always")
# Y, N. 4282 x N
# Excluding validity_indicator == "N" does not get rid of a meaningful % of events
# GEOID.dailyPM2.5 %>% dplyr::filter(validity_indicator == "N") %>% View()

summary(GEOID.dailyPM2.5$arithmetic_mean)

# Create preliminary outcome variables
GEOID.daily.summary <-
  GEOID.dailyPM2.5 %>%
  dplyr::filter(validity_indicator=="Y") %>%
  mutate(arithmetic_mean = case_when(arithmetic_mean < 0 ~ 0, TRUE ~ arithmetic_mean)) %>%
  group_by(GEOID,date_local) %>%
  summarise(mean = mean(arithmetic_mean),.groups = "keep")

# table(GEOID.daily.summary$any_event)
summary(GEOID.daily.summary$mean)

GEOID.AQI.outcomes <-
  GEOID.daily.summary %>%
  mutate(ungreen = case_when(mean > 12.0 ~ 1L, TRUE ~ 0L)) %>%
  group_by(GEOID) %>%
  summarise( pm2.5_days         = n()
            ,pm2.5_p50          = quantile(mean, 0.50)
            ,pm2.5_ungreen_days = sum(ungreen)
            ,.groups="keep")

head(GEOID.AQI.outcomes)
summary(GEOID.AQI.outcomes)

# How many days of valid data do we have per tract?
table(GEOID.AQI.outcomes$pm2.5_days)

# Create final PM2.5 outcome variables
AQI.outcomes.final <-
  GEOID.AQI.outcomes %>%
  dplyr::filter(pm2.5_days >= 50) %>%
  mutate( pm2.5_pct_ungreen    = 100 * pm2.5_ungreen_days / pm2.5_days
         ,pm2.5_flag10_ungreen = case_when(pm2.5_ungreen_days * 10 > pm2.5_days ~ 1L, TRUE ~ 0L)
         ,pm2.5_flag20_ungreen = case_when(pm2.5_ungreen_days *  5 > pm2.5_days ~ 1L, TRUE ~ 0L)
         ) %>%
  mutate( pm2.5_flag10_ungreen = factor(pm2.5_flag10_ungreen
                                        ,levels = c(0,1)
                                        ,labels = c("0-10%",">10%"))
         ,pm2.5_flag20_ungreen = factor(pm2.5_flag20_ungreen
                                        ,levels = c(0,1)
                                        ,labels = c("0-20%",">20%"))) %>%
  dplyr::select(GEOID, pm2.5_p50, pm2.5_pct_ungreen, pm2.5_flag10_ungreen, pm2.5_flag20_ungreen)

# Review created outcome variables
head(AQI.outcomes.final)
summary(AQI.outcomes.final$pm2.5_p50)
summary(AQI.outcomes.final$pm2.5_pct_ungreen)
table(AQI.outcomes.final$pm2.5_flag10_ungreen)
table(AQI.outcomes.final$pm2.5_flag20_ungreen)
AQI.outcomes.final %>% dplyr::filter(pm2.5_flag10_ungreen==">10%") %>% summary()
AQI.outcomes.final %>% dplyr::filter(pm2.5_flag20_ungreen==">20%") %>% summary()

```

With both predictors and outcomes summarized by census tract, the ACS and AQS files can now be joined to create the final data set.
```{r final-linkage-step, eval=TRUE}

str(AQI.outcomes.final)
str(testing.sites.acs.complete)

# Drop unnecessary geographic variables from the ACS file
acs.joinready <- 
  testing.sites.acs.complete %>%
  dplyr::select(-site_id, -STATEFP, -COUNTYFP) %>%
  unique()

dim(acs.joinready)
length(unique(acs.joinready$GEOID))
# 920 rows, unique on GEOID

# Join PM2.5 and ACS data by tract on GEOID
AQI.ACS <- inner_join(AQI.outcomes.final,acs.joinready,by="GEOID")
head(AQI.ACS)

# Prepare the geography/geometry file for linkage
str(testing.sites.tracts)
geom.joinready <-
  testing.sites.tracts %>%
  dplyr::select(GEOID,NAMELSAD,STATEFP,state,COUNTYFP,county,city,cbsa,cbsa_code,geometry) %>%
  unique()
dim(geom.joinready)
length(unique(geom.joinready$GEOID))
geom.joinready %>% group_by(GEOID) %>% summarise(obs=n()) %>% arrange(-obs) %>% head()
geom.joinready %>% dplyr::filter(GEOID=="06079012304")

# Hard-code one value to be able to keep city attribute unique by GEOID
geom.joinready2 <- 
  geom.joinready %>%
  mutate(city = case_when(GEOID=="06079012304" ~ "Arroyo Grande", TRUE ~ city)) %>%
  unique()

dim(geom.joinready2)
length(unique(geom.joinready2$GEOID))
head(geom.joinready2)

# Join geography/geometry file with AQS outcomes and ACS variables
AQI.ACS.geom <- inner_join(geom.joinready2,AQI.ACS,by="GEOID") %>% group_by()
head(AQI.ACS.geom)
class(AQI.ACS.geom)
```


### Results
*Describe your results and include relevant tables, plots, and code/comments used to obtain them. End with a brief conclusion of your findings related to the question you set out to address. You can include references if you'd like, but this is not required.*

XXXXXXXXXXXXXXXXXPerform bivariate tests of community characteristics vs air quality (continous measures and 1/0 for poor air quality above threshold). Create multivariate models to predict air quality from community characteristics. Construct a classifier using community characteristics and evaluate its performance against the real data. XXXXXXXXXXXXXXXXX




Continuous PM2.5 outcomes by tract, mapped: 
```{r leaflet, eval=TRUE}

AQI.ACS.geom.WGS84 <- st_transform(AQI.ACS.geom, 4326) # FROM 4269 TO 4326 to cooperate with leaflet

palette <- colorNumeric("viridis", NULL, reverse=TRUE)

# Median PM2.5 by tract - interactive
popup_msg <- paste0(AQI.ACS.geom.WGS84$county," County, ",AQI.ACS.geom.WGS84$state,", ",AQI.ACS.geom.WGS84$NAMELSAD
                   ,"<br>Metro Area: ",AQI.ACS.geom.WGS84$cbsa
                   ,"<br>Median PM2.5: ",round(AQI.ACS.geom.WGS84$pm2.5_p50,digits=2))

leaflet(AQI.ACS.geom.WGS84) %>%
  addPolygons(fillColor = ~palette(pm2.5_p50)
              ,fillOpacity = 0.9
              ,weight = 1.5
              ,color = "black"
              ,popup = popup_msg) %>%      
  addTiles() %>%
  addLegend("bottomright",         
            pal=palette,      
            values=~pm2.5_p50,   
            title = 'PM2.5',  
            opacity = 1) %>%    
  addScaleBar()

# % of days above 12 mcg/m3 by tract - interactive
popup_msg2 <- paste0(AQI.ACS.geom.WGS84$county," County, ",AQI.ACS.geom.WGS84$state,", ",AQI.ACS.geom.WGS84$NAMELSAD
                   ,"<br>Metro Area: ",AQI.ACS.geom.WGS84$cbsa
                   ,"<br>Reached 12mcg/m3 on ",round(AQI.ACS.geom.WGS84$pm2.5_pct_ungreen,digits=1),"% of days")

leaflet(AQI.ACS.geom.WGS84) %>%
  addPolygons(fillColor = ~palette(pm2.5_pct_ungreen)
              ,fillOpacity = 0.9
              ,weight = 1.5
              ,color = "black"
              ,popup = popup_msg2) %>%      
  addTiles() %>%
  addLegend("bottomright",         
            pal=palette,      
            values=~pm2.5_pct_ungreen,   
            title = '% days of 12+ mcg/m3 PM2.5',  
            opacity = 1) %>%    
  addScaleBar()
```


Regression results, using all 19 ACS-based predictor variables: 
```{r regression, eval=TRUE}
# Run linear regression for continuous outcomes
lm.p50 <- lm(pm2.5_p50 ~ 
               age.median + commute.time.agg.10k + income.hh.median.10k + rent.median.100 
             + home.pmt.median.100 + race.black.any + ethn.nhisp.white.alone + married + kids 
             + bachelor.plus + veteran + manufacturing + farm.fish.mining + commutes.car.alone 
             + renter + single.fam.home + worked.12mo + poverty.12mo + snap.12mo
             ,data = AQI.ACS.geom)

lm.pct.ungreen <- lm(pm2.5_pct_ungreen ~ 
               age.median + commute.time.agg.10k + income.hh.median.10k + rent.median.100 
             + home.pmt.median.100 + race.black.any + ethn.nhisp.white.alone + married + kids 
             + bachelor.plus + veteran + manufacturing + farm.fish.mining + commutes.car.alone 
             + renter + single.fam.home + worked.12mo + poverty.12mo + snap.12mo
             ,data = AQI.ACS.geom)

# Run logistic regression for binary outcomes
logit.flag10.ungreen <- glm(pm2.5_flag10_ungreen ~ 
               age.median + commute.time.agg.10k + income.hh.median.10k + rent.median.100 
             + home.pmt.median.100 + race.black.any + ethn.nhisp.white.alone + married + kids 
             + bachelor.plus + veteran + manufacturing + farm.fish.mining + commutes.car.alone 
             + renter + single.fam.home + worked.12mo + poverty.12mo + snap.12mo
             ,data = AQI.ACS.geom
             ,family = binomial())

logit.flag20.ungreen <- glm(pm2.5_flag20_ungreen ~ 
               age.median + commute.time.agg.10k + income.hh.median.10k + rent.median.100 
             + home.pmt.median.100 + race.black.any + ethn.nhisp.white.alone + married + kids 
             + bachelor.plus + veteran + manufacturing + farm.fish.mining + commutes.car.alone 
             + renter + single.fam.home + worked.12mo + poverty.12mo + snap.12mo
             ,data = AQI.ACS.geom
             ,family = binomial())

# Extract p-values by predictor variable from regression results into a summary data frame.
lm.p50.pval.df <- data.frame(acs.var = names(summary(lm.p50)$coefficients[-1,4])
                             ,lm.p50.pval  = summary(lm.p50)$coefficients[-1,4])

lm.pct.ungreen.pval.df <- data.frame(acs.var = names(summary(lm.pct.ungreen)$coefficients[-1,4])
                                    ,lm.pct.ungreen.pval   = summary(lm.pct.ungreen)$coefficients[-1,4])

logit.flag10.ungreen.pval.df <- data.frame(acs.var = names(summary(logit.flag10.ungreen)$coefficients[-1,4])
                                    ,logit.flag10.ungreen.pval = summary(logit.flag10.ungreen)$coefficients[-1,4])

logit.flag20.ungreen.pval.df <- data.frame(acs.var = names(summary(logit.flag20.ungreen)$coefficients[-1,4])
                                    ,logit.flag20.ungreen.pval = summary(logit.flag20.ungreen)$coefficients[-1,4])

# Join p-value data frames together by ACS-based variable name. 
# Sort ascending by p-value for median PM2.5 regression
pval1 <- inner_join(lm.p50.pval.df,lm.pct.ungreen.pval.df, by="acs.var")
pval2 <- inner_join(pval1,logit.flag10.ungreen.pval.df, by="acs.var")
pval3 <- inner_join(pval2,logit.flag20.ungreen.pval.df, by="acs.var") %>% arrange(lm.p50.pval)

# Return results
summary.lm(lm.p50)
summary(lm.pct.ungreen)
summary(logit.flag10.ungreen)
summary(logit.flag20.ungreen)
pval3
```


Bivariate plots for most strongly-associated predictor variables with median PM2.5 and 10%-of-days outcomes:
```{r assoc-plots, eval=TRUE}
# worked.12mo
ggplot(data = AQI.ACS.geom, aes(x = worked.12mo, y = pm2.5_p50)) + 
  geom_point() + geom_smooth(color = "red", method = "lm") + 
  xlab("% Worked in Past 12 Months") +
  ylab("Median Daily PM2.5 Concentration (mcg/m3)")

ggplot(data = AQI.ACS.geom, aes(x = pm2.5_flag10_ungreen, y = worked.12mo)) +
  geom_violin(fill = "steelblue1", draw_quantiles = c(0.25, 0.5, 0.75)) + 
  xlab("% of Days with PM2.5 >= 12mcg/m3") + 
  ylab("% Worked in Past 12 Months") 

# manufacturing
ggplot(data = AQI.ACS.geom, aes(x = manufacturing, y = pm2.5_p50)) + 
  geom_point() + geom_smooth(color = "red", method = "lm") + 
  xlab("% of Workers in Manufacturing Industry") +
  ylab("Median Daily PM2.5 Concentration (mcg/m3)")

ggplot(data = AQI.ACS.geom, aes(x = pm2.5_flag10_ungreen, y = manufacturing)) +
  geom_violin(fill = "steelblue1", draw_quantiles = c(0.25, 0.5, 0.75)) + 
  xlab("% of Days with PM2.5 >= 12mcg/m3") + 
  ylab("% of Workers in Manufacturing Industry") 

# farm.fish.mining
ggplot(data = AQI.ACS.geom, aes(x = farm.fish.mining, y = pm2.5_p50)) + 
  geom_point() + geom_smooth(color = "red", method = "lm") + 
  xlab("% of Workers in Agriculture, Forestry,\nFishing & Hunting, and Mining Industry Category") +
  ylab("Median Daily PM2.5 Concentration (mcg/m3)")

ggplot(data = AQI.ACS.geom, aes(x = pm2.5_flag10_ungreen, y = farm.fish.mining)) +
  geom_violin(fill = "steelblue1", draw_quantiles = c(0.25, 0.5, 0.75)) + 
  xlab("% of Days with PM2.5 >= 12mcg/m3") + 
  ylab("% of Workers in Agriculture, Forestry,\nFishing & Hunting, and Mining Industry Category")

# ethn.nhisp.white.alone
ggplot(data = AQI.ACS.geom, aes(x = ethn.nhisp.white.alone, y = pm2.5_p50)) + 
  geom_point() + geom_smooth(color = "red", method = "lm") + 
  xlab("% of Respondents Reporting\nNon-Hispanic Ethnicity and White Race Only") +
  ylab("Median Daily PM2.5 Concentration (mcg/m3)")

ggplot(data = AQI.ACS.geom, aes(x = pm2.5_flag10_ungreen, y = ethn.nhisp.white.alone)) +
  geom_violin(fill = "steelblue1", draw_quantiles = c(0.25, 0.5, 0.75)) + 
  xlab("% of Days with PM2.5 >= 12mcg/m3") + 
  ylab("% of Respondents Reporting\nNon-Hispanic Ethnicity and White Race Only")

# race.black.any
ggplot(data = AQI.ACS.geom, aes(x = race.black.any, y = pm2.5_p50)) + 
  geom_point() + geom_smooth(color = "red", method = "lm") + 
  xlab("% of Respondents Reporting Black Race\n(with or without other categories)") +
  ylab("Median Daily PM2.5 Concentration (mcg/m3)")

ggplot(data = AQI.ACS.geom, aes(x = pm2.5_flag10_ungreen, y = race.black.any)) +
  geom_violin(fill = "steelblue1", draw_quantiles = c(0.25, 0.5, 0.75)) + 
  xlab("% of Days with PM2.5 >= 12mcg/m3") + 
  ylab("% of Respondents Reporting Black Race\n(with or without other categories)")

```



```{r crossvalidation, eval=TRUE}

dim(AQI.ACS)
set.seed(1504492)
kgroup <- data.frame(kgroup = sample(1:5, size = dim(AQI.ACS)[1], replace = T))
AQI.ACS.onlynec <- bind_cols(AQI.ACS,data.frame(kgroup = sample(1:5, size = dim(AQI.ACS)[1], replace = T))) %>% 
                    select(-pm2.5_p50, -pm2.5_pct_ungreen, -pm2.5_flag20_ungreen, -denominator) %>%
                    group_by()

for (i in 1:5) {

	train <- filter(AQI.ACS.onlynec, kgroup != i)
	test  <- filter(AQI.ACS.onlynec, kgroup == i)
    
  # GLM: All variables
	glm <- train %>% glm(pm2.5_flag10_ungreen ~ 
               age.median + commute.time.agg.10k + income.hh.median.10k + rent.median.100 
             + home.pmt.median.100 + race.black.any + ethn.nhisp.white.alone + married + kids 
             + bachelor.plus + veteran + manufacturing + farm.fish.mining + commutes.car.alone 
             + renter + single.fam.home + worked.12mo + poverty.12mo + snap.12mo
             , data = .
             , family = binomial())
	
	glm.predict <- bind_cols(test[,"GEOID"], data.frame(glmpred = predict(glm, test, type = "response")))
	
  # GLM: Selected variables
	select.glm <- train %>% glm(pm2.5_flag10_ungreen ~ 
               age.median + race.black.any + ethn.nhisp.white.alone + veteran 
               + manufacturing + farm.fish.mining + worked.12mo + commutes.car.alone
             , data = .
             , family = binomial())
	
	select.predict <- bind_cols(test[,"GEOID"], data.frame(selectpred = predict(select.glm, test, type = "response")))
	
	# Random forest
	rf <- train %>% randomForest(pm2.5_flag10_ungreen ~ 
               age.median + commute.time.agg.10k + income.hh.median.10k + rent.median.100 
             + home.pmt.median.100 + race.black.any + ethn.nhisp.white.alone + married + kids 
             + bachelor.plus + veteran + manufacturing + farm.fish.mining + commutes.car.alone 
             + renter + single.fam.home + worked.12mo + poverty.12mo + snap.12mo
             , data = .
             , ntree = 2000)
	
	rf.predict <- bind_cols(test[,"GEOID"], data.frame(rfpred = predict(rf, test, type = "prob")[,2]))
	
	# Support vector machines with radial kernel
	svm <- train %>% svm(pm2.5_flag10_ungreen ~ 
               age.median + commute.time.agg.10k + income.hh.median.10k + rent.median.100 
             + home.pmt.median.100 + race.black.any + ethn.nhisp.white.alone + married + kids 
             + bachelor.plus + veteran + manufacturing + farm.fish.mining + commutes.car.alone 
             + renter + single.fam.home + worked.12mo + poverty.12mo + snap.12mo
             , data = .
             , scale = TRUE
             , kernel = "radial"
             , probability = TRUE)
	
	svm.step1 <- predict(svm, test, probability = TRUE)

	svm.predict <- bind_cols(test[,"GEOID"], data.frame(svmpred = attr(svm.step1, "probabilities")[,2]))

	# Join the predictions together by GEOID
	two.predict   <- inner_join(glm.predict, rf.predict, by="GEOID")
	three.predict <- inner_join(two.predict, select.predict, by="GEOID")
	four.predict  <- inner_join(three.predict, svm.predict, by="GEOID")
		
	if (i==1){
	  collect.predict <- four.predict
	} else {
	  collect.predict <- bind_rows(collect.predict, four.predict)
	}
}

AQI.ACS.preds <- inner_join(AQI.ACS.onlynec, collect.predict, by = "GEOID")

library(pROC)
AQI.ACS.preds %>% roc(pm2.5_flag10_ungreen, rfpred, ci=TRUE)
AQI.ACS.preds %>% roc(pm2.5_flag10_ungreen, glmpred, ci=TRUE)
AQI.ACS.preds %>% roc(pm2.5_flag10_ungreen, selectpred, ci=TRUE)
AQI.ACS.preds %>% roc(pm2.5_flag10_ungreen, svmpred, ci=TRUE)

plot.roc(AQI.ACS.preds$pm2.5_flag10_ungreen, AQI.ACS.preds$svmpred, col="yellow")
plot.roc(AQI.ACS.preds$pm2.5_flag10_ungreen, AQI.ACS.preds$rfpred, col="darkgreen", add=TRUE)
plot.roc(AQI.ACS.preds$pm2.5_flag10_ungreen, AQI.ACS.preds$glmpred, col="blue", add=TRUE)
plot.roc(AQI.ACS.preds$pm2.5_flag10_ungreen, AQI.ACS.preds$selectpred, col="orange", add=TRUE)
legend("bottomright"
       ,legend = c("SVM (Radial)","Random Forest", "Logistic: All Vars", "Logistic: Select Vars")
       ,col = c("yellow","darkgreen", "blue", "orange")
       ,lwd = 1)

```

```{r adfkgjnadfg, eval=FALSE}
head(AQI.ACS.preds)


#SVM
roc(obs.outputs, pred.outputs.svm, ci = TRUE)
plot.roc(titanic$survived, svm.pred.lived)
plot.roc(obs.outputs, pred.outputs.svm, ci = TRUE, col = "blue", add = TRUE)
legend("bottomright", legend = c("Training", "Cross-Validation"), col = c("black", "blue"), lwd = 1)

#Random Forest
roc(obs.outputs, pred.outputs.rf, ci = TRUE)
plot.roc(titanic$survived, rf.pred.lived)
plot.roc(obs.outputs, pred.outputs.rf, ci = TRUE, col = "darkgreen", add = TRUE)
legend("bottomright", legend = c("Training", "Cross-Validation"), col = c("black", "darkgreen"), lwd = 1)

#Lasso
roc(obs.outputs, pred.outputs.lasso, ci = TRUE)
plot.roc(titanic$survived, titanic.lasso.pred[ ,1])
plot.roc(obs.outputs, pred.outputs.lasso, ci = TRUE, col = "red", add = TRUE)
legend("bottomright", legend = c("Training", "Cross-Validation"), col = c("black", "red"), lwd = 1)

#Plot both cross-validation ROCs
plot.roc(obs.outputs, pred.outputs.svm, ci = TRUE, col = "blue") #CV of svm
plot.roc(obs.outputs, pred.outputs.rf, ci = TRUE, col = "darkgreen", add = TRUE) #CV of rf
plot.roc(obs.outputs, pred.outputs.lasso, ci = TRUE, col = "red", add = TRUE) #CV of lasso
legend("bottomright", legend = c("SVM Cross-Validation", "RF Cross-Validation", "Lasso Cross-Validation"), col = c("blue", "darkgreen", "red"), lwd = 2)



table(AQI.ACS.preds$glmpred,AQI.ACS.preds$pm2.5_flag10_ungreen)


  pred.status.glm[1:length(s[s == i]) + offset] <- glm.pred.test
  
  # Random forest
	rf <- train %>% select(-status) %>% randomForest(statusfactor ~ ., data = ., ntree = 100)
	rf.pred.test <- predict(rf, newdata = test, type = "prob") 
	pred.status.rf[1:length(s[s == i]) + offset] <- rf.pred.test[ , 2]
  
	offset <- offset + length(s[s == i])
}



rf.flag10.ungreen <- randomForest(pm2.5_flag10_ungreen ~ 
               age.median + commute.time.agg.10k + income.hh.median.10k + rent.median.100 
             + home.pmt.median.100 + race.black.any + ethn.nhisp.white.alone + married + kids 
             + bachelor.plus + veteran + manufacturing + farm.fish.mining + commutes.car.alone 
             + renter + single.fam.home + worked.12mo + poverty.12mo + snap.12mo
             ,data = AQI.ACS.geom
             ,ntree = 2000
             ,importance = TRUE)

rf.flag10.ungreen
rf.flag10.ungreen$importance[,c("MeanDecreaseGini")] %>% sort(decreasing = TRUE)


rf.flag20.ungreen <- randomForest(pm2.5_flag20_ungreen ~ 
               age.median + commute.time.agg.10k + income.hh.median.10k + rent.median.100 
             + home.pmt.median.100 + race.black.any + ethn.nhisp.white.alone + married + kids 
             + bachelor.plus + veteran + manufacturing + farm.fish.mining + commutes.car.alone 
             + renter + single.fam.home + worked.12mo + poverty.12mo + snap.12mo
             ,data = AQI.ACS.geom
             ,ntree = 2000
             ,importance = TRUE)

rf.flag20.ungreen
rf.flag20.ungreen$importance[,c("MeanDecreaseGini")] %>% sort(decreasing = TRUE)


AQI.ACS.svm <- svm(pm2.5_flag10_ungreen ~ 
               age.median + commute.time.agg.10k + income.hh.median.10k + rent.median.100 
             + home.pmt.median.100 + race.black.any + ethn.nhisp.white.alone + married + kids 
             + bachelor.plus + veteran + manufacturing + farm.fish.mining + commutes.car.alone 
             + renter + single.fam.home + worked.12mo + poverty.12mo + snap.12mo
             , data = AQI.ACS.geom
             , scale = TRUE
             # , kernel = "linear"
             , kernel = "radial")

# Linear kernel:
#         0-10% >10%
#   0-10%   192  180
#   >10%    111  426

# Radial kernel: Better! 
#         0-10% >10%
#   0-10%   193  179
#   >10%     46  491

plot(worked.12mo ~ ethn.nhisp.white.alone, data=AQI.ACS.svm, col = pm2.5_flag10_ungreen)

summary(AQI.ACS.svm)
svm.flag10pred <- fitted(AQI.ACS.svm)
table(AQI.ACS.geom$pm2.5_flag10_ungreen, svm.flag10pred)

?plot.svm
length(svm.flag10pred)
length(AQI.ACS.geom$pm2.5_flag10_ungreen)

?e1071::plot
plot(svm.flag10pred, AQI.ACS.geom[,c("pm2.5_flag10_ungreen","worked.12mo","ethn.nhisp.white.alone")], worked.12mo ~ ethn.nhisp.white.alone) 




?svm


```







```{r junk-just-in-case, eval=FALSE, echo=FALSE}

#################################################
# Scraps from previous attempts I'm keeping in case I need them later...
#################################################

table(all.2019.dailyPM2.5$units_of_measure, useNA = TRUE)
# All Micrograms/cubic meter (LC) 

table(round(all.2019.dailyPM2.5$sample_measurement))

# Plot distribution of time-of-day-of-measurement by testing site, 
# to determine whether an overall plot of measurement x time of day will be representative



# Try getting 1 month of state-level daily summary data - Jan 2017, Pennsylvania

# 88101	: PM2.5 - Local Conditions

dSum.PA201701.PM2.5Local <- get.AQS.data(
    "/data/api/dailyData/byState?email=api.email&key=api.key&param=88101&bdate=20170101&edate=20170131&state=42"
)

head(dSum.PA201701.PM2.5Local)
table(dSum.PA201701.PM2.5Local$county_code)
summary(dSum.PA201701.PM2.5Local)
View(dSum.PA201701.PM2.5Local)

table(dSum.PA201701.PM2.5Local$local_site_name,useNA="ifany") 
# 1,445 NA
dSum.PA201701.PM2.5Local %>% filter(is.na(local_site_name)) %>% View()

dSum.PA201701.PM2.5Local %>% 
  group_by(county_code,site_number,cbsa_code,site_address,local_site_name) %>% 
  summarise(count=n(), .groups="keep")

length(unique(dSum.PA201701.PM2.5Local$local_site_name))
# 38 unique sites

table(dSum.PA201701.PM2.5Local$observation_count)
# Ranges from 1 to 24
table(dSum.PA201701.PM2.5Local$units_of_measure) 
# Micrograms/cubic meter (LC) for all




dSum.PA201701.PM2.5Local %>% filter(observation_count > 20) %>% View()


# Site_number is not unique. Is county (or county_code) x site_number unique? 
PA.testing.sites %>% 
  select(county, site_number) %>%
  unique() %>%
  dim()

# Yes. Create county (1st 4 letters) + site_number to have something unique and also sort of readable.

PA.testing.sites <- PA.testing.sites %>%
                      mutate(site_cty = paste0(substring(toupper(county),1,4),site_number))

table(PA.testing.sites$site_cty)
length(unique(PA.testing.sites$site_cty))

# Apply to full data set

all.2019.dailyPM2.5 <- all.2019.dailyPM2.5 %>%
                  mutate(site_cty = paste0(substring(toupper(county),1,4),site_number))

table(all.2019.dailyPM2.5$site_cty)

# What do the counts look like by site?

PA.site.counts <- all.2019.dailyPM2.5 %>%
                    group_by(site_cty) %>%
                    summarize(obs = n(), .groups = "keep") %>%
                    arrange(-obs)

head(PA.site.counts)

PA.site.counts %>% filter(obs > 10000)
# WASH0005	17885			
# CAMB0011	17520	

# Look more closely - should these actually be 2 sites (with the same long/lat?)?
all.2019.dailyPM2.5 %>% filter(site_cty == "WASH0005") %>% View()

table(all.2019.dailyPM2.5$method_code,all.2019.dailyPM2.5$site_cty)
# Some sites use different methods at different points in the year
# The 2 highest-count sites appear to use 2 methods simultaneously throughout the year
# One method appears seems likely to be a daily measurement which should be ignored 
# in considering trends by time of day

ggplot(data = all.2019.dailyPM2.5, aes(x = factor(substring(time_local,1,2)), fill = factor(method_code))) + 
    geom_bar(position = "stack")

# Yes. Ignore method_code = "145" for considering time-of-day. Also ignore time_local = "00:14"

all.2019.dailyPM2.5 %>%
  filter(method_code != "145" & time_local != "00:14") %>%
  ggplot(data = ., aes(x = site_cty, fill = factor(substring(time_local,1,2)))) + 
    geom_bar(position = "stack")

# Also drop sites that have less than approx 1 measurement/hour for the year (365 x 24 = 8760)
PA.site.counts %>% filter(obs < 8000)
# LYCO0419	3840			
# WYOM0010	672			
# ALLE0067	121			
# ALLE1008	121			
# ALLE1301	121			
# ALLE0093	61			
# ALLE3007	61	

all.2019.dailyPM2.5 %>%
  filter(method_code != "145" & time_local != "00:14" & !(site_cty %in% c("LYCO0419","WYOM0010"))) %>%
  ggplot(data = ., aes(x = site_cty, fill = factor(substring(time_local,1,2)))) + 
    geom_bar(position = "stack")

# Now, ready to make violin plots for sample_measurement by time_local

# #########################################
# NEED TO REMOVE NA MEASUREMENT VALUES!!!
# #########################################

all.2019.dailyPM2.5 %>% filter(is.na(sample_measurement) == TRUE) %>% View()
# Consider the `qualifier` field - seems to explain why no measurement was collected 

# table(all.2019.dailyPM2.5$qualifier,useNA = "always")
# all.2019.dailyPM2.5 %>% select(qualifier) %>% unique() %>% arrange(qualifier)

PA.qualifier.counts <- all.2019.dailyPM2.5 %>% 
                        mutate(any_measure = !is.na(sample_measurement)) %>%
                        group_by(any_measure,qualifier) %>% 
                        summarize(obs = n(), .groups = "keep") %>% 
                        arrange(-any_measure, -obs)

PA.qualifier.counts

all.2019.dailyPM2.5 %>% filter(!is.na(qualifier) & !is.na(sample_measurement)) %>% View()
# Not many in total and most are type 145 anyway

all.2019.dailyPM2.5 %>% filter(!is.na(qualifier) & !is.na(sample_measurement) & method_code != "145") %>% View()
# 5 records, all flagged as "Outlier" - no need to exclude here

all.2019.dailyPM2.5 %>%
  filter(method_code != "145" & time_local != "00:14" & !(site_cty %in% c("LYCO0419","WYOM0010"))) %>%
  select(sample_measurement) %>%
  summary()


table(round(all.2019.dailyPM2.5$sample_measurement))

# 75th pct 11.0 but max 217.9 !! 
# And negative concentrations are impossible; code to 0

all.2019.dailyPM2.5 %>%
  filter(method_code != "145" & time_local != "00:14" & !(site_cty %in% c("LYCO0419","WYOM0010")) & sample_measurement < 0) %>% 
  View()

all.2019.dailyPM2.5 %>%
  filter(method_code != "145" & time_local != "00:14" & !(site_cty %in% c("LYCO0419","WYOM0010")) & sample_measurement >= 100) %>% 
  View()

clean.all.2019.dailyPM2.5 <- all.2019.dailyPM2.5 %>%
                        filter(method_code != "145" 
                               & time_local != "00:14" 
                               & !(site_cty %in% c("LYCO0419","WYOM0010"))
                               & !is.na(sample_measurement)) %>%
                        mutate(sample_measurement = case_when(sample_measurement < 0 ~ 0, TRUE ~ sample_measurement))

dim(clean.all.2019.dailyPM2.5)
table(round(clean.all.2019.dailyPM2.5$sample_measurement),useNA = "always")

ggplot(data = clean.all.2019.dailyPM2.5, aes(x = site_cty, fill = factor(substring(time_local,1,2)))) + 
    geom_bar(position = "stack")

ggplot(data = clean.all.2019.dailyPM2.5, aes(x = factor(substring(time_local,1,2)), y = sample_measurement)) + 
    geom_violin(fill = "lightblue", draw_quantiles = c(0.10,0.30, 0.50, 0.70, 0.90)) +
    ylim(c(0,25))

# There is some fluctuation by time of day -- 
# But, all of the site left in have ~hourly readings throughout the year. 
# So it would still be reasonable to compute annual percentiles and means by site 
# for an overall sense of typical particulate conditions by geography. 

clean.PA.site.summary <- clean.all.2019.dailyPM2.5 %>%
                          group_by(site_cty,county,county_code,site_number,latitude,longitude) %>%
                          summarise(pm2.5_mean = mean(sample_measurement),
                                    pm2.5_p10 = quantile(sample_measurement, 0.10), 
                                    pm2.5_p25 = quantile(sample_measurement, 0.25), 
                                    pm2.5_p50 = quantile(sample_measurement, 0.50), 
                                    pm2.5_p75 = quantile(sample_measurement, 0.75), 
                                    pm2.5_p90 = quantile(sample_measurement, 0.90), 
                                    .groups = "keep") %>%
                          arrange(-pm2.5_p50)

View(clean.PA.site.summary)
summary(clean.PA.site.summary$longitude)
summary(clean.PA.site.summary$latitude)

# more to come
```

Retrieve a range of census descriptive data by census tract. 
Join with air quality summary data.

```{r explore-linked-data, eval=FALSE}

# still to come 

```




```{r actual-data-science, eval=FALSE}

# still to come

```




