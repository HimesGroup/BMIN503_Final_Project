---
title: "Evaluation of clinical notes, pathology reports, and institutional cancer registry for automated abstraction of Gleason score in prostate cancer patients"
author: "Anh Le"
date: "11/2/2019"
output: html_document: 
    toc: false 
    depth: 3 
    theme: paper 
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
***
## Evaluation of clinical notes, pathology reports, and institutional cancer registry for automated abstraction of Gleason score in prostate cancer patients

### Overview

The primary objective of this study is to evaluate data structures including physician progress note, pathology report, and the institutional cancer registry for abstraction of Gleason score in prostate cancer patients. On a deeper level, the utility of data abstraction methods including natural language processing and use of legally-binding and abstractor-curated database is also being investigated.

#### Introduction 

Prostate cancer (PCa) is the most common cancer in American men where it is the second leading cause of cancer-related deaths. Recent studies suggest that up to 20% of metastatic PCa have germline mutations in DNA repair genes, which are associated with more aggressive disease and worse survival outcomes.There are various guidelines for germline mutation screenings for PCa patients, mostly in the metastatic population. However, there is a paucity of data on the incidence and role of inherited DNA repair mutations in localized PCa and the relationship between these mutations and Gleason score. Genotype-phenotype analysis are pertinent to determine the rate of germline DNA repair mutations in patients with localized PCa stratified by Gleason score.
To address this problem, a multidisciplinary approach involing cancer genetics and informatics for clinical phenotyping and genotyping is imperative. This project can be broken down to two parallel arms: phenotyping and genotyping. In the phenotyping arm, we aim to develop a rule-based data extraction algorithm to perform large-scale deep phenotyping of prostate patients in the Penn Medicine BioBank (PMBB) for Gleason Score. To abstract a Gleason Score that is most clinically relevant, it is important to incorporate clinical expertise in urologic medical oncology, pathology, and surgery to formulate a “ground truth” for Gleason Score abstraction. In the genotyping arm, targeted gene and RNA sequencing are performed for this cohort. However, this project is focused on the phenotyping effort. 

##### Methods

A deep Phenotyping Rule-Based Algorithm is developed by team of physicians with expertise in urologic
medical oncology, pathology, and surgery based on clinical practice principles and the Data Analytics Center using PennSeek. 
Cohort identification is conducted by rapid phenotyping of the Penn Medicine Biobank using ICD9 code of “185 Malignant neoplasm of prostate” and ICD10 code of “C61 Malignant neoplasm of prostate”.
Gleason Score is extracted from three data structures: (1) Pathology Reports,(2) Oncology Encounter Notes, and (3) Penn Medicine Cancer Registry.
Gleason Score selection criteria prioritize Gleason score reported on prostatectomy pathology
report. If there is no prostatectomy available, the highest score reported on all available biopsy reports regardless of temporal order.NLP is performed by DAC using PennSeek. PennSeek queries data pulled from PDS/ EPIC Clarity. Manual chart review is performed to create a gold standard set of Gleason Score data. Evaluation of data performance stratified by data structure 

###### Results 
Descriptive data 
# Demographic distribution (race, ethnicity, Ashkenazi Jewish descent, vital status)
```{r}
data <-read.csv("/Users/leanhn/Desktop/BMIN503FinalData_Le.csv", stringsAsFactors = FALSE)
str(data)


```

# Breakdown of clinical stage at diagnosis and biochemical recurrence
```{r}
install.packages("MASS")
install.packages("dplyr")
library (MASS)
library (dplyr)
data <- data %>%
  mutate(Race = factor(Race, levels = c(1, 2, 3, 4, 5), labels = c ("Caucasian", "African American","Asian", "Multiple races", "Other" ))) %>%
  
ggplot(birthwt.clean, aes(x = smoke, y = bwt)) +
    geom_boxplot()
```
# Age at diagnosis 
```{r}
median(data$Age.of.Dgx, na.rm = TRUE)
mean(data$Age.of.Dgx, na.rm = TRUE)
sd(data$Age.of.Dgx, na.rm = TRUE)
data %>%
  group_by(Race) %>%
  summarise(AgeofDgx = mean(Age.of.Dgx, na.rm=TRUE))
```
# Gleason score data distribution across data sources (just a sum of whether or not there was data found in each source + a Venn diagram)
```{r}
install.packages(VennDiagram)
library (VennDiagram)
VENN.LIST <- source
venn.plot <- venn.diagram(VENN.LIST , NULL, fill=c("darkmagenta", "darkblue"), alpha=c(0.5,0.5), cex = 2, cat.fontface=4, category.names=c("A", "B"))
grid.draw(venn.plot)
```

# Evaluation of data structure performance:[insert code to calculate positive prediction value, sensitivity, and F-score].

```{r}
# Clean data
w = which(data$Chart.review.final == "")
data$Chart.review.final[w] = "not available"
w = which(data$Chart.review.final == "3 + 4 = 7, tert 5")
data$Chart.review.final[w] = "3 + 4 = 7"
w = which(data$Chart.review.final == "4 + 3 = 7, tert 5")
data$Chart.review.final[w] = "4 + 3 = 7"

enc_cont = c()
path_cont = c()
orqid_cont = c()
# Precision
for(i in 1:nrow(data)){
  gs = data$Chart.review.final[i]
  enc = data$ENC[i]
  path = data$PATH[i]
  orqid = data$ORQID[i]
  # True Negative
  if(gs == "not available" & enc == ""){
    enc_cont = c(enc_cont, "TN")
  }
  if(gs == "not available" & path == ""){
    path_cont = c(path_cont, "TN")
  }
  if(gs == "not available" & orqid == ""){
    orqid_cont = c(orqid_cont, "TN")
  }
  # True Positive
  if(gs != "not available" & gs == enc){
    enc_cont = c(enc_cont, "TP")
  }
  if(gs != "not available" & gs == path){
    path_cont = c(path_cont, "TP")
  }
  if(gs != "not available" & gs == orqid){
    orqid_cont = c(orqid_cont, "TP")
  }
  # False Negative
  if(gs != "not available" & enc == ""){
    enc_cont = c(enc_cont, "FN")
  }
  if(gs != "not available" & path == ""){
    path_cont = c(path_cont, "FN")
  }
  if(gs != "not available" & orqid == ""){
    orqid_cont = c(orqid_cont, "FN")
  }
  # False Positive
  if( (gs == "not available" & enc != "") | (gs != "not available" & enc != "" & gs != enc)){
    enc_cont = c(enc_cont, "FP")
  }
  if( (gs == "not available" & path != "") | (gs != "not available" & path != "" & gs != path) ){
    path_cont = c(path_cont, "FP")
  }
  if( (gs == "not available" & orqid != "") | (gs != "not available" & orqid != "" & gs != orqid) ){
    orqid_cont = c(orqid_cont, "FP")
  }
}

# Precision = TP / (TP + FP)
enc_precision = table(enc_cont)["TP"] / (table(enc_cont)["TP"] + table(enc_cont)["FP"])
path_precision = table(path_cont)["TP"] / (table(path_cont)["TP"] + table(path_cont)["FP"])
orqid_precision = table(orqid_cont)["TP"] / (table(orqid_cont)["TP"] + table(orqid_cont)["FP"])

# Recall = TP / (TP + FN)
enc_recall = table(enc_cont)["TP"] / (table(enc_cont)["TP"] + table(enc_cont)["FN"])
path_recall = table(path_cont)["TP"] / (table(path_cont)["TP"] + table(path_cont)["FN"])
orqid_recall = table(orqid_cont)["TP"] / (table(orqid_cont)["TP"] + table(orqid_cont)["FN"])

# F Score = 2*(Precision * Recall) / (Precision + Recall)
enc_f = 2*(enc_precision * enc_recall) / (enc_precision + enc_recall)
path_f = 2*(path_precision * path_recall) / (path_precision + path_recall)
orqid_f = 2*(orqid_precision * orqid_recall) / (orqid_precision + orqid_recall)

# Print
print(paste0("Encounter Precision = ", as.character(enc_precision)))
print(paste0("Encounter Recall = ", as.character(enc_recall)))
print(paste0("Encounter F Score = ", as.character(enc_f)))

print(paste0("Pathology Precision = ", as.character(path_precision)))
print(paste0("Pathology Recall = ", as.character(path_recall)))
print(paste0("Pathology F Score = ", as.character(path_f)))

print(paste0("ORQID Precision = ", as.character(orqid_precision)))
print(paste0("ORQID Recall = ", as.character(orqid_recall)))
print(paste0("ORQID F Score = ", as.character(orqid_f)))

```