---
title: "BMIN503/EPID600 Project Template"
author: "James Gesualdi"
output: 
  html_document:
    theme: paper 
    highlight: tango
---


***
Use this template to complete your project throughout the course. Your Final Project presentation will be based on the contents of this document. Replace the title/name above and text below with your own, but keep the headers. Feel free to change the theme and other display settings, but this is not required.

### Overview

My project will be a limited meta-analysis of existing bulk RNAseq data sets detailing the differentiation of induced-pluripotent stem cells (IPSCs) into microglia, a key population of resident immune cells in the central nervous system (CNS). IPSC-based modeling is the future of microglia biology in vitro, thus there are many competing standards - eg different IPSC-derived microglia produced by different groups. My analysis will compare the transcriptomes of these competing microglia to a "Gold Standard" or reference transcriptomic dataset generated using microglia isolated from post-mortem biopsies from human donors. 

Project Repository: https://github.com/gesualdiJ/BMIN503_Final_Project

### Introduction 

Microglia have long been challenging to model in-vitro using conventional approaches such as immortalized cell lines or primary culture because their morphology, function, and (more recently appreciated) transcriptome rapidly deteriorate when cultured in isolation. To address this issue, numerous groups have developed microglial cell lines derived from IPSCs through supplementation of cultures with various factors normally present in the micro-encironment of the CNS. The goal of this project is to interrogte the merit of several published IPSC-derived microglia lines along with some more recently developed applications of these cells involving chimeric animal model systems. 

Addressing this problem involves suject matter knowledge of both immunology and neuroscience, as well as various bioinformatic techniques. This analysis will include only a subset of published microglial lines, prioritizing those models that myself and Drs Schaletzki and Su considered influential. The reference transcriptomes - one from adult donors and one generated from analysis of pediatric tissue - add rigor to this project because they represent the closest that we can realistically hope to get to the in vivo gene expression of microglia. The microglia that were analyzed to generate these reference transcriptomes were isolated immediately after surgical resection from patients, therefore there has been minimal time for these cells to lose their in vivo character. Finally, this analysis will be useful to microglia biologists because while many transcriptomic data sets exist, there have been few if any comprehensive meta-analyses of these data and still fewer attempts to harmonize their insights. This project aims to make progress in that direction. 


### Methods
Describe the data used and general methodological approach. Subsequently, incorporate full R code necessary to retrieve and clean data, and perform analysis. Be sure to include a description of code so that others (including your future self) can understand what you are doing and why. 


#install and load packages----

```{r, eval = FALSE, results = 'hide'}


install.packages("BiocManager")
BiocManager::install(c("GEOquery", 
                       "oligo", 
                       "limma", 
                       "hgu133plus2.db", 
                       "pd.hg.u133.plus.2", 
                       "viridis", 
                       "fgsea", 
                       "edgeR",
                       "gplots"))
install.packages("tidyverse")
install.packages("reshape2")
install.packages("edgeR")
install.packages("readxl")
install.packages("ggplot2")
install.packages("fgsea")
install.packages("stringr")
install.packages("readr")
install.packages("purrr")
BiocManager::install("ensembldb") 
BiocManager::install("AnnotationHub") 
BiocManager::install("rhdf5") 
```

```{r, eval = TRUE, results = 'hide', message = FALSE, warning = FALSE}
library(BiocManager)
library(tidyverse)
library(reshape2)
library(rhdf5)
library(edgeR)
library(readxl)
library(GEOquery)
library(oligo)
library(limma)
library(viridis)
library(pd.hg.u133.plus.2)
library(hgu133plus2.db)
library(ggplot2)
library(gplots)
library(fgsea)
library(stringr)
library(readr)
library(ensembldb)
library(AnnotationHub)
library(purrr)
```


```{r, eval = TRUE, message = FALSE}

#Gosselin Data, Fetal Ex-Vivo iMg (raw reads, needs cleaning (removing all non Ex-Vivo microglia conditions) and filtering (removing non-expressed genes) and normalizing (TPM))----

#This Reference dataset contains 24  ex-vivo microglia samples from 24 pediatric patients isolated following surgical resection
#The number of observations (expressed genes) for this dataset is 14,528
#The processed data frames containing these data are stored in tbl's "ExVivo_Juvenile_MG_Reference_Gosselin" (no GeneID column, gene names are row names) 
#or "Gosselin_log2_cpm_filtered_norm" (maintains GeneID as a separate column)

#These data are published but the .xlsx file containing the raw counts, sample labels, and gene names were sent to me by a collaborator
#Therefore, I can just read the counts into a data frame and begin cleaning, filtering, and normalizing without having to access any 
#Transcriptomic repositories or databases. That makes the processing for this data set simpler but less generalizeable. The following 
#Datasets make use of either EnsembleDB or ArchS4 and are therefore more informative for directly accessing published data without any personal connections. 


microglia_fetal_ExVivo_Gosselin <- read_xlsx("Human_RNA-seq_data_Gosselin_Fetal_ExVivo.xlsx", sheet = 1, skip = 1) #Read in raw counts
microglia_fetal_ExVivo_Gosselin <- dplyr::rename(microglia_fetal_ExVivo_Gosselin, Gene_ID = ...1)
microglia_fetal_ExVivo_Gosselin <- microglia_fetal_ExVivo_Gosselin[!duplicated(microglia_fetal_ExVivo_Gosselin$Gene_ID), ]  #remove any duplicated genes symbols (2)
microglia_fetal_ExVivo_Gosselin <- column_to_rownames(microglia_fetal_ExVivo_Gosselin, var = "Gene_ID") #Move gene labels from column to rowname to allow for math operations on values

microglia_fetal_ExVivo_Gosselin <- microglia_fetal_ExVivo_Gosselin %>%    
  dplyr::select(!contains("InVitro") & !contains("Monocytes") & !contains("Lysate"))  #Removes 40 columns of unneeded monocyte/in vitro/lysate data
sample_Labels_Gosselin <- colnames(microglia_fetal_ExVivo_Gosselin)


DGEList_Gosselin <- DGEList(microglia_fetal_ExVivo_Gosselin) #Convert to DGE list to facilitate normalization and count visualization
Gosselin_cpm <- cpm(DGEList_Gosselin$counts)                #Get counts per million for count visualization and filtering of unexpressed genes
table(rowSums(DGEList_Gosselin$counts==0)==24)              #Shows number of non-expressed genes across all samples, indicates roughly how many should be filtered out 


Gosselin_log2_cpm <- as_tibble(cpm(DGEList_Gosselin$counts, log = TRUE) , rownames = "GeneID") #Create and reshape (melt) tibble of log transformed raw counts to visualized unfiltered / unnormalized data
Gosselin_log2_cpm_melt <- melt(Gosselin_log2_cpm)

ggplot(Gosselin_log2_cpm_melt, aes(x=variable, y=value, fill=variable)) +     #visualize overall expression to show excessive influence of unexpressed / lowly expressed genes
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun.y = "median", 
               geom = "point", 
               shape = 124, 
               size = 6, 
               color = "black", 
               show.legend = FALSE) +
  theme(axis.text.x=element_blank()) +
  labs(y="log2 expression",
       title="Log2 Counts per Million (CPM)",
       subtitle="Gosselin, unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time()))

filtrate_gosselin <- rowSums(Gosselin_cpm > 1) >= 6  #create logical vector that evaluates to TRUE when at least 6 of 24 samples express a given gene 
table(filtrate_gosselin)
DGEList_Gosselin_filtered <- DGEList_Gosselin[filtrate_gosselin, ] #subset DGE list so that only genes expressed in at least 6 samples remain
Gosselin_log2_cpm_filtered <- as_tibble(cpm(DGEList_Gosselin_filtered, log = TRUE), rownames = "GeneID") #get counts per million with log2 transformation, reshape and visualize

Gosselin_log2_cpm_filtered_melt <- melt(Gosselin_log2_cpm_filtered)
ggplot(Gosselin_log2_cpm_filtered_melt, aes(x=variable, y=value, fill=variable)) +     
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun.y = "median", 
               geom = "point", 
               shape = 124, 
               size = 6, 
               color = "black", 
               show.legend = FALSE) +
  theme(axis.text.x=element_blank()) +
  labs(y="log2 expression",
       title="Log2 Counts per Million (CPM)",
       subtitle="Gosselin, filtered, non-normalized",
       caption=paste0("produced on ", Sys.time()))

DGEList_Gosselin_filtered_norm <- calcNormFactors(DGEList_Gosselin_filtered, method = "TMM") #TPM normalization
Gosselin_log2_cpm_filtered_norm <- as_tibble(cpm(DGEList_Gosselin_filtered_norm, log = TRUE), rownames = "GeneID") #Format maintaining GeneID column if needed for join function
ExVivo_Juvenile_MG_Reference_Gosselin <- column_to_rownames(Gosselin_log2_cpm_filtered_norm, var = "GeneID") #Final format of juvenile (J) microglia reference data

labels_Gosselin <- rep(NA, 24)  #clean up lengthy sample labels for this dataset. haters will suggest rewriting with vapply. I will never learn vapply!
i <- 1

while (i <= 24){
  labels_Gosselin[i] = paste0(paste0("J", substring(sample_Labels_Gosselin[i], 16, 32)), as.character(i))
  i = i + 1
}
colnames(ExVivo_Juvenile_MG_Reference_Gosselin) <- labels_Gosselin
```

```{r, eval = TRUE, message = FALSE}
#Eggen Data, Adult Ex-Vivo iMg from surgical resection, 39 total samples----

##This processed Reference dataset will contain 39 total samples (all Ex Vivo microglia surgically resected from adult patients)
#The number of observations (expressed genes) for this dataset is 14,397
#The processed data frames containing these data are stored in tbl's "ExVivo_Adult_MG_Reference_Eggen" (no GeneID column, gene names are row names) 
#or "Eggen_log2_cpm_filtered_norm" (maintains GeneID as a separate column)

#This dataset was accessed by directly downloading the tsv containing the raw counts from GEO. However, these data contained only
#transcript IDs instead of gene names like the other datasets. Therefore, I needed to use AnnotationHub() to access the Ensemble Data base
#in order to map the transcript IDs to the appropriate gene names. This is comparable to the use of hgu133plus2.db in Practicum 9,
#But is optimized for Bulk RNA sequencing data rather than MicroArrays, which are somewhat out of date (no shade)

#This is an alternative approach to using the ArchS4 database, which I employ for the next 3 datasets. This 
#Method was mainly included to showcase alternate approaches to access GEO data without downloading and reading in the  large (16 GB!) Archs4 database
#This is also a more beginner friendly approach that allows the user to avoid working with the somewhat cumbersome HDF5 files that ArchS4 uses to organize data


ah <- AnnotationHub()
ahDb <- query(ah, pattern = c("Homo Sapiens", "EnsDb"))   ## Query for available H.Sapiens EnsDb databases, using for mapping probe id's to gene names
EndDB_Hs <- ahDb[["AH104864"]]
EnsDB_Hs <- EndDB_Hs  
EnsDB_Hs_DF <- genes(EnsDB_Hs, return.type = "data.frame") %>%
  dplyr::select(gene_id, gene_name)
EnsDB_Hs_DF <- dplyr::rename(EnsDB_Hs_DF, Tx_ID = gene_id)

microglia_adult_ExVivo_Eggen <- read_tsv("GSE99074_HumanMicrogliaBrainCounts.txt")       #read in data, will need to add gene names using EnsDB information
microglia_adult_ExVivo_Eggen <- dplyr::rename(microglia_adult_ExVivo_Eggen, Tx_ID = ...1)

EnsDB_Hs_DF <- dplyr::filter(EnsDB_Hs_DF, EnsDB_Hs_DF$Tx_ID %in% microglia_adult_ExVivo_Eggen$Tx_ID)  #subset list of matched tx_id's and gene names to only include tx's present in dataset
microglia_adult_ExVivo_Eggen <- inner_join(microglia_adult_ExVivo_Eggen, EnsDB_Hs_DF, by = "Tx_ID")
microglia_adult_ExVivo_Eggen <- relocate(microglia_adult_ExVivo_Eggen, gene_name, .before = spm09)
microglia_adult_ExVivo_Eggen <- microglia_adult_ExVivo_Eggen[ , 1:67]
microglia_adult_ExVivo_Eggen <- dplyr::rename(microglia_adult_ExVivo_Eggen, GeneID = gene_name)
table(microglia_adult_ExVivo_Eggen$GeneID == "") #5116 transcripts ID's for which there is no corresponding gene name, we remove using dplyr::filter
microglia_adult_ExVivo_Eggen <- dplyr::filter(microglia_adult_ExVivo_Eggen, GeneID != "")
microglia_adult_ExVivo_Eggen <- microglia_adult_ExVivo_Eggen[ , 2:67]
microglia_adult_ExVivo_Eggen <- microglia_adult_ExVivo_Eggen[1:40]
microglia_adult_ExVivo_Eggen <- microglia_adult_ExVivo_Eggen[!duplicated(microglia_adult_ExVivo_Eggen$GeneID), ]
microglia_adult_ExVivo_Eggen <- column_to_rownames(microglia_adult_ExVivo_Eggen, var = "GeneID")

#Create DGElist, find counts per million, visualize distribution of data, and filter out unexpressed probes
DGEList_Eggen <- DGEList(microglia_adult_ExVivo_Eggen)      #Convert to DGE list to facilitate normalization and count visualization
Eggen_cpm <- cpm(DGEList_Eggen)                #Get counts per million for count visualization and filtering of unexpressed genes
table(rowSums(DGEList_Eggen$counts==0)==20)              #Shows number of non-expressed genes across all samples, indicates roughly how many should be filtered out 


Eggen_log2_cpm <- as_tibble(cpm(DGEList_Eggen, log = TRUE) , rownames = "GeneID") #Create and reshape (melt) tibble of log transformed raw counts to visualized unfiltered / unnormalized data
Eggen_log2_cpm_melt <- melt(Eggen_log2_cpm)

ggplot(Eggen_log2_cpm_melt, aes(x=variable, y=value, fill=variable)) +     #visualize overall expression to show excessive influence of unexpressed / lowly expressed genes
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun.y = "median", 
               geom = "point", 
               shape = 124, 
               size = 6, 
               color = "black", 
               show.legend = FALSE) +
  theme(axis.text.x=element_blank()) +
  labs(y="log2 expression",
       title="Log2 Counts per Million (CPM)",
       subtitle="Eggen, unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time()))


filtrate_eggen <- rowSums(Eggen_cpm > 1) >= 20  #create logical vector that evaluates to TRUE when at least 20 of 39 samples express a given gene 
table(filtrate_eggen)
DGEList_Eggen_filtered <- DGEList_Eggen[filtrate_eggen, ] #subset DGE list so that only genes expressed in at least 24 samples remain, remove 8110 unexpressed genes
Eggen_log2_cpm_filtered <- as_tibble(cpm(DGEList_Eggen_filtered, log = TRUE), rownames = "GeneID") #get counts per million with log2 transformation, reshape and visualize

Eggen_log2_cpm_filtered_melt <- melt(Eggen_log2_cpm_filtered)
ggplot(Eggen_log2_cpm_filtered_melt, aes(x=variable, y=value, fill=variable)) +     #instead of plotting this whole thing (cumbersone), randomly select 10 and plot
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun.y = "median", 
               geom = "point", 
               shape = 124, 
               size = 6, 
               color = "black", 
               show.legend = FALSE) +
  theme(axis.text.x=element_blank()) +
  labs(y="log2 expression",
       title="Log2 Counts per Million (CPM)",
       subtitle="Eggen, filtered, non-normalized",
       caption=paste0("produced on ", Sys.time()))

DGEList_Eggen_filtered_norm <- calcNormFactors(DGEList_Eggen_filtered, method = "TMM") #TPM normalization
Eggen_log2_cpm_filtered_norm <- as_tibble(cpm(DGEList_Eggen_filtered_norm, log = TRUE), rownames = "GeneID") #Format maintaining GeneID column if needed for join function
ExVivo_Adult_MG_Reference_Eggen <- column_to_rownames(Eggen_log2_cpm_filtered_norm, var = "GeneID") #Final format of Adult (a) microglia reference data

labels_Eggen <- rep(NA, ncol(ExVivo_Adult_MG_Reference_Eggen))  #clean up non-intuitive sample labels. haters will suggest rewriting with vapply. I will never learn vapply!
j <- 1

while (j <= length(labels_Eggen)){
  labels_Eggen[j] = paste0("A_Microllia_ExVivo", as.character(j))
  j = j + 1
}
colnames(ExVivo_Adult_MG_Reference_Eggen) <- labels_Eggen
```

```{r, eval = TRUE, message = FALSE}
#KJS Lab internal data (already cleaned and normalized, expression values are log2(TPM)) ----

#This data set was previously prepared for my thesis lab. Contains 3 IPSC-Microglia samples and 3 Monocyte-derived Macrophage (MDM) samples
#The total number of observations (expressed genes) for this dataset is 14,139
#Only handling here is adding the prefix "KJS_" to the start of the existing sample labels to facilitate downstream aggregation / analysis
#Tbl "KJS_iMG_MDM" contains this dataset and maintains a GeneID column

KJS_iMG_MDM <- read_xlsx("KJS_iMG_MDM_TMM_Normalized.xlsx")
labels_KJS <- c(rep(NA, ncol(KJS_iMG_MDM)))
labels_KJS[1] <- "GeneID"
for(n in 2: ncol(KJS_iMG_MDM)){
  labels_KJS[n] <- paste0("KJS_", colnames(KJS_iMG_MDM[n]))
}
colnames(KJS_iMG_MDM) <- labels_KJS


#Abud 2017 data (regular IPSC Microglia or coculture with Rat Hippocampal neurons)----

#This processed dataset will contain 15 total samples (9 monocultured IPSC-iMg, 6 iMg cocultured with rat hippocampal neurons. Cocultured iMg are notated 'rHcN')
#The number of observations (expressed genes) for this dataset is 12,968
#The processed data frames containing these data are stored in tbl's "IPSC_Microglia_Abud" (no GeneID column, gene names are row names) 
#or "DGEList_Abud_filtered_norm" (maintains GeneID as a separate column)

#This dataset, as well as those from the Svoboda and Blurton-Jones Publications were accessed and cleaned using the Archs4 database which contains
#All of the samples ever uploaded to the Gene Expression Omnibus Repository and includes - among other information -  raw counts for samples as
#Well as descriptions of different samples and overall study design. 

#This is the most efficient way to access and clean data from GEO, as the available metadata typically provides a work around for 
#digging into the supplementary information of a given publication to find sample information

archs4.human <- "/Users/jamesgesualdi/Desktop/BMIN_5030/BMIN503_Final_Project_Local/human_matrix_v11.h5"  #bring in downloaded ArchS4 database containing all GEO accessible transcriptomic data
h5ls(archs4.human)  #List the contents of the loaded Database
all.samples.human <- h5read(archs4.human, name="meta/samples/geo_accession")    #Read in all 441,356 GEO Accession numbers (eg all total human samples on GEO)

#Query the ArchS4 database for the samples I need from the Abud study, based on descriptions in the paper and on the GEO Entry
Abud_Samples <- c("GSM2360252",	#10318X2
                  "GSM2360253",	#7028X2
                  "GSM2360254",	#x2-1
                  "GSM2360255",	#x2-2
                  "GSM2360256",	#x2-3
                  "GSM2360257",	#x2-4
                  "GSM2360283",	#HC-1
                  "GSM2360284",	#HC-2
                  "GSM2360285",	#HC-3
                  "GSM2360286",	#HC-4
                  "GSM2360287",	#HC-5
                  "GSM2360288",	#HC-6
                  "GSM2445478",	#n200 -2
                  "GSM2445479",	#n200 -3
                  "GSM2445480"	#n200 -4
)	

Abud_Sample_Locations <- which(all.samples.human %in% Abud_Samples)     #Find the indices of the above samples in my previously created array of GEO Accession numbers
genes <- h5read(archs4.human, "meta/genes/genes")                       #Bring in gene labels provided by ArchS4


Expression_Abud <- t(h5read(archs4.human, "data/expression",                  
                     index=list(Abud_Sample_Locations, 1:length(genes))))   #Read in raw counts for my samples of interest
H5close()
rownames(Expression_Abud) <- genes
colnames(Expression_Abud) <- all.samples.human[Abud_Sample_Locations]

#Below, I access some meta-data from the study to verify that the appropriate data was extracted from ArchS4, and clean up colnames to more informative labels

Sample_source_name_ch1 <- h5read(archs4.human, "meta/samples/source_name_ch1")     # extract source name
Sample_title <- h5read(archs4.human, name= "meta/samples/title")                   # extract sample title
Sample_characteristics <- h5read(archs4.human, name="meta/samples/characteristics_ch1")   # extract sample characteristics

studyDesign_Abud <- tibble(Sample_title_Abud = Sample_title[Abud_Sample_Locations], 
                      Sample_source_name_ch1 = Sample_source_name_ch1[Abud_Sample_Locations],
                      Sample_characteristics = Sample_characteristics[Abud_Sample_Locations])

head(studyDesign_Abud)                                                      #Just for context

colnames(Expression_Abud) <- studyDesign_Abud$Sample_title_Abud

#move on to filtering and normalization of Abud data
DGEList_Abud <- DGEList(Expression_Abud)      #Convert to DGE list to facilitate normalization and count visualization
Abud_cpm <- cpm(DGEList_Abud)                #Get counts per million for count visualization and filtering of unexpressed genes
table(rowSums(DGEList_Abud$counts==0)==15)              #Shows number of non-expressed genes across all samples, indicates roughly how many should be filtered out 

Abud_log2_cpm <- as_tibble(cpm(DGEList_Abud, log = TRUE) , rownames = "GeneID") #Create and reshape (melt) tibble of log transformed raw counts to visualized unfiltered / unnormalized data
Abud_log2_cpm_melt <- melt(Abud_log2_cpm)

ggplot(Abud_log2_cpm_melt, aes(x=variable, y=value, fill=variable)) +     #visualize overall expression to show excessive influence of unexpressed / lowly expressed genes
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun.y = "median", 
               geom = "point", 
               shape = 124, 
               size = 6, 
               color = "black", 
               show.legend = FALSE) +
  theme(axis.text.x=element_blank()) +
  labs(y="log2 expression",
       title="Log2 Counts per Million (CPM)",
       subtitle="Abud, unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time()))

filtrate_abud <- rowSums(Abud_cpm > 1) >= 4  #create logical vector that evaluates to TRUE when at least 4 of 15 samples express a given gene 
table(filtrate_abud)
DGEList_Abud_filtered <- DGEList_Abud[filtrate_abud, ] #subset DGE list so that only genes expressed in at least 4 samples remain, remove 24,138 unexpressed genes
Abud_log2_cpm_filtered <- as_tibble(cpm(DGEList_Abud_filtered, log = TRUE), rownames = "GeneID") #get counts per million with log2 transformation, reshape and visualize

Abud_log2_cpm_filtered_melt <- melt(Abud_log2_cpm_filtered)     #visualize overall expression to show corrected distribution following filtering
ggplot(Abud_log2_cpm_filtered_melt, aes(x=variable, y=value, fill=variable)) +   
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun.y = "median", 
               geom = "point", 
               shape = 124, 
               size = 6, 
               color = "black", 
               show.legend = FALSE) +
  theme(axis.text.x=element_blank()) +   
  labs(y="log2 expression",
       title="Log2 Counts per Million (CPM)",
       subtitle="Abud, filtered, non-normalized",
       caption=paste0("produced on ", Sys.time()))

DGEList_Abud_filtered_norm <- calcNormFactors(DGEList_Abud_filtered, method = "TMM") #TPM normalization
DGEList_Abud_filtered_norm <- as_tibble(cpm(DGEList_Abud_filtered_norm, log = TRUE), rownames = "GeneID") #Format maintaining GeneID column if needed for join function

IPSC_Microglia_Abud <- column_to_rownames(DGEList_Abud_filtered_norm, var = "GeneID")                  #Final variable location of Abud IPSC Microglia Data
IPSC_Microglia_Abud <- IPSC_Microglia_Abud  %>%
  dplyr::select(order(colnames(IPSC_Microglia_Abud)))


labels_Abud <- c(rep("IPSC_Microglia_Abud", 2), rep("IPSC_Microglia_Abud_rHcN", 6), rep("IPSC_Microglia_Abud", 7))  #clean up non-intuitive sample labels
labels_Abud_Numbers <- c("1", "2", "1", "2", "3", "4", "5", "6", "3", "4", "5", "6", "7", "8", "9")
for(l in 1:length(labels_Abud)){
  labels_Abud[l] <- paste0(labels_Abud[l], labels_Abud_Numbers[l])
}
colnames(IPSC_Microglia_Abud) <- labels_Abud
IPSC_Microglia_Abud <- dplyr::select(IPSC_Microglia_Abud, order(colnames(IPSC_Microglia_Abud)))    #reorder again for convenient grouping of now renamed samples
```

```{r, eval = TRUE, message = FALSE}
#Blurton jones 2019 data (transplant) ----

#This processed dataset will contain 16 total samples (10 transplanted iMg, 6 in vitro. Transplanted iMg are notated 'xMG')
#The number of observations (expressed genes) for this dataset is 13,421
#The processed data frames containing these data are stored in tbl's "IPSC_Microglia_Blurton" (no GeneID column, gene names are row names) 
#or "DGEList_Blurton_filtered_norm" (maintains GeneID as a separate column)

Blurton_Samples <- c("GSM3908536",	#MBJ_iMGL_SAL_1
  "GSM3908537",	#MBJ_iMGL_SAL_2
  "GSM3908538",	#MBJ_iMGL_SAL_3
  "GSM3908539",	#MBJ_iMGL_LPS_1
  "GSM3908540",	#MBJ_iMGL_LPS_2
  "GSM3908541",	#MBJ_iMGL_LPS_3
  "GSM3908542",	#MBJ_xMG_GFP_1
  "GSM3908543",	#MBJ_xMG_GFP_2
  "GSM3908544",	#MBJ_xMG_GFP_3
  "GSM3908545",	#MBJ_xMG_GFP_LPS_1
  "GSM3908546",	#MBJ_xMG_GFP_LPS_2
  "GSM3908547",	#MBJ_xMG_GFP_LPS_3
  "GSM3908548",	#MBJ_xMG_GFP_LPS_4
  "GSM3908549",	#MBJ_xMG_GFP_LPS_5
  "GSM3908550",	#MBJ_xMG_CDI_1
  "GSM3908551",	#MBJ_xMG_CDI_2
  "GSM3908552",	#MBJ_xMG_CDI_3
  "GSM3908553",	#MBJ_xMG_CDI_4
  "GSM3908554",	#MBJ_xMG_CDI_5
  "GSM3908555",	#MBJ_xMG_CDI_6
  "GSM3908556",	#MBJ_xMG_10C_1
  "GSM3908557",	#MBJ_xMG_10C_2
  "GSM3908558",	#MBJ_xMG_10C_3
  "GSM3908559",	#MBJ_xMG_10C_4
  "GSM3908560",	#MBJ_ExVivo_1
  "GSM3908561",	#MBJ_ExVivo_2
  "GSM3908562",	#MBJ_iMGL_GFP_1
  "GSM3908563",	#MBJ_iMGL_GFP_2
  "GSM3908564",	#MBJ_iMGL_GFP_3
  "GSM3908565",	#MBJ_iMGL_GFP_4
  "GSM3908566",	#MBJ_iMGL_GFP_5
  "GSM3908567"	#MBJ_iMGL_GFP_6
)

Blurton_Sample_Locations <- which(all.samples.human %in% Blurton_Samples)
Expression_Blurton <- t(h5read(archs4.human, "data/expression", 
                               index=list(Blurton_Sample_Locations, 1:length(genes))))
H5close()
rownames(Expression_Blurton) <- genes
colnames(Expression_Blurton) <- all.samples.human[Blurton_Sample_Locations]

#Below, I access some meta-data from the study to verify that the appropriate data was extracted from ArchS4, and clean up colnames to more informative labels

studyDesign_Blurton <- tibble(Sample_title_Blurton = Sample_title[Blurton_Sample_Locations], 
                              Sample_source_name_ch1_Blurton = Sample_source_name_ch1[Blurton_Sample_Locations],
                              Sample_characteristics_Blurton = Sample_characteristics[Blurton_Sample_Locations])
head(studyDesign_Blurton)

colnames(Expression_Blurton) <- studyDesign_Blurton$Sample_title_Blurton
Expression_Blurton <- Expression_Blurton[ , c(15:24, 27:32)]              #Remove samples unnecessary for this analysis based on sample characteristics accessed above

#move on to filtering and normalization of Blurton-Jones data
DGEList_Blurton <- DGEList(Expression_Blurton)      #Convert to DGE list to facilitate normalization and count visualization
Expression_Blurton_cpm <- cpm(DGEList_Blurton)                #Get counts per million for count visualization and filtering of unexpressed genes
table(rowSums(DGEList_Blurton$counts==0)==18)              #Shows number of non-expressed genes across all samples, indicates roughly how many should be filtered out 

Blurton_log2_cpm <- as_tibble(cpm(DGEList_Blurton, log = TRUE) , rownames = "GeneID") #Create and reshape (melt) tibble of log transformed raw counts to visualized unfiltered / unnormalized data
Blurton_log2_cpm_melt <- melt(Blurton_log2_cpm)

ggplot(Blurton_log2_cpm_melt, aes(x=variable, y=value, fill=variable)) +     #visualize overall expression to show excessive influence of unexpressed / lowly expressed genes
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun.y = "median", 
               geom = "point", 
               shape = 124, 
               size = 6, 
               color = "black", 
               show.legend = FALSE) +
  theme(axis.text.x=element_blank()) +                    
  labs(y="log2 expression",
       title="Log2 Counts per Million (CPM)",
       subtitle="Blurton-Jones, unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time()))

filtrate_Blurton<- rowSums(Expression_Blurton_cpm > 1) >= 6  #create logical vector that evaluates to TRUE when at least 6 of 16 samples express a given gene 
table(filtrate_Blurton)
DGEList_Blurton_filtered <- DGEList_Blurton[filtrate_Blurton, ] #subset DGE list so that only genes expressed in at least 6 samples remain, remove 21817 unexpressed genes
Blurton_log2_cpm_filtered <- as_tibble(cpm(DGEList_Blurton_filtered, log = TRUE), rownames = "GeneID") #get counts per million with log2 transformation, reshape and visualize
Blurton_log2_cpm_filtered_melt <- melt(Blurton_log2_cpm_filtered)

ggplot(Blurton_log2_cpm_filtered_melt, aes(x=variable, y=value, fill=variable)) +   
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun.y = "median", 
               geom = "point", 
               shape = 124, 
               size = 6, 
               color = "black", 
               show.legend = FALSE) +
  theme(axis.text.x=element_blank()) + 
  labs(y="log2 expression",
       title="Log2 Counts per Million (CPM)",
       subtitle="Blurton-Jones, filtered, non-normalized",
       caption=paste0("produced on ", Sys.time()))

DGEList_Blurton_filtered_norm <- calcNormFactors(DGEList_Blurton_filtered, method = "TMM") #TPM normalization
DGEList_Blurton_filtered_norm <- as_tibble(cpm(DGEList_Blurton_filtered_norm, log = TRUE), rownames = "GeneID") #Format maintaining GeneID column if needed for join function
IPSC_Microglia_Blurton <- column_to_rownames(DGEList_Blurton_filtered_norm, var = "GeneID")                  #Final format of Blurton IPSC Microglia Data, no altering of these sample labels
```

```{r, eval = TRUE, message = FALSE}
#Svoboda 2019 data, transplant ---- 

#This processed dataset will contain 18 total samples of IPSC microglia (6 in transplant for 60 days, 6 in transplant for 10 days, and 6 differentiated in vitro (10 days))
#The number of observations (expressed genes) for this dataset is 13,433
#The processed data frames containing these data are stored in tbl's "IPSC_Microglia_Svoboda" (no GeneID column, gene names are row names) 
#or "DGEList_Svoboda_filtered_norm" (maintains GeneID as a separate column)

Svoboda_Samples <- c("GSM4133389", #iMP1
                    "GSM4133390",	#iMP2
                    "GSM4133391",	#iMP3
                    "GSM4133392",	#iMP4
                    "GSM4133393",	#iMP5
                    "GSM4133394",	#iMP6
                    "GSM4133395",	#In vivo iMG 10dpi rep 1
                    "GSM4133396",	#In vivo iMG 10dpi rep 2
                    "GSM4133397",	#In vivo iMG 10dpi rep 3
                    "GSM4133398",	#In vivo iMG 10dpi rep 4
                    "GSM4133399",	#In vivo iMG 10dpi rep 5
                    "GSM4133400",	#In vivo iMG 10dpi rep 6
                    "GSM4133401",	#In vivo iMG 60dpi rep 1
                    "GSM4133402",	#In vivo iMG 60dpi rep 2
                    "GSM4133403",	#In vivo iMG 60dpi rep 3
                    "GSM4133404",	#In vivo iMG 60dpi rep 4
                    "GSM4133405",	#In vivo iMG 60dpi rep 5
                    "GSM4133406",	#In vivo iMG 60dpi rep 6
                    "GSM4133407",	#In vitro iMG 10dpi rep 1
                    "GSM4133408",	#In vitro iMG 10dpi rep 2
                    "GSM4133409",	#In vitro iMG 10dpi rep 3
                    "GSM4133410",	#In vitro iMG 10dpi rep 4
                    "GSM4133411",	#In vitro iMG 10dpi rep 5
                    "GSM4133412",	#In vitro iMG 10dpi rep 6
                    "GSM4133413", #In vitro iMG 60dpi rep 1
                    "GSM4133414", #In vitro iMG 60dpi rep 2
                    "GSM4133415",	#In vitro iMG 60dpi rep 3
                    "GSM4133416",	#In vitro iMG 60dpi rep 4
                    "GSM4133417",	#In vitro iMG 60dpi rep 5
                    "GSM4133418",	#In vitro iMG 60dpi rep 6
                    "GSM4133419",	#In Vivo 2 [M543]
                    "GSM4133420",	#In Vivo 1 [M544]
                    "GSM4133421",	#In Vivo 4 [M1]
                    "GSM4133422",	#In Vivo 3 [M2]
                    "GSM4133423",	#In Vitro 1 [IV1]
                    "GSM4133424"	#In Vitro 2 [IV2]
)

Svoboda_Sample_Locations <- which(all.samples.human %in% Svoboda_Samples)
Expression_Svoboda <- t(h5read(archs4.human, "data/expression", 
                            index=list(Svoboda_Sample_Locations, 1:length(genes))))
H5close()
rownames(Expression_Svoboda) <- genes
colnames(Expression_Svoboda) <- all.samples.human[Svoboda_Sample_Locations]

#Below, I access some meta-data from the study to verify that the appropriate data was extracted from ArchS4, and clean up colnames to more informative labels

studyDesign_Svoboda <- tibble(Sample_title_Svoboda = Sample_title[Svoboda_Sample_Locations], 
                           Sample_source_name_ch1_Svoboda = Sample_source_name_ch1[Svoboda_Sample_Locations],
                           Sample_characteristics_Svoboda = Sample_characteristics[Svoboda_Sample_Locations])

colnames(Expression_Svoboda) <- studyDesign_Svoboda$Sample_title_Svoboda
Expression_Svoboda <- Expression_Svoboda[ , 9:26]

#move on to filtering and normalization of Svoboda data
DGEList_Svoboda <- DGEList(Expression_Svoboda)      #Convert to DGE list to facilitate normalization and count visualization
Expression_Svoboda_cpm <- cpm(DGEList_Svoboda)                #Get counts per million for count visualization and filtering of unexpressed genes
table(rowSums(DGEList_Svoboda$counts==0)==18)              #Shows number of non-expressed genes across all samples, indicates roughly how many should be filtered out 

Svoboda_log2_cpm <- as_tibble(cpm(DGEList_Svoboda, log = TRUE) , rownames = "GeneID") #Create and reshape (melt) tibble of log transformed raw counts to visualized unfiltered / unnormalized data
Svoboda_log2_cpm_melt <- melt(Svoboda_log2_cpm)

ggplot(Svoboda_log2_cpm_melt, aes(x=variable, y=value, fill=variable)) +     #visualize overall expression to show excessive influence of unexpressed / lowly expressed genes
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun.y = "median", 
               geom = "point", 
               shape = 124, 
               size = 6, 
               color = "black", 
               show.legend = FALSE) +
  theme(axis.text.x=element_blank()) +   
  labs(y="log2 expression",
       title="Log2 Counts per Million (CPM)",
       subtitle="Svoboda, unfiltered, non-normalized",
       caption=paste0("produced on ", Sys.time()))

filtrate_Svoboda<- rowSums(Expression_Svoboda_cpm > 1) >= 6  #create logical vector that evaluates to TRUE when at least 6 of 18 samples express a given gene 
table(filtrate_Svoboda)
DGEList_Svoboda_filtered <- DGEList_Svoboda[filtrate_Svoboda, ] #subset DGE list so that only genes expressed in at least 6 samples remain, remove 21805 unexpressed genes
Svoboda_log2_cpm_filtered <- as_tibble(cpm(DGEList_Svoboda_filtered, log = TRUE), rownames = "GeneID") #get counts per million with log2 transformation, reshape and visualize
Svoboda_log2_cpm_filtered_melt <- melt(Svoboda_log2_cpm_filtered)

ggplot(Svoboda_log2_cpm_filtered_melt, aes(x=variable, y=value, fill=variable)) +   
  geom_violin(trim = FALSE, show.legend = FALSE) +
  stat_summary(fun.y = "median", 
               geom = "point", 
               shape = 124, 
               size = 6, 
               color = "black", 
               show.legend = FALSE) +
  theme(axis.text.x=element_blank()) +   
  labs(y="log2 expression",
       title="Log2 Counts per Million (CPM)",
       subtitle="Svoboda, filtered, non-normalized",
       caption=paste0("produced on ", Sys.time()))

DGEList_Svoboda_filtered_norm <- calcNormFactors(DGEList_Svoboda_filtered, method = "TMM") #TPM normalization
DGEList_Svoboda_filtered_norm <- as_tibble(cpm(DGEList_Svoboda_filtered_norm, log = TRUE), rownames = "GeneID") #Format maintaining GeneID column if needed for join function
IPSC_Microglia_Svoboda <- column_to_rownames(DGEList_Svoboda_filtered_norm, var = "GeneID")                  #Final format of Svoboda IPSC Microglia Data

labels_Svoboda <- c(rep(NA, ncol(IPSC_Microglia_Svoboda)))      #Add "Svoboda_" to sample lables to facilitate later analysis and visualization. Potentially will return later to shorten
for(m in 1:length(labels_Svoboda)){
  labels_Svoboda[m] <- paste0("Svoboda_", colnames(IPSC_Microglia_Svoboda[m]))
}
colnames(IPSC_Microglia_Svoboda) <- labels_Svoboda
```

```{r, eval = TRUE, message = FALSE}
#Data Aggregation ----
#Here, I will add all 6 of the pre-processed datasets into a list, then use purrr::reduce() to apply left_join() to all the elements of this list
#This will create a tibble of all 118 samples with a total of 14,528 observations (expressed genes). The number of observations comes from the Gosselin 
#reference dataset, which had the largest number of samples (14,528). However, this introduces NA data into the aggregate dataset, since other component
#tibbles may have been missing some of those genes. Removing any genes for which any samples have NA vaues leads to a removel of 4269 genes, leading 
#to a final number of observations of 10,259 in the aggregate dataset. 
#For subsequent exploratory and DGE analysis, the generated tbl.df Aggregation_Set will be used

Aggregation_List <- list(Gosselin_log2_cpm_filtered_norm, Eggen_log2_cpm_filtered_norm, KJS_iMG_MDM, 
                         DGEList_Abud_filtered_norm, DGEList_Blurton_filtered_norm, DGEList_Svoboda_filtered_norm)
Aggregation_Set <- Aggregation_List %>%
  purrr::reduce(left_join, by = "GeneID")
Aggregation_Set <- column_to_rownames(Aggregation_Set, var = "GeneID") %>% #Move the gene names to rownames to eliminate the non numeric column, remove NA probes
  na.omit()
dim(Aggregation_Set)

#Exploratory Analysis (PCA)----
#Differential Gene Expression Analysis----
```

### Results
Describe your results and include relevant tables, plots, and code/comments used to obtain them. End with a brief conclusion of your findings related to the question you set out to address. You can include references if you'd like, but this is not required.

```{r, eval = TRUE, message = FALSE}

```


