---
title: "BMIN503/EPID600 Final Project"
author: "Jenna Reece"
output: 
  html_document:
    theme: paper 
    highlight: tango
---


***
Use this template to complete your project throughout the course. Your Final Project presentation will be based on the contents of this document. Replace the title/name above and text below with your own, but keep the headers. Feel free to change the theme and other display settings, but this is not required.

### Overview
This project aims to evaluate blood product transfusion at the Hospital of the University of Pennsylvania.  I will use a dataset from 2021 that includes all transfusions performed, and the patientâ€™s complete blood count, clotting tests, and other parameters. The goal is to assess how often patients received transfusions when they fell outside the established clinical guidelines for blood components.



### Introduction 
Blood product transfusion is a common and lifesaving intervention for patients, but despite its benefits, it also introduces risks for patients, including the risk of transfusion reaction, infectious complications, and alloimmunization. Many studies over the past few decades have demonstrated that transfusion thresholds that are more conservative, i.e. more restrictive, lead to better patient outcomes than liberal transfusion thresholds. I am examining an operational dataset which contains blood products administered to patients, and their hematologic lab values, which will be compared to established transfusion guidelines. 

Obviously, there are many complex factors that play into whether a transfusion is indicated, and transfusion thresholds may be personalized for patients, but it will be helpful to describe practices and trends to identify areas for potential intervention. There are several specific questions of particular interest to the blood bank, notably how often clinicians evaluate the corrected count increment after platelet transfusion.  Other concerns include the size of the population with certain transfusion thresholds, and identifying practice patterns for particular providers. In general, knowing how blood products are used allows the blood bank to more accurately predict blood needs in the future, which allows for better planning and inventory management.


### Methods
Describe the data used and general methodological approach. Subsequently, incorporate full R code necessary to retrieve and clean data, and perform analysis. Be sure to include a description of code so that others (including your future self) can understand what you are doing and why. 

Data cleaning:
The data that I have for this project begins in an excel file, which means that I need to do some cleaning to get it in the right format. Many of the variables are also very much not de-identified, which means that they will be de-identified for analysis.

Code for processing the files:

---
title: "20200210_TransfusionWeek"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(readxl)
```

```{r}
df <- read_excel("Blood Bank Transfusion_20200720.xlsx", skip = 2) 
#(to skip 2 lines)
```

```{r}
#QAQI_20200127_timediff <- mutate(QAQI_20200127, timediff = TRANSFUSION_DATE - COLLECT_DATE)
```


```{r}
#QAQI_20200127_timediff$timediff <- as.numeric(QAQI_20200127_timediff$timediff)

#RBCs

df_Hgb <- df %>% filter(RESULT_CODE == "Hgb") %>% select(MRN, COLLECT_DATE, RESULT, RESULT_CODE, ORDER_PHYS) %>% unique(by =c(MRN, COLLECT_DATE))

#df_HgbOtherunique <- df %>% filter(RESULT_CODE == "Hgb") %>% select(MRN, COLLECT_DATE, RESULT, RESULT_CODE) %>% unique()


df_RBCTransfusion <- df %>% filter(PRODUCT_TYPE == "Red Cells") %>% select(MRN, PATIENT_NAME, TRANSFUSION_DATE, PRODUCT_TYPE, TRANSFUSED_VOL) %>% unique(by =c(MRN, TRANSFUSION_DATE, PRODUCT_TYPE))

RBCTransHgb <- df_RBCTransfusion %>% left_join(df_Hgb, by = 'MRN') %>% mutate(timediff = TRANSFUSION_DATE - COLLECT_DATE)

RBCTransHgbPre1 <- RBCTransHgb %>% filter(timediff > 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(HgbRankDatePre = rank(timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(HgbRankDatePre == "1") %>% select(-HgbRankDatePre, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -timediff)

colnames(RBCTransHgbPre1)[colnames(RBCTransHgbPre1) == "COLLECT_DATE"] <- "COLLECT_DATE_HgbPre1"

colnames(RBCTransHgbPre1)[colnames(RBCTransHgbPre1) == "timediff"] <- "timediff_Pre1"

colnames(RBCTransHgbPre1)[colnames(RBCTransHgbPre1) == "RESULT"] <- "Hgb_Pre1"

##colnames(df)[colnames(df) == "COLLECT_DATE"] <- "COLLECT_DATE_NEW"
#switch column name by name, not number, and idempotent.  Will run only once because once name is changed it wont run it again no matter how many times this line of code is seen

RBCTransHgbPre2 <- RBCTransHgb %>% filter(timediff > 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(HgbRankDatePre = rank(timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(HgbRankDatePre == "2")  %>% select(-HgbRankDatePre, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -ORDER_PHYS, -timediff)

colnames(RBCTransHgbPre2)[colnames(RBCTransHgbPre2) == "COLLECT_DATE"] <- "COLLECT_DATE_HgbPre2"

colnames(RBCTransHgbPre2)[colnames(RBCTransHgbPre2) == "RESULT"] <- "Hgb_Pre2"

colnames(RBCTransHgbPre2)[colnames(RBCTransHgbPre2) == "timediff"] <- "timediff_Pre2"

RBCTransHgbPost1 <- RBCTransHgb %>% filter(timediff < 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(HgbRankDatePost = rank(-timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(HgbRankDatePost == "1")  %>% select(-HgbRankDatePost, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -ORDER_PHYS, -timediff)

colnames(RBCTransHgbPost1)[colnames(RBCTransHgbPost1) == "COLLECT_DATE"] <- "COLLECT_DATE_HgbPost1"

colnames(RBCTransHgbPost1)[colnames(RBCTransHgbPost1) == "RESULT"] <- "Hgb_Post1"

colnames(RBCTransHgbPost1)[colnames(RBCTransHgbPost1) == "timediff"] <- "timediff_Post1"

RBCTransHgbPost2 <- RBCTransHgb %>% filter(timediff < 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(HgbRankDatePost = rank(-timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(HgbRankDatePost == "2")  %>% select(-HgbRankDatePost, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -ORDER_PHYS, -timediff)

colnames(RBCTransHgbPost2)[colnames(RBCTransHgbPost2) == "COLLECT_DATE"] <- "COLLECT_DATE_HgbPost2"

colnames(RBCTransHgbPost2)[colnames(RBCTransHgbPost2) == "RESULT"] <- "Hgb_Post2"

colnames(RBCTransHgbPost2)[colnames(RBCTransHgbPost2) == "timediff"] <- "timediff_Post2"

RBCTransAll <- df_RBCTransfusion %>% left_join(RBCTransHgbPre1, by = c( 'MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% left_join(RBCTransHgbPre2, by = c( 'MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% left_join(RBCTransHgbPost1, by = c( 'MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% left_join(RBCTransHgbPost2, by = c( 'MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% arrange(TRANSFUSION_DATE, MRN)

```

```{r}
#FFP
df_INR <- df %>% filter(RESULT_CODE == "INR") %>% select(MRN, COLLECT_DATE, RESULT, RESULT_CODE, ORDER_PHYS) %>% unique(by =c(COLLECT_DATE))

df_FFPTransfusion <- df %>% filter(PRODUCT_TYPE == "Thawed Plasma") %>% select(MRN, PATIENT_NAME, TRANSFUSION_DATE, PRODUCT_TYPE, TRANSFUSED_VOL) %>% unique(by =c(MRN, TRANSFUSION_DATE, PRODUCT_TYPE))

FFPTransINR <- df_FFPTransfusion %>% left_join(df_INR, by = 'MRN') %>% mutate(timediff = TRANSFUSION_DATE - COLLECT_DATE)

FFPTransINRPre1 <- FFPTransINR %>% filter(timediff > 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(INRRankDatePre = rank(timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(INRRankDatePre == "1") %>% select(-INRRankDatePre, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -timediff)

colnames(FFPTransINRPre1)[colnames(FFPTransINRPre1) == "COLLECT_DATE"] <- "COLLECT_DATE_INRPre1"

colnames(FFPTransINRPre1)[colnames(FFPTransINRPre1) == "timediff"] <- "timediff_Pre1"

colnames(FFPTransINRPre1)[colnames(FFPTransINRPre1) == "RESULT"] <- "INR_Pre1"

##colnames(df)[colnames(df) == "COLLECT_DATE"] <- "COLLECT_DATE_NEW"
#switch column name by name, not number, and idempotent.  Will run only once because once name is changed it wont run it again no matter how many times this line of code is seen

FFPTransINRPre2 <- FFPTransINR %>% filter(timediff > 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(INRRankDatePre = rank(timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(INRRankDatePre == "2")  %>% select(-INRRankDatePre, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -ORDER_PHYS, -timediff)

colnames(FFPTransINRPre2)[colnames(FFPTransINRPre2) == "COLLECT_DATE"] <- "COLLECT_DATE_INRPre2"

colnames(FFPTransINRPre2)[colnames(FFPTransINRPre2) == "RESULT"] <- "INR_Pre2"

colnames(FFPTransINRPre2)[colnames(FFPTransINRPre2) == "timediff"] <- "timediff_Pre2"

FFPTransINRPost1 <- FFPTransINR%>% filter(timediff < 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(INRRankDatePost = rank(-timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(INRRankDatePost == "1")  %>% select(-INRRankDatePost, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -ORDER_PHYS, -timediff)

colnames(FFPTransINRPost1)[colnames(FFPTransINRPost1) == "COLLECT_DATE"] <- "COLLECT_DATE_INRPost1"

colnames(FFPTransINRPost1)[colnames(FFPTransINRPost1) == "RESULT"] <- "INR_Post1"

colnames(FFPTransINRPost1)[colnames(FFPTransINRPost1) == "timediff"] <- "timediff_Post1"

FFPTransINRPost2 <- FFPTransINR %>% filter(timediff < 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(INRRankDatePost = rank(-timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(INRRankDatePost == "2")  %>% select(-INRRankDatePost, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -ORDER_PHYS, -timediff)

colnames(FFPTransINRPost2)[colnames(FFPTransINRPost2) == "COLLECT_DATE"] <- "COLLECT_DATE_INRPost2"

colnames(FFPTransINRPost2)[colnames(FFPTransINRPost2) == "RESULT"] <- "INR_Post2"

colnames(FFPTransINRPost2)[colnames(FFPTransINRPost2) == "timediff"] <- "timediff_Post2"

FFPTransAll <- df_FFPTransfusion %>% left_join(FFPTransINRPre1, by = c( 'MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% left_join(FFPTransINRPre2, by = c('MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% left_join(FFPTransINRPost1, by = c('MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% left_join(FFPTransINRPost2, by = c('MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% arrange(TRANSFUSION_DATE, MRN)
```

```{r}
# Platelets

df_Plt <- df %>% filter(RESULT_CODE == "Platelet") %>% select(MRN, COLLECT_DATE, RESULT, RESULT_CODE, ORDER_PHYS) %>% unique(by =c(COLLECT_DATE))

df_PltTransfusion <- df %>% filter(PRODUCT_TYPE == "Single Donor Platelets") %>% select(MRN, PATIENT_NAME, TRANSFUSION_DATE, PRODUCT_TYPE, TRANSFUSED_VOL) %>% unique(by =c(MRN, TRANSFUSION_DATE, PRODUCT_TYPE))

PltTransPlt <- df_PltTransfusion %>% left_join(df_Plt, by = 'MRN') %>% mutate(timediff = TRANSFUSION_DATE - COLLECT_DATE)

PltTransPltPre1 <- PltTransPlt %>% filter(timediff > 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(PltRankDatePre = rank(timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(PltRankDatePre == "1") %>% select(-PltRankDatePre, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -timediff)

colnames(PltTransPltPre1)[colnames(PltTransPltPre1) == "COLLECT_DATE"] <- "COLLECT_DATE_PltPre1"

colnames(PltTransPltPre1)[colnames(PltTransPltPre1) == "timediff"] <- "timediff_Pre1"

colnames(PltTransPltPre1)[colnames(PltTransPltPre1) == "RESULT"] <- "Plt_Pre1"

##colnames(df)[colnames(df) == "COLLECT_DATE"] <- "COLLECT_DATE_NEW"
#switch column name by name, not number, and idempotent.  Will run only once because once name is changed it wont run it again no matter how many times this line of code is seen

PltTransPltPre2 <- PltTransPlt %>% filter(timediff > 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(PltRankDatePre = rank(timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(PltRankDatePre == "2")  %>% select(-PltRankDatePre, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -ORDER_PHYS, -timediff)

colnames(PltTransPltPre2)[colnames(PltTransPltPre2) == "COLLECT_DATE"] <- "COLLECT_DATE_PltPre2"

colnames(PltTransPltPre2)[colnames(PltTransPltPre2) == "RESULT"] <- "Plt_Pre2"

colnames(PltTransPltPre2)[colnames(PltTransPltPre2) == "timediff"] <- "timediff_Pre2"

PltTransPltPost1 <- PltTransPlt %>% filter(timediff < 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(PltRankDatePost = rank(-timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(PltRankDatePost == "1")  %>% select(-PltRankDatePost, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -ORDER_PHYS, -timediff)

colnames(PltTransPltPost1)[colnames(PltTransPltPost1) == "COLLECT_DATE"] <- "COLLECT_DATE_PltPost1"

colnames(PltTransPltPost1)[colnames(PltTransPltPost1) == "RESULT"] <- "Plt_Post1"

colnames(PltTransPltPost1)[colnames(PltTransPltPost1) == "timediff"] <- "timediff_Post1"

PltTransPltPost2 <- PltTransPlt %>% filter(timediff < 0) %>% group_by(MRN, TRANSFUSION_DATE) %>% arrange(COLLECT_DATE) %>% mutate(PltRankDatePost = rank(-timediff)) %>% arrange(TRANSFUSION_DATE) %>% filter(PltRankDatePost == "2")  %>% select(-PltRankDatePost, -RESULT_CODE, -PRODUCT_TYPE, -TRANSFUSED_VOL, -ORDER_PHYS, -timediff)

colnames(PltTransPltPost2)[colnames(PltTransPltPost2) == "COLLECT_DATE"] <- "COLLECT_DATE_PltPost2"

colnames(PltTransPltPost2)[colnames(PltTransPltPost2) == "RESULT"] <- "Plt_Post2"

colnames(PltTransPltPost2)[colnames(PltTransPltPost2) == "timediff"] <- "timediff_Post2"

PltTransAll <- df_PltTransfusion %>% left_join(PltTransPltPre1, by = c('MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% left_join(PltTransPltPre2, by = c('MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% left_join(PltTransPltPost1, by = c('MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% left_join(PltTransPltPost2, by = c('MRN', 'PATIENT_NAME', 'TRANSFUSION_DATE')) %>% arrange(TRANSFUSION_DATE, MRN)
```

```{r}
write_tsv(RBCTransAll, "20200720_RBCTransfusions.txt")
write_tsv(FFPTransAll, "20200720_FFPTransfusions.txt")
write_tsv(PltTransAll, "20200720_PltTransfusions.txt")
```


As a summary:


* means that this is NOT a de-identified variable, so I need to de-identify it for this project.
KEY means that I think this column will be crucial for analysis.

Columns I have:
*KEY MRN- char
*Patient Name- char
KEY Transfusion_Date- numeric
KEY Product_type- char- may be red blood cells, single donor platelets, pathogen reduced platelets, thawed cryo, thawed plasma, whole blood
Transfused_vol- numeric, standardized, not trustworthy
Order_Name- char â€“ not high yield, because result code is better.
Order_date- numeric- not high yield, because collect is more important
KEY Collect_date- numeric- KEY
Result_date- numeric
*Accession_nbr- char
KEY Result_code- char. Platelets, hbg, INR
KEY Result- numeric
*Order_phys- char



Analysis that should be done:

For each product:
How many patients received transfusions, and how many units did they receive- over what time period?

For those who received platelet transfusions, how many had a platelet count performed beforehand?  After?  What was the distribution of those values?

For those who received red blood cells, how many had a hemoglobin performed beforehand?  After?  What was the distribution of those values?

How many patients received a single unit of FFP? What was their INR?


Were the ordering practices different for different ordering physicians?


How would we predict the need for products given this information?



### Results
Describe your results and include relevant tables, plots, and code/comments used to obtain them. End with a brief conclusion of your findings related to the question you set out to address. You can include references if you'd like, but this is not required.
