---
title: "Gather Vital Signs"
author: "Adam Dziorny"
date: "November 24, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
```

## Connect

First source the ODBC connection functions and make the connection (code is hidden).

```{r nzConn, echo=FALSE}
source('F_rodbc_cdw.R')

nzConn <- makeConn(user = 'dziornya', pwd = getPassword('CHOPDW'), 
                   server = 'binbiaclv2.chop.edu', db = 'CDWPRD')
```

Now source the pager function, which notifies me that the query is completed:

```{r, message=FALSE, warning=FALSE}
source('F_pageXDS.r')
```

## Example SQL

The flowsheets are linked in a complex manner to the patient's VISIT_KEY, the key to the visit.  For each calendar day there is a particular `FLOWSHEET_RECORD` for a `VSI_KEY`, or a `VISIT_STAY_INFO` key.  These `VSI` keys are mapped 1:1 to `VISIT_KEY` in the `VISIT_STAY_INFO` table.  

We first find all `FLOWSHEET_RECORD` rows for the appropriate `VSI_KEY` and the date range of our in-out dates.  We then find the `FLOWSHEET_MEASURE` rows that correspond to this `FS_REC_KEY` from the `FLOWSHEET_RECORD` table.  We find its name and description by linking to the `FLOWSHEET` table, and we limit by linking to `FLOWSHEET_TEMPLATE` (the header title across the top of the Flowsheet activity) which corresponds to PICU vital signs.  We will use a very similar procedure for gathering fluid administered.

Below is an example SQL query for a given `VISIT_KEY` (which is not PHI because it is generated by the CDW on ETL):

```
SELECT 
    fs.DISP_NM
	,fs.FS_UNIT
	,fs.FS_KEY
	,fs_meas.MEAS_VAL
	,fs_meas.MEAS_VAL_NUM
	,fs_meas.SEQ_NUM
	,fs_rec.FS_REC_DT
	,fs_rec.FS_REC_KEY
	,fs_temp.FS_TEMP_NM
	,fs_temp.FS_TEMP_ID
	,fs_meas.REC_DT
	,fs_meas.ENTRY_DT
FROM 
	CDW.FLOWSHEET_MEASURE fs_meas
	JOIN CDW.FLOWSHEET fs ON fs_meas.FS_KEY = fs.FS_KEY
    JOIN CDW.FLOWSHEET_RECORD fs_rec ON fs_meas.FS_REC_KEY = fs_rec.FS_REC_KEY
	JOIN CDW.FLOWSHEET_TEMPLATE fs_temp ON fs_meas.FS_TEMP_KEY = fs_temp.FS_TEMP_KEY
    JOIN CDW.VISIT_STAY_INFO vsi ON vsi.VSI_KEY = fs_rec.VSI_KEY
WHERE 
  vsi.VISIT_KEY = 82674464
  AND DATE(fs_rec.FS_REC_DT) >= DATE('2014-08-18 17:39:00')
  AND DATE(fs_rec.FS_REC_DT) <= DATE('2014-08-19 22:16:00')
  AND fs_temp.FS_TEMP_ID IN (40060000) -- VS PICU
ORDER BY fs_rec.FS_REC_DT, fs_meas.SEQ_NUM
```

## Define Query 

Now we will append this to the end of our cohort definition, to bring everything together:

```{r}
query <- strwrap(paste(
"WITH
cohort AS (
SELECT 
  DISTINCT vis_evnt.VISIT_KEY
FROM 
  CDW.VISIT_EVENT vis_evnt  
    INNER JOIN CDW.CDW_DICTIONARY event_type ON vis_evnt.DICT_ADT_EVENT_KEY = event_type.dict_key
        AND event_type.src_id IN (1,2,3,4,6) 
    INNER JOIN CDW.CDW_DICTIONARY event_sub_type ON vis_evnt.DICT_EVENT_SUBTYPE_KEY = event_sub_type.dict_key
        AND event_sub_type.src_id <> 2 
    INNER JOIN CDW.DEPARTMENT dept ON vis_evnt.DEPT_KEY = dept.DEPT_KEY
WHERE 
  dept.DEPT_ID IN (34, 43, 123, 36) 
  AND vis_evnt.VISIT_KEY NOT IN (-1, 0)
  AND vis_evnt.PAT_KEY NOT IN (0)
  AND vis_evnt.EFF_EVENT_DT BETWEEN DATE('07/01/2012') AND DATE('07/01/2017')
),
all_adt AS (
SELECT
  vis_evnt.VISIT_KEY,
  vis_evnt.VISIT_EVENT_KEY,
  pat.DOB AS PAT_DOB,
  pat.SEX AS PAT_SEX,
  vis_evnt.EFF_EVENT_DT as IN_DT,
  event_type.DICT_NM AS EVENT_TYPE,
  CASE WHEN event_type.src_id IN (1,3) THEN 1 
       WHEN event_type.src_id IN (2,4) THEN 0 
	   END AS EVENT_DIR,
  dept.DEPT_NM as d_name,
  dept.DEPT_KEY AS d_key,
  CASE WHEN dept.DEPT_ID IN (34,43,123) THEN 1 
       WHEN dept.DEPT_ID IN (36) THEN 2 
	   WHEN dept.DEPT_ID IN (101001069,58,66) THEN 3 
	   ELSE 0 
	   END AS dept_grp,
  bed.BED_NM AS bed_name,
  vis_evnt.PAT_KEY,
  dict_svc.DICT_NM AS PAT_SVC
FROM 
  cohort
    INNER JOIN CDW.VISIT_EVENT vis_evnt ON cohort.VISIT_KEY = vis_evnt.VISIT_KEY
    INNER JOIN CDW.PATIENT pat ON pat.PAT_KEY = vis_evnt.PAT_KEY
    INNER JOIN CDW.CDW_DICTIONARY event_type ON vis_evnt.DICT_ADT_EVENT_KEY = event_type.dict_key
        AND event_type.src_id IN (1,2,3,4) 
    INNER JOIN CDW.CDW_DICTIONARY event_sub_type ON vis_evnt.DICT_EVENT_SUBTYPE_KEY = event_sub_type.dict_key
        AND event_sub_type.src_id <> 2 
    INNER JOIN CDW.CDW_DICTIONARY dict_svc ON dict_svc.DICT_KEY = vis_evnt.DICT_PAT_SVC_KEY
    INNER JOIN CDW.DEPARTMENT dept ON vis_evnt.DEPT_KEY = dept.DEPT_KEY
    INNER JOIN CDW.MASTER_BED bed ON vis_evnt.BED_KEY = bed.BED_KEY
),
remv_periop AS (
SELECT 
  *,
  FIRST_VALUE(in_dt) OVER (PARTITION BY visit_key ORDER BY in_dt) AS HOSP_ADMIT_DT,
  FIRST_VALUE(in_dt) OVER (PARTITION BY visit_key ORDER BY in_dt DESC) AS HOSP_DC_DT,
  CASE WHEN (LAG(dept_grp) OVER (PARTITION BY visit_key ORDER BY in_dt,event_dir) IN (3) AND 
             dept_grp IN (3) AND
			 LAG(event_type) OVER (PARTITION BY visit_key ORDER BY in_dt,event_dir) IN ('Transfer In') AND
			 event_type IN ('Transfer Out')) OR 
			(LEAD(dept_grp) OVER (PARTITION BY visit_key ORDER BY in_dt,event_dir) IN (3) AND 
             dept_grp IN (3) AND
			 LEAD(event_type) OVER (PARTITION BY visit_key ORDER BY in_dt,event_dir) IN ('Transfer Out') AND
			 event_type IN ('Transfer In')) THEN 'Y' END AS out_periop
FROM all_adt
),
same_dept AS (
SELECT 
  *,
  CASE WHEN LAG(dept_grp) OVER (PARTITION BY visit_key ORDER BY in_dt,event_dir) IN (dept_grp) THEN 'Y' END AS same_dept
FROM remv_periop
WHERE out_periop IS NULL
),
visit_dt_set AS (
SELECT 
  *,
  CASE WHEN SAME_DEPT IS NULL THEN IN_DT END AS VISIT_IN_DT,
  CASE WHEN LEAD(SAME_DEPT) OVER (PARTITION BY visit_key ORDER BY in_dt,event_dir) IS NULL THEN IN_DT END AS VISIT_OUT_DT
FROM same_dept
WHERE DEPT_GRP IN (1,2)
),
comb_lines AS (
SELECT
  *,
  CASE WHEN VISIT_OUT_DT IS NULL THEN LEAD(VISIT_OUT_DT) OVER (PARTITION BY visit_key ORDER BY in_dt,event_dir) END AS OUT_DT
FROM visit_dt_set
WHERE VISIT_IN_DT IS NOT NULL OR VISIT_OUT_DT IS NOT NULL
),
final_cohort AS (
SELECT 
  VISIT_KEY,
  PAT_KEY,
  PAT_SVC,
  PAT_DOB,
  PAT_SEX,
  CASE WHEN DEPT_GRP = 1 THEN 'PICU'
       WHEN DEPT_GRP = 2 THEN 'CICU' END AS DEPT,
  VISIT_IN_DT AS IN_DT,
  OUT_DT,
  HOSP_ADMIT_DT,
  HOSP_DC_DT
FROM comb_lines
WHERE VISIT_IN_DT IS NOT NULL AND OUT_DT IS NOT NULL
),
cohort_vsi AS (
SELECT
  final_cohort.*
  ,vsi.VSI_KEY
FROM
  final_cohort
    JOIN CDW.VISIT_STAY_INFO vsi ON final_cohort.VISIT_KEY = vsi.VISIT_KEY
)
SELECT
  cohort_vsi.VISIT_KEY
  ,cohort_vsi.IN_DT
  ,cohort_vsi.OUT_DT
  ,fs.DISP_NM
	,fs_meas.MEAS_VAL
	,fs_meas.SEQ_NUM
	,fs_rec.FS_REC_DT
	,fs_meas.REC_DT
	,fs_meas.ENTRY_DT
FROM 
  cohort_vsi
	JOIN CDW.FLOWSHEET_RECORD fs_rec ON fs_rec.VSI_KEY = cohort_vsi.VSI_KEY AND
      DATE(fs_rec.FS_REC_DT) >= DATE(cohort_vsi.IN_DT) AND
      DATE(fs_rec.FS_REC_DT) <= DATE(cohort_vsi.OUT_DT)
  JOIN CDW.FLOWSHEET_MEASURE fs_meas ON fs_meas.FS_REC_KEY = fs_rec.FS_REC_KEY 
	JOIN CDW.FLOWSHEET fs ON fs_meas.FS_KEY = fs.FS_KEY
	JOIN CDW.FLOWSHEET_TEMPLATE fs_temp ON fs_meas.FS_TEMP_KEY = fs_temp.FS_TEMP_KEY AND
      fs_temp.FS_TEMP_ID IN (40060000)
ORDER BY cohort_vsi.VISIT_KEY, cohort_vsi.IN_DT,fs_rec.FS_REC_DT, fs_meas.SEQ_NUM",                 
  sep="\n"), width=1000000)
```

# Execute Query 

Now we run the query, after defining the 'as.is' vector which specifies the columns to leave unconverted (the date-time columns).  This query will take >4 hours to run and should return >25 million flowsheet rows.

```{r}
as.is <- rep(F,9)
as.is[c(2,3,7,8,9)] <- T

# Execute the query from the database
tic <- proc.time()
vs.df <- sqlQuery(nzConn, query, 
                  believeNRows=TRUE, 
                  stringsAsFactors=FALSE,
                  as.is = as.is)
toc <- proc.time() - tic

save(vs.df, file='D_vs_df')

# Print stats
cat(sprintf('Elapsed time (hrs): %0.2f\n',
            toc[3]/60/60))

cat(sprintf('Number of flowsheet rows returned: %0.f\n',
            nrow(vs.df)))

# And page to notify that we are done
pageMe(profileID = 'E7582503', msg='Finished gathering VS!', displayResult = F)
```

