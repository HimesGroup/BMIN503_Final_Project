---
title: 'Gene expression predictors of response to preoperative chemoradiotherapy for rectal cancer'
author: 'Jahan Mohiuddin)'
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: TRUE
    depth: 3
editor_options: 
  chunk_output_type: console
---

***
### Overview
In this section, give a brief a description of your project and its goal, what data you are using to complete it, and what three faculty/staff in different fields you have spoken to about your project with a brief summary of what you learned from each person. Include a link to your final project GitHub repository.

I am doing a secondary analysis of gene expression data from tumor biopsy samples in a study of patients with rectal cancer. The dataset includes basic clinical covariates and recurrence data. I will determine what gene expression is associated with recurrence, and also perform gene set enrichment analysis to determine whether any pathways are up- or down-regulated after treatment with anti-PDL1 monoclonal antibody.


### Introduction 

The standard of care for stage III rectal cancer is combination chemoradiation followed by surgical resection of the primary tumor and lymph nodes. There is interest in developing predictive tools that can predict which patients will have a complete response to chemoradiation and could potentially avoid surgery, which would leave the patient with a colostomy bag. 

Traditional clinical factors such as demographic variables, stage, etc are not sufficient to predict which patients will have good responses to chemoradiation, so investigators are focusing on radiomics and genomics to develop predictive models. These are collaborative studies between radiation oncologists, radiologists, and bioinformaticians. I met several times with Mengyuan Kan, who taught me about the RAVED pipeline she developed and how I can adapt it to my chosen data set. 

### Methods
In the first paragraph, describe the data used and general methodological approach. Subsequently, incorporate full R code necessary to retrieve and clean data, and perform analysis. Be sure to include a description of code so that others (including your future self) can understand what you are doing and why. 

I used publicly available gene expression and phenotype data from [GEO](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE35452). This study by Watanabe et al. obtained biopsies of the primary tumor for 46 patients with stage III rectal cancer, administered pre-operative chemoradiation, and then resected the primary tumors.  Patients were labeled as "Responders" if they had a complete or near-complete pathological response according to a classification system by the Japanese Society for Cancer of the Colon and Rectum. There was no other clinical data included in the dataset.

QC and analysis scripts for differential expression were adapted from the RAVED pipeline [PubMed](https://www.ncbi.nlm.nih.gov/pubmed/30815178).

***

This report shows the QC steps for gene expression microarry data from GEO study, including:

* GEO data download
* Phenotype file preparation
* Quality control metrics measurement and outlier detection

Manually define the variables used in the RAVED pipeline

```{r var, eval=T, echo=T}
# GEO id
geo_id="GSE35452" 
GPL_ID="GPL570"
# directory stores GEO data
datadir="C:/Users/jahan/Desktop/GSE35452"
# directory stores generated files
resdir="C:/Users/jahan/Desktop/GSE35452"
```

```{r var2, eval=T, echo=T}
#platform="Affymetrix" #Try changing to Illumina
platform="Affymetrix"
geo_GPL=""
normdata=FALSE 
suppldata=TRUE
paired=FALSE
usesuppl=TRUE
# The shortname_func function shortens the sample name shown in the plots. To start, define shortname_func <- function(x){x}
shortname_func <- function(x){gsub("^(.*)\\.(cel|CEL).gz","\\1",x)}
```


Load the necessary libraries. Load affy and dplyr packages later since they will mask other functions.

```{r lib, eval=T, echo=F, message=F, warning=F}
if (grepl("^GSE", geo_id)) {
  library(GEOquery); geo=TRUE; arrayexpr=FALSE} else if (grepl("^E-", geo_id)) {
  library(ArrayExpress); geo=FALSE; arrayexpr=TRUE
}
library(knitr)
library(oligo)
library(viridis) # heatmap colour
library(ggplot2)
library(gplots) # heatmap.2 plot
library(Hmisc) # compute hoeffd (Hoeffding's D statistics) for MA plot
library(devtools) # compuate PCs
library(preprocessCore) # quantile normalization
library(pander)
library(limma)
library(sva)
library(annotate)
library(DT)
library(fgsea)
```

## GEO/ArrayExpress Data Download and Phenotype Preparation

```{r, eval=geo, echo=F}
knitr::asis_output("### GEO Dataset Download")
```

```{r, eval=geo, echo=F}
knitr::asis_output("Download GEO series matrix files if available.")
```

```{r geo_download, eval=geo, echo=F, message=F, warning=F}

  # check if GEO matrix file exists
  geo_fn <- list.files(path=datadir)[grepl(geo_id,list.files(path=datadir))&grepl("matrix.txt.gz$",list.files(path=datadir))] # check if GEO matrix file exists
  if (length(geo_fn)==0) { # GEO matrix file is not downloaded
    gselms <- getGEO(geo_id, destdir=datadir, GSEMatrix = TRUE) # dowanload matrix file
    gse <- gselms[[1]]
  } else if (length(geo_fn)==1) { # GEO matrix file is alreadly downloaded and only has one platform
    gse <- getGEO(filename=paste0(datadir,"/",geo_fn),GSEMatrix = TRUE)
  } 

```


#### Phenotype information modification

**This step requires mannual inspection.**

These columns are required: GEO_ID, Patient, Disease, Response. Column naming is rigid for these columns, because pipeline scripts will recognize these name strings.

```{r pheno_new, eval=T, echo=T, message=F, warning=F, results="hide"}
library(dplyr)
pheno.raw=pData(gse)
cols <- c("title","geo_accession","source_name_ch1","response to preoperative chemoradiotherapy:ch1")
pheno <- pheno.raw %>%
            dplyr::select(cols) %>%
            dplyr::rename(Response="response to preoperative chemoradiotherapy:ch1") %>%
            dplyr::mutate(Patient=seq(1:nrow(pheno.raw)),
                          Response=ifelse(Response=="Non-responder","Nonresponder","Responder"),
                          Disease="Rectal_cancer",
                          Tissue="Tumor",
                          Response=factor(Response),
                           GEO_ID=geo_accession)
            
            

pheno$Response[pheno$Response=="Non-responder"]=factor("Nonresponder")
pData(gse)=dplyr::rename(pData(gse),Response='response to preoperative chemoradiotherapy:ch1')
pData(gse)$Response[pData(gse)$Response=='Non-responder']='Nonresponder'
detach("package:dplyr")
```



### Raw intensity data download and define RAVED pipeline functions

Download supplementary raw data files.

```{r suppl_download, eval=T, echo=F}

celFiles <- list.celfiles(paste0(datadir,"/data"), full.names = TRUE, listGzipped = TRUE)
raw.data <- read.celfiles(celFiles)

# The suppdownload_func function downloads the supplimentary raw data files from GEO and extract the zip file

# If supplementary data is available, download supplimentary raw data files

  # The sampall_func function obtains the supplementary filenames of all samples of interest
  sampall_func <- function() {
    if (geo) {basename(as.character(pheno.raw$supplementary_file))}
    else if (arrayexpr) {{basename(as.character(pheno.raw$Array.Data.File))}}
  }

  # The existall_func function check whether all supplementary files in GEO phenotype exist in the data directory
  existall_func <- function() {
    raw_fn=list.files(path=paste0(datadir,"/",geo_id,"/data"))
    # check if all supplementary_file name from GEO phenotype are within the downloaded folder
    return(all(sapply(sampall_func(),function(x)x%in%raw_fn)))
  }

  # The rawall_func function obtains all files in the data directory with full path
  rawall_func <- function() {
    raw_fn=list.files(path=paste0(datadir,"/",geo_id,"/data"))
    # obtain supplementary data with path
    paste0(datadir,"/",geo_id,"/data/",raw_fn[which(raw_fn%in%sampall_func())]) # only select cel files from datadir
  }

   samp_exist=existall_func()

```


Assign phenotype data from gse object to raw data object.

```{r pData_assign, eval=T, echo=F}
# assign phenotype data to raw expression data
pheno <- pheno[order(pheno$GEO_ID),] # if using supplementary data, order pheno object by GEO_ID, because the files are loaded by this order
pData(raw.data) <- pheno
row.names(pData(raw.data)) <- sampleNames(protocolData(raw.data))
# Check if the sample names derived from expression data match those in phenotype file
rowname <- gsub("^(.*).(cel|CEL|txt|Txt).gz","\\1",row.names(pData(raw.data)))
```

Retrieve scan date information from raw.data object for batch effect adjustment. For Affymetrix data, scan date information is imported by oligo with raw data files.

```{r scandate, eval=T, echo=F, message=F, warning=F, results="hide"}

  # As the scan date and scan time are usually joined by "T" or a white space, use both pattern to split the date with time
  pheno$ScanDate_Group <- sapply(strsplit(as.character(protocolData(raw.data)$dates), "T| "), function(x) {x[[1]]})
  pheno$ScanDate_Group <- sapply(strsplit(pheno$ScanDate_Group,"/"), function(x) {x[3]})
  pheno$ScanDate_Group <- ifelse(pheno$ScanDate_Group=='06','2006',ifelse(pheno$ScanDate_Group=='07','2007',ifelse(pheno$ScanDate_Group=='08','2008',ifelse(pheno$ScanDate_Group=='09','2009',NA))))
  
pheno$ScanDate_Group <- as.factor(pheno$ScanDate_Group)

pData(raw.data) <- pheno # update pData
row.names(pData(raw.data)) <- sampleNames(protocolData(raw.data))
```

Show the summary of phenotype variables and the sample size for different groups

```{r pheno_check_raw, eval=T, warning=F,results="asis",echo=F}
# show the groups of interest
avail_group=c("Tissue","Disease","Response")[c("Tissue","Disease","Response")%in%names(pheno)]
res=as.data.frame(table(pheno[,avail_group]))
names(res) <- c(avail_group,"Count")
pandoc.table(res[which(res$Count>0),], split.tables=Inf, caption="Sample size in different tissue and disease/Response groups")
# show samples in different batch
res=as.data.frame(table(droplevels(pheno[,"ScanDate_Group"])))
names(res) <- c("ScanDate_Group","Count")
pandoc.table(res, split.tables=Inf, caption="Sample size in different batch")

```

Assign colors to scan date or disease/Response if scan date is not available.

```{r usrdefine_utility, eval=T, echo=F}
# assign colours to Scan Date for plots
colours=c("#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666", "#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#CCEBC5", "#FFED6F") # first 8 colour names derived from Dark2, and last 12 names from Set3

# assign colour to corresponding variable (scan date if available otherwise disease/Response)
colour_list <- colours[1:4]
names(colour_list) <- levels(pheno[,"ScanDate_Group"]) 
varuse<-"ScanDate_Group"
```

If negative/zero intensity values are present, convert them to NAs.

```{r infinite_convert, eval=T, echo=F, fig.height=10, fig.width=12}
exprs(raw.data)=apply(exprs(raw.data),2,function(x){replace(x,which(x<=0),NA)})
```

Write the phenotype data set to .txt format for storage

```{r pheno_withoutQC, eval=T, warning=F, echo=F}
pheno_fn_withoutQC=paste0(resdir,"/",geo_id,"_Phenotype_withoutQC.txt")
pheno_fn_withQC=paste0(resdir,"/",geo_id,"_Phenotype_withQC.txt")
write.table(pheno,pheno_fn_withoutQC,col.names=T,row.names=F,sep="\t",quote=F)
```


## Quality Control for Microarray Data

The major QC steps and scoring methods for outliers were adapted from [arrayQualityMetrics](https://bioconductor.org/packages/release/bioc/html/arrayQualityMetrics.html). The threshold to determine an outlier used in arrayQualityMetrics is the boxplot's upper whisker, i.e. values beyond 1.5 times the interquartile range, which is also applied to our pipeline. The following QC metrics are included in a routine analysis. The QC metrics used for outlier detection are marked with an asterisk.

* Boxplots and density plots for raw probe intensities*
* RNA degradation plots
* Density plots for perfect match (PM) and mismatch (MM) probe
* MA plots*
* Spatial plots*
* Boxplots for the normalized unscaled standard error (NUSE)*
* Boxplots for the relative log expression (RLE)*
* Heatmap and dendrogram for distance between arrays*
* Principal component analysis (PCA) plots


### Raw Probe Intensity Boxplots and Density Histograms

The log2-transformed/normalized intensity distributions of all samples (arrays) are expected to have the similar scale (i.e. the similar positions and widths of the boxes). Outlier detection is applied by computing a Kolmogorov-Smirnov statistic (Ka) between log-intensity distribution for one array and the pooled array data, where an array with a Ka beyond the upper whisker is designated as an outlier.


```{r raw_intensity_utility, eval=T, echo=F, warning=F}
# The subsamp function randomly selects 20000 probes
subsamp <- function(x,num=20000, seed=123) {
  set.seed(seed)
  subsample=num # if number of probes are >20000, randomly select 20000 probes for plot or compute
  if (nrow(x)>subsample) {
    ss  = sample(nrow(x), subsample)
    Mss = x[ss,,drop=FALSE]
  } else {
    ss  = TRUE
    Mss = x
  }
  Mss
}

# The outlier_KS_func function computes KS statistics for outlier detection
outlier_KS_func = function(exprs) { # matrix (row: probe intensities/RLE values etc., col: array (e.g. sample))
  fx = ecdf(as.vector(exprs)) # get empirical cumulative distribution function of the data
  KS=suppressWarnings(apply(exprs, 2, function(v)ks.test(v, y = fx, alternative="two.sided")$statistic))
  stats = stats::fivenum(KS, na.rm = TRUE) # Tukey's five number summary (minimum, lower-hinge, median, upper-hinge, maximum)
  iqr = diff(stats[c(2, 4)]) # lagged difference between the lower-hinge and upper-hinge
  coef = 1.5
  th = (stats[4] + coef * iqr)
  list(threshold = th, stats=KS, outlier = which(KS > th))
}

# The boxplot_func function generates boxplots for raw data metrics (e.g. probe intensities, RLE, NUSE) 
boxplot_func <- function(Mss,outlier,ylab) {
  # use * to mark the outliers in boxplot
  array_name <- shortname_func(colnames(Mss))
  outlier <- shortname_func(outlier)
  array_name[array_name%in%outlier] <- paste0("*",outlier)
  # boxplot raw intensity by array
  ylim = quantile(Mss, probs = c(0.01, 0.99), na.rm=TRUE) # create range of y-axsis
  # create data frame for plot
  df <- data.frame(
    sample_id=rep(colnames(Mss),each=nrow(Mss)),
    values=as.numeric(Mss),
    scandate=rep(pData(raw.data)[,varuse],each=nrow(Mss)) # for color
  )
  cols <- colour_list
  ggplot(df, aes(sample_id,values,fill=scandate)) + geom_boxplot(outlier.colour=NA) +
    coord_flip() + theme_bw() +
    ylim(ylim) +
    scale_x_discrete(labels=array_name) +
    ylab(ylab) +
    scale_fill_manual(varuse,values=cols) +
    theme(axis.title.y=element_blank())
}

# The densplot_func function plots density curve for raw data metrics (e.g. probe intensity)
densplot_func <- function(Mss) {
  # create data frame for plot
  df <- data.frame(
    sample_id=rep(colnames(Mss),each=nrow(Mss)),
    values=as.numeric(Mss),
    scandate=rep(pData(raw.data)[,varuse],each=nrow(Mss)) # for color
  )
  cols <- colour_list
  ggplot(df,aes(x=values,colour=scandate)) + geom_line(aes(group=sample_id),stat="density") +
    theme_bw() +
    xlab("Raw Probe Intensities") +
    ylab("Density") +
    scale_color_manual(varuse,values=cols)
}

# The raw_intensity_func function outputs raw probe intensity metrics
raw_intensity_func <- function() {
  if (!normdata) {Mss=log2(subsamp(exprs(raw.data))) # use log2 transformed raw probe intensity
  } else {
    Mss=subsamp(exprs(raw.data))
  }
  outlier_res=outlier_KS_func(Mss)
  outlier=names(outlier_res$outlier)
  boxplot=boxplot_func(Mss=Mss, outlier=outlier, ylab="Raw Probe Intensities")
  densplot=densplot_func(Mss=Mss)
  return(list(outlier=outlier,boxplot=boxplot,densplot=densplot))
}
```

1. Outlier detection for log2 raw probe intensity/normalized intensity

Compute the Kolmogorov-Smirnov statistic Ka between each array's (i.e. sample) values (i.e. log2 transformed raw probe intensity values) and the 
pooled, overall distribution of the values.

```{r raw_intensity_outlier, eval=T, echo=F, warning=F}
res_intensity=raw_intensity_func()
outlier_intensity = res_intensity$outlier
cat(length(outlier_intensity), "outlier(s) are detected in the raw intensity metrics.\n")
if (length(outlier_intensity)>0) {cat("They are: ", shortname_func(outlier_intensity))}
```

2. Boxplots for log2 raw probe intensity

```{r raw_intensity_boxplot, eval=T, echo=F, message=F, warning=F, fig.height=8, fig.width=6}
res_intensity$boxplot
```

3. Density curves for log2 raw probe intensity

The intensity curves of all samples (arrays) are expected to have the similar shapes and ranges. Samples with deviated curves are likely to have problematic experiments. For example, high levels of background will shift an array's distribution to the right. Lack of signal diminishes its right right tail. A bulge at the upper end of the intensity range often indicates signal saturation.

```{r raw_intensity_densplot, eval=T, echo=F, message=F, warning=F}
res_intensity$densplot
```

### RNA Digestion


Overall RNA quality can be assessed by RNA degradation plots. In the gene expression array, each probe is represented by a probe set. Each probe set is 11-20 probes (pairs of oligos). This plot shows the average intensity of each probe across all probe sets, ordered from the 5' to the 3' end. It is expected that probe intensities are lower at the 5' end of a probe set when compared to the 3' end as RNA degradation starts from the 5' end of a molecule. RNA which is too degraded will shows a very high slope from 5' to 3'. Thus, the standardized slope of the RNA degradation plot serves as quantitative indicator of the RNA degradation. 


```{r RNAdegaffy_utility, eval=T, echo=F}
# The RNAdegaffy_func function compute mean PM intensities in each probe position following 5' to 3' order. Adopted from the AffyRNAdeg function in the affy package but include a step that randomly selects 20,000 probe sets.
RNAdegaffy_func <- function(data){ # input a list of probe set matrix with rows as probe ids and columns as samples
  {
    names <- colnames(data[[1]])
    probe.set.size <- function(x) {
      size <- dim(x)[1]
      return(size)
    }
    max.num <- sapply(data, probe.set.size) # get the number of probes in each probe set
    tab <- (table(max.num)) # summarize the frequencies of probe numbers in probe sets
    ord <- order(-as.numeric(tab)) # order the frequency from large to small
    K <- as.numeric(names(tab))[ord[1]] # K is the number of probes appearing in most probe sets
    data <- data[max.num == K] # select data of probe sets only have K number of probes
  }
  
  subsample=20000
  if (length(data)>subsample) { # randomly select 10000 probe sets
    set.seed(12345)
    ss = sample(length(data),subsample)
    data = data[ss,drop=FALSE]
  }

  N <- length(data) # number of probe sets
  n <- dim(data[[1]])[2] # number of samples
  
  # create two matrices: number of samples * number of probes representing a probe set
  mns <- matrix(nrow = n, ncol = K) # create matrix for mean values
  sds <- mns # create matrix for sds values

  get.row <- function(x, i = 1) {return(x[i, ])} # function to get each row (i.e. probe id, i) from one probe set x (i.e. probe list[[x]])
  rowstack <- function(x, i = 1) {return(t(sapply(x, get.row, i)))} # function to combine the rows obtained using get.row (pms across samples by probe sets) to get a table (row: samples column: probe sets) and transpose the table (row: probe sets, column: samples)

  for (i in 1:K) { # get probe id (position) from 1 to K from each probe set
    data.stack <- rowstack(data, i) # get the probe pm values in a specific probe position across all samples from each probe set (rows are samples and columns are probe sets)
    if(dim(data[[1]])[2]==1) data.stack <- t(data.stack)
    mns[, i] <- colMeans(data.stack) # get the mean values at one probe position across all probe sets
    sds[, i] <- apply(data.stack, 2, sd) # get the sd values at one probe position across all probe sets
  }
    
  mns.orig <- mns # store the original mns data matrix
  mn <- mns[, 1] # select values in the first probe position
  mns <- sweep(mns, 1, mn) # adjust for the intensity at the first probe position
  mns <- mns/(sds/sqrt(N)) # adjust for standard error
  lm.stats <- function(x) {
    index <- 0:(length(x) - 1)
    ans <- summary(lm(x ~ index))$coefficients[2, c(1, 4)] # use linear model fit the relationship between intensity and probe position
    return(ans)
  }
  stats <- apply(mns, 1, lm.stats)
  answer <- list(N, names, mns.orig, sds/sqrt(N), stats[1,], stats[2, ])
  names(answer) <- c("N", "sample.names", "means.by.number","ses", "slope", "pvalue")
  return(answer)
}

# The RNAdeg_func function generates RNA degradation plots
# return a logical variable whether this array type can be read by affy.
RNAdeg_func <- function() {
  # 1. Read in raw data as an AffyBatch object
  library(affy) # for Affymetrix microarray-specific QC analysis
  raw.data.affy <- read.affybatch(rawall_func(),compress=T)
  # 2. Obtain a list of probe sets with a matrix of oligos (probes) by samples as an input and compute statistics of the mean PM intensities from 5' to 3' probe positions. 
  PM_list <- affy::pm(raw.data.affy,LIST=T) 
  PM_list <- lapply(PM_list,log2)
  raw.data.rnadeg <- RNAdegaffy_func(PM_list) # Compute mean PM intensity for probes following 5' to 3' order.
  # 3. Plot 5' to 3' mean PM intensity
  status.cols <- unlist(lapply(pData(raw.data)[,varuse],function(x)colour_list[x])) # colour list to corresponding scan date list
  plotAffyRNAdeg(raw.data.rnadeg,cols=status.cols)
  legend("topleft",legend=names(colour_list),fill=colour_list,cex=0.6)
  detach("package:affy", unload=TRUE) # detach the affy package
}
```

```{r RNAdeg_plot, eval=T, echo=F, message=F, warning=F}
RNAdeg_func()
```

### Distribution of Perfect Match (PM) and Mismatch (MM)

There are two paired probe types: perfect match (PM) and of mismatched (MM) probes. A PM probe matches a strand of cDNA, while the corresponding MM probe differs from the PM by a change in the central nucleotide. A probe set is called present if the intensity value of PM is significantly larger than MM. However, the Affymetrix approach is under attack because between 15%-30% of the MM are greater than the PM. For some newer arrays, MM probes are not used. If the number of PMs is not equal to that of MMs, this might be a PM-only array.

If both PM and MM are present, the density curves of log2 PM and MM intensities are generated, where MM probes are expected to have smaller log2-intensity at the peak than PM probes due to their nonspecific hybridization.

```{r PMMM_utility, eval=T, echo=F}
PMMM_func <- function() {
  if (class(raw.data)=="GeneFeatureSet") {
    message("GeneFeatureSet does not have MM probes. No plots will be generated.")
  } else {
    PM <- log2(pm(raw.data))
    MM <- log2(mm(raw.data))
    if(nrow(PM) != nrow(MM)) {
      message("This might be a PM-only array. No plots will be generated.")
      rm(PM,MM)
    } else {
      subsample=20000
      if(nrow(PM)>subsample) { # randomly select 20000 probe sets
        sel = sample(nrow(PM), subsample)
        sPM = PM[sel, ]
        sMM = MM[sel, ]
      } else {
        sPM = PM
        sMM = MM
      }
      rm(PM,MM) 
      
      df <- data.frame(
        values=c(as.numeric(sPM),as.numeric(sMM)),
        types=c(rep("PM",each=length(as.numeric(sPM))),rep("MM",each=length(as.numeric(sMM))))
      )
      cols=colours[1:2]
      ggplot(df,aes(x=values,colour=types)) + geom_line(aes(group=types),stat="density") +
        theme_bw() +
        xlab("Intensity") +
        ylab("Density") +
        scale_color_manual(values=cols) +
        theme(legend.title=element_blank())
    }
  }
}
```

```{r PMMM_plot, eval=T, echo=F}
PMMM_func()
```

### MA Plots
MA plots allow pairwise comparison of the log-intensity of each array to a reference array and identification of intensity-dependent biases.

The y-axis of the MA-plot shows the log-ratio intensity of one array to the reference median array, which is called M (minus). M = log2(I1)-log2(I2) (I1: the intensity of the array studied; I2: the median intensity across arrays)

The x-axis indicates the average log-intensity of both arrays, which is called A (add). A = 1/2\*(log2(I1)+log2(I2))

It is expected that the probe levels do not differ systematically within a group of replicates, so that the MA-plot is centered on the y-axis (y=0 or M=0) from low to high intensities.

```{r MA_utility, eval=T, echo=F}
# The MAcal_func function computes M and A matrices, while use the intensity of 20000 randomly selected probes
MAcal_func <- function(x) { # matrix (row: probe intensities, col: array (samples)
  medArray = rowMedians(x, na.rm=TRUE)
  M =  x - medArray
  A = (x + medArray)/2
  subsample=20000
  if(nrow(M)>subsample) {
    set.seed(12345)
    sel = sample(nrow(M), subsample)
    sM = M[sel, ]
    sA = A[sel, ]
  } else {
    sM = M
    sA = A
  }
  list(M=sM,A=sA) # return a list with M and A data matrices
}

# The outlier_MA_func function computes the Hoeffding's statistic (Da) statistics for outlier detection
outlier_MA_func <- function(exprs) { # list with M and A data matrices
  M=exprs$M
  A=exprs$A
  Dstats = sapply(1:ncol(M), function(x){hoeffd(A[,x], M[,x])$D[1,2]})
  names(Dstats) <- colnames(M)
  Dthresh = 0.15
  list(threshold=Dthresh, stats=Dstats, outlier = which(Dstats > Dthresh))
}

# The MAplot_func function plots samples with the first 4 highest and lowest values of Da. The value of Da for each sample is shown in the panel headings. Outliers marked with * have Da values >0.15.
MAplot_func <- function(sMA, outlier_res) {
# select arrays with top 4 highest and lowest Da
  stats_order <- order(outlier_res$stats)
  column_sel <- stats_order[c(1:4,(ncol(sMA$M)-3):ncol(sMA$M))]
  stats_sel <- round(outlier_res$stats[column_sel],2)
  scandate_sel <- pData(raw.data)[,varuse][column_sel]
  M_sel <- sMA$M[,column_sel]
  A_sel <- sMA$A[,column_sel]
  # use * to mark the outliers
  array_name <- shortname_func(colnames(M_sel))
  outlier_MA=shortname_func(names(outlier_res$outlier))
  array_name[array_name%in%outlier_MA] <- paste0("*",array_name[array_name%in%outlier_MA])
  array_name <- paste0(array_name," (D=",stats_sel,")") # add D statistics to corresponding samples
  # create data frame for plot
  df <- data.frame(
    sample_id=rep(array_name,each=nrow(M_sel)),
    scandate=rep(scandate_sel,each=nrow(M_sel)),
    M=as.numeric(M_sel),
    A=as.numeric(A_sel)
  )
  # MA plots
  ggplot(df,aes(x=A,y=M,color=scandate)) + geom_point(alpha=0.1) + theme_bw() +
    scale_color_manual(varuse,values=colour_list) +
    facet_wrap(~sample_id,ncol=2)
}

# The MA_func function outputs MA metrics
MA_func <- function(){
  # Compute M-A metrics
  if (!normdata) {
    sMA <- MAcal_func(log2(exprs(raw.data)))
  } else {
    sMA <- MAcal_func(exprs(raw.data))
  }
  outlier_res <- outlier_MA_func(exprs=sMA)
  outlier <- names(outlier_res$outlier)
  plot <- MAplot_func(sMA=sMA, outlier_res=outlier_res)
  return(list(outlier=outlier, plot=plot))
}
```

1. Outlier detection for MA plots

Outlier detection is applied by computing a Hoeffding's statistic (Da) on the joint distribution of A and M for each array, where an array with a Da >0.15 is designated as an outlier.

```{r MA_outlier, eval=T, echo=F, message=F, warning=F}
res_MA=MA_func()
outlier_MA=res_MA$outlier
cat(length(outlier_MA), "outliers are detected in the MA metrics.\n")
if (length(outlier_MA)>0) {cat("They are: ", shortname_func(outlier_MA))}
```

2. MA plots

MA plots of the samples with the 4 highest and lowest Hoeffding's statistics.

```{r MA_plot, eval=T, echo=F, message=F, warning=F, fig.height=10, fig.width=7}
res_MA$plot
```

### Spatial Distribution

Spatial plots show an artificial colored image of an array's spatial distribution of intensities that indicate spatial variation in an array. Log-intensities of probes are plotted by their corresponding spatial x and y-coordinate in the array and are expected to be uniformly distributed if the array data has good quality. The rank scale is applied for plotting as it has the potential to amplify patterns that are small in amplitude but systematic within an array.


```{r spatial_utility, eval=T, echo=F}
# The affyspatial_func function computes spatial x- and y-coordinate using raw data object classed as AffyBatch
affyspatial_func <- function() {
  library(affy)
  raw.data.affy <- read.affybatch(rawall_func(),compress=T)
  maxc = ncol(raw.data.affy) # number of probes in x-coordinate
  maxr = nrow(raw.data.affy) # number of probes in y-coordinate
  sx = rep(seq_len(maxc), each = maxr) ## spatial x-coordinate
  sy = rep(seq_len(maxr), maxc) ## spatial y-coordinate
  M = log2(affy::exprs(raw.data.affy))
  detach("package:affy", unload=TRUE)
  numArrays = dim(M)[2]
  return(list(M=M,numArrays=numArrays,sx=sx,sy=sy))
}

# The outlier_spatial_func function computes the Fourier coefficients for outlier detection
outlier_spatial_func <- function(affy_spatial_list) {
  sx=affy_spatial_list$sx # spatial x-coordinate
  sy=affy_spatial_list$sy # spatial y-coordinate
  M=affy_spatial_list$M
  numArrays=affy_spatial_list$numArrays
  maxx = max(sx, na.rm=TRUE)
  maxy = max(sy, na.rm=TRUE)
  stat_spatial = numeric(numArrays)
  for(a in seq_len(numArrays)) {
    mat = matrix(NA_real_, nrow=maxy, ncol=maxx)
    mat[cbind(sy, sx) ] = M[, a]
    pg  = fft(mat) ## periodogram, computes the discrete fourier transform
    npg = Re(pg*Conj(pg))
    npg[1,1] = 0 ## drop the constant component
    stat_spatial[a] = sqrt(sum(npg[1:4, 1:4]) / sum(npg)) # low frequency power
  }
  names(stat_spatial)=colnames(M)
  stats = stats::fivenum(stat_spatial, na.rm = TRUE) # Tukey's five number summary (minimum, lower-hinge, median, upper-hinge, maximum)
  iqr = diff(stats[c(2, 4)]) # lagged difference between the lower-hinge and upper-hinge
  coef = 1.5
  th = (stats[4] + coef * iqr)
  list(threshold = th, stats=stat_spatial, outlier = which(stat_spatial > th))
}

# The spatplot_func function plots samples with the first 4 highest and lowest values of Fa. The value of Fa for each sample is shown in the panel headings.
spatplot_func <- function(raw.data.spatial,outlier_res) {
  # select arrays with top 4 highest and lowest Da
  stats_order <- order(outlier_res$stats)
  column_sel <- stats_order[c(1:4,(ncol(raw.data.spatial$M)-3):ncol(raw.data.spatial$M))]
  stats_sel <- round(outlier_res$stats[column_sel],2)
  M_sel <- raw.data.spatial$M[,column_sel]
  # apply rank to expression data
  M_sel = apply(M_sel, 2, rank)
  # use * to mark the outliers
  array_name=shortname_func(colnames(M_sel))
  outlier_spatial=shortname_func(names(outlier_res$outlier))
  array_name[array_name%in%outlier_spatial] <- paste0("*",array_name[array_name%in%outlier_spatial])
  array_name <- paste0(array_name," (F=",stats_sel,")") # add F statistics to corresponding samples
  # create variables for plot
  df <- data.frame(
    sample_id=rep(array_name,each=nrow(M_sel)),
    M=as.numeric(M_sel),
    row=rep(raw.data.spatial$sy,ncol(M_sel)),
    column=rep(raw.data.spatial$sx,ncol(M_sel))
  )
  # spatial distribution plots
  ggplot(df,aes(x=row,y=column,fill=M)) + geom_tile() + 
    theme_bw() +
    xlab("Raw Probe Intensiry in X") + ylab("Raw Probe Intensiry in Y") +
    scale_fill_gradientn(name="Ranked Intensity",colours=viridis(256,option="B")) +
    facet_wrap(~sample_id,ncol=2)
}

# The spatial_func function outputs spatial metrics
spatial_func <- function() {
  raw.data.spatial=affyspatial_func()
  outlier_res=outlier_spatial_func(affy_spatial_list=raw.data.spatial)
  outlier=names(outlier_res$outlier)
  plot=spatplot_func(raw.data.spatial=raw.data.spatial,outlier_res=outlier_res)
  return(list(outlier=outlier,plot=plot))
}
```


1. Outlier detection for spatial plots

Outlier detection is applied by computing a sum of the absolute values of low frequency Fourier coefficients (Fa) across all probe sets for each array, where an array with a Fa beyond the upper whisker is designated as an outlier.

```{r spatial_outlier, eval=T, echo=F, message=F, warning=F}
res_spatial=spatial_func()
outlier_spatial=res_spatial$outlier
cat(length(outlier_spatial), "outlier(s) are detected in the spatial metrics.\n")
```
  
2. Spatial distribution plots

Spatial distribution plots of samples with the 4 highest and lowest values of Fa. The value of Fa for each sample is shown in the panel headings. Outliers marked with * have Fa values of large scale spatial structures.

```{r spatial_plot, eval=T, echo=F, fig.height=10, fig.width=7}
res_spatial$plot
```

### Relative Log Expression (RLE) Distribution

The normalized unscaled standard error (NUSE) and relative log expression (RLE) boxplots indicate probe set homogeneity in one array, where the metrics are derived from a fitted probe level model by the fitProbeLevelModel function (oligo). The RLE plots represent the distribution of the ratio between the log-intensity of a probe set and the median log-intensity of the corresponding probe set across all arrays, expected to be centered near 0, as a log scale is applied. Outlier detection is applied by computing a Kolmogorov-Smirnov statistic (Ra) between RLE distribution for one array and the pooled array data, where an array with a Ra beyond the upper whisker is designated as an outlier 

```{r RLE_utility, eval=T, echo=F, message=F, warning=F}
# The fitPLM_func function generates RLE and NUSE matrices
fitPLM_func <- function(raw.data) {
  exprs(raw.data) <- log2(exprs(raw.data)) # The fitProbeLevelModel function needs ExpressionFeatureSet object as an input. Assign log transformed expression values to a new object
  fitPLM <- fitProbeLevelModel(raw.data)
  # RLE
  M_RLE <- RLE(fitPLM, type="values") # generate RLE matrix
  Mss_RLE <- subsamp(M_RLE,seed=1234) # use the subsamp function to reduce RLE data with randomly selected 20000 probes
  # NUSE
  M_NUSE <- NUSE(fitPLM, type="values") # generate NUSE matrix
  Mss_NUSE <- subsamp(M_NUSE, seed=1234) # use the subsamp function to reduce RLE data with randomly selected 20000 probes
  return(list(Mss_RLE=Mss_RLE,Mss_NUSE=Mss_NUSE))
}
# The RLE_func function outputs RLE metrics
RLE_func <- function(Mss) {
  outlier_res=outlier_KS_func(Mss) # compute KS statistics to detect outliers
  outlier=names(outlier_res$outlier)
  plot=boxplot_func(Mss,outlier,"RLE")
  return(list(outlier=outlier,plot=plot))
}
```

1. Outlier detection for RLE

Compute the Kolmogorov-Smirnov statistic Ra between each array's (i.e. sample) values (i.e. relative log expression values) and the pooled, overall distribution of the values. Detect outliers that are deviated from the threshold.

```{r RLE_outlier, eval=T, echo=F, message=F, warning=F}
fitPLM=fitPLM_func(raw.data)
res_RLE=RLE_func(Mss=fitPLM$Mss_RLE)
outlier_RLE=res_RLE$outlier
```

2. Boxplot for RLE

Use boxplot_func function to plot RLE. Outliers marked with * have values centered away from 0 and/or are more spread out are potentially problematic.

```{r RLE_plot, eval=T, echo=F, message=F, warning=F, fig.height=8, fig.width=6}
res_RLE$plot
```

### Normalized Unscaled Standard Error (NUSE) Outlier Detection and Plots

The NUSE plots show the distribution of normalized standard error estimates, expected to be centered near 1. Outlier detection is applied by computing an upper hinge (Na) across all probe sets for each array, where an array with a Na beyond the upper whisker is designated as an outlier.

```{r NUSE_utility, eval=T, echo=F, message=F, warning=F}
# The function outlier_upperquartile_func function computes upper 75% quantile for outlier detection
outlier_upperquartile_func <- function(exprs) { # matrix (row: NUSE values, col: array (e.g. sample))
  upperquartile = apply(exprs, 2, quantile, na.rm=TRUE, probs=0.75)
  stats = stats::fivenum(upperquartile, na.rm = TRUE) # Tukey's five number summary (minimum, lower-hinge, median, upper-hinge, maximum)
  iqr = diff(stats[c(2, 4)]) # lagged difference between the lower-hinge and upper-hinge
  coef = 1.5
  th = (stats[4] + coef * iqr)
  list(threshold = th, outlier = which(upperquartile > th))
}

# The NUSE_func function outputs the NUSE metrics
NUSE_func <- function(Mss) {
  outlier_res = outlier_upperquartile_func(Mss)
  outlier=names(outlier_res$outlier)
  boxplot=boxplot_func(Mss,outlier,"NUSE")
  return(list(outlier=outlier,boxplot=boxplot))
}
```

1. Outlier detection for NUSE

Compute 75% quantile Na of each array's NUSE values Detect outliers that have larger Na deviated from the threshold.

```{r NUSE_outlier, eval=T, echo=F, message=F, warning=F, results="asis"}

  res_NUSE <- NUSE_func(Mss=fitPLM$Mss_NUSE)
  outlier_NUSE = res_NUSE$outlier # compute upper 75% quantile statistics to detect outliers
  cat(length(outlier_NUSE), "outlier(s) are detected in NUSE metrics.\n")
```

2. Boxplot for NUSE

Use boxplot_func function to plot RLE. Outliers marked with * have values centered away from 0 and/or are more spread out are potentially problematic.

```{r NUSE_plot, eval=T, echo=F, message=F, warning=F, fig.height=8, fig.width=6}
res_NUSE$boxplot
```

### Distance between Samples and Outlier Detection

Distance between arrays is evaluated using mean absolute difference of log-intensity/normalized intensity between each pair of arrays, where the hierarchical tree between arrays is created based on the distance, which is visualized by a heatmap and dendrogram.

The distance d(ab) between two arrays a and b is computed as the mean absolute difference (L1-distance) between the data of the arrays (using the data from all probes without filtering). In the formula (the dist2 function from genefilter package), d(ab) = mean | M(ai) - M(bi) |, where M(ai) is the value of the i-th probe on the a-th array. 

```{r dist_utility, eval=T, echo=F, warning=F}
# The dist2 estimates distance between samples
dist2 <- function (x,fun = function(a, b) mean(abs(a - b), na.rm = TRUE),diagonal = 0) {
  if (!(is.numeric(diagonal) && (length(diagonal) == 1)))
    stop("'diagonal' must be a numeric scalar.")

  if (missing(fun)) {
    res = apply(x, 2, function(w) colMeans(abs(x-w), na.rm=TRUE))
  } else {
    res = matrix(diagonal, ncol = ncol(x), nrow = ncol(x))
    if (ncol(x) >= 2) {
      for (j in 2:ncol(x))
        for (i in 1:(j - 1))
          res[i, j] = res[j, i] = fun(x[, i], x[, j])
    } # if
  } # else
  colnames(res) = rownames(res) = colnames(x)
  return(res)
}

# The outlier_dist_func function computes the sum of all distance of one sample to other samples for outlier detection
outlier_dist_func <- function(exprs) { # matrix (row: distance to each sample, col: array (e.g. sample))
  sum = colSums(exprs, na.rm=TRUE) # sum the total distance
  stats = stats::fivenum(sum, na.rm = TRUE) # Tukey's five number summary (minimum, lower-hinge, median, upper-hinge, maximum)
  iqr = diff(stats[c(2, 4)]) # lagged difference between the lower-hinge and upper-hinge
  coef = 1.5
  th = (stats[4] + coef * iqr)
  list(threshold = th, outlier = which(sum > th))
}

# The displot_func function plots distance between samples
distplot_func <- function(m,outlier) {
  dend = as.dendrogram(hclust(as.dist(m), method = "single"))
  ord = order.dendrogram(dend)
  array_name=shortname_func(colnames(m))
  outlier=shortname_func(outlier)
  array_name[array_name%in%outlier] <- paste0("*",outlier)
  array_name <- shortname_func(array_name) # shorten the sample id
  status.cols <- unlist(lapply(pData(raw.data)[,varuse],function(x)colour_list[x])) # colour list to corresponding scan date list
  heatmap.2(m,Rowv=dend,Colv=dend,
    col=viridis(256, option="B"),ColSideColors=status.cols,RowSideColors=status.cols,
    labCol=array_name,labRow=array_name,
    trace="none",
    margins=c(12,20), # (bottom margin, left margin)
    cexRow = 1,cexCol = 1,
    keysize=1.5,key.title=NA,key.xlab="Dist2",key.ylab="Counts")
  legend("bottomleft",legend=names(colour_list),fill=colour_list,cex=0.6)
}

# The dist_func function outputs distance metrics
dist_func <- function() {
  if (!normdata) {
    m <- dist2(log2(exprs(raw.data)))
  } else {
    m <- dist2(exprs(raw.data))
  }
  
  outlier_res=outlier_dist_func(m)
  outlier=names(outlier_res$outlier)
  return(list(outlier=outlier,m=m))
}
```

1. Outlier detection for sample distance

Outlier detection is applied by computing the sum of the distances of one array to all other arrays (Sa) (Sa=Sum(b)d(ab)), where an array with a Sa beyond the upper whisker is designated as an outlier.

```{r dist_outlier, eval=T, echo=F}
res_dist=dist_func()
outlier_dist=res_dist$outlier
cat(length(outlier_dist), "outlier(s) are detected in sample distance metrics.\n")
```

2. Plot distance between samples
```{r dist_plot, eval=T, echo=F, fig.height=10, fig.width=12}
distplot_func(m=res_dist$m,outlier=res_dist$outlier)
```

### Principal Component Analysis (PCA)

PCA demonstrates information of the expression dataset in a reduced number of dimensions. Clustering and PCA plots enable to assess to what extent arrays resemble each other, and whether this corresponds to the known resemblances of the samples.

```{r pca_utility, eval=T, echo=F}
# The pcastat_func function computes principal components
pcastat_func <- function(raw.data) {
  # obtain original expression data
  if (!normdata) {
    raw.data.pca <- na.omit(log2(exprs(raw.data)))
  } else {
    raw.data.pca <- na.omit(exprs(raw.data))
  } # remove NAs
 
  # As scale function divides by the variance, the probe with the expression sd=0 across samples must be removed.
  sd <- apply(raw.data.pca,1,sd)
  raw.data.pca <- raw.data.pca[!sd==0,]
  # compute pcs
  pca <- prcomp(t(raw.data.pca), retx = TRUE, center = TRUE, scale = TRUE)
  pc <- data.frame(pca$x)
  # compute variance explained by each PC
  vars <- pca$sdev^2
  pcs <- t(pc)
  pvars <- vars*100.0/sum(vars) # proportion of variance (%) explained by each PC
  cumsum_pvars <- cumsum(pvars) # Cumulative Proportion of Variance (%)
  if (nrow(pcs)>10) {nres <- 10} else {nres=nrow(pcs)} # select top 10 PCs if number of PCs >10
  res <- data.frame(rownames(pcs),pvars,cumsum_pvars)[1:nres,]
  names(res) <- c("PC","Proportion of Variance (%)","Cumulative Proportion of Variance (%)")
  return(list(tb=res,pc=pc))
}
# The pcaplot_func creates plots for pc1 and pc2
pcaplot_func <- function(pc, group_var,legend) { # group_var: column name for a specific group; legend: legend name
  group=pData(raw.data)[which(row.names(pData(raw.data))%in%row.names(pc)),group_var]
  df <- data.frame(
    PC1=pc$PC1,
    PC2=pc$PC2,
    group=group
  )
  i=length(levels(group))
  group_col <- colours[1:i]
  names(group_col) <- levels(pData(raw.data)[,group_var]) # colour to corresponding group for plot
  ggplot(df,aes(PC1,PC2,color=group)) + geom_point() +
    theme_bw() +
    scale_color_manual(legend,values=group_col,na.value="grey")
}
# The pca_func function generates multiple pca plots for scan date, disease, Response, and Donor
pca_func <- function(pc) {
  group_vars=c("ScanDate_Group", "Response")
  legends=c("ScanDate_Group", "Response")
  idx_exist=c(1:length(group_vars))[group_vars%in%names(pData(raw.data))] # obtain index of existing variables
  plot_list=list() # store plots in a list
  for (i in idx_exist) {
    group_var=group_vars[i]
    legend=legends[i]
    nlevel=nlevels(pData(raw.data)[,group_var]) # levels of the variable
    if (group_var=="ScanDate_Group"|(nlevel>=2&nlevel<=20)) {
      plot_list[[group_var]]=pcaplot_func(pc, group_var=group_var,legend=legend)
    }
  }
  return(plot_list)
}
```


1. Compute PCs and variance explained by the first 10 PCs

```{r pca_tb, eval=T, echo=F, message=F, warning=F, results="asis"}
res_pca <- pcastat_func(raw.data=raw.data)
pandoc.table(res_pca$tb,split.tables=Inf, caption="Variance explained")
```

2. PCA plots

PCA plots are generated using the first two principle components colored by known factors (e.g. Response/disease conditions, tissue, Patients and scan dates), visualizing similarities between arrays and these similarities' correlation to batch effects.

```{r pca_plot, eval=T, echo=F}
plot_list=pca_func(pc=res_pca$pc)
for (i in plot_list) {print(i)}
```


### QC Summary

```{r qcsumm_utility, eval=T, echo=F}
# The outlier_summ_func function outputs a summary table of outlier and the detected frequency
outlier_summ_func <- function() {
  outlier_all <- c("outlier_intensity","outlier_MA","outlier_spatial","outlier_RLE","outlier_NUSE","outlier_dist") # all outliers
  outlier_env=ls(envir=.GlobalEnv, pattern="outlier_") # "outlier_" enviromental variables
  outlier=outlier_env[outlier_env%in%outlier_all]
  method=gsub("outlier_","",outlier)
  outliers=unlist(lapply(1:length(outlier),function(x){get(outlier[x],envir=.GlobalEnv)}))
  if (length(outliers)==0) {
    cat("No outlier was detected\n")
    res <- data.frame() # create an empty data frame
  } else {
    methods=unlist(lapply(1:length(outlier),function(x){n=length(get(outlier[x]));rep(method[x],n)}))
    outlier_list=list()
    for (x in 1:length(outliers)){outlier=outliers[x];method=methods[x];outlier_list[[outlier]]=append(outlier_list[[outlier]],method)}
    # summary table
    Frequency <- sapply(outlier_list,length) # times to detect
    Method <- unlist(lapply(names(outlier_list),function(x){paste0(outlier_list[[x]],collapse=", ")}))
    res <- data.frame(Frequency,Method)
    res <- res[order(res$Frequency),]
  }
  return(res)
}

# The tbQC_func function
tbQC_func <- function(outliers) { # define outliers
  tb=pData(raw.data)
  tb$QC_Pass=1
  if (missing(outliers)) { # if outliers are not defined, use those detected more than twice
    tb$QC_Pass[rownames(tb)%in%rownames(outlier_tb)[outlier_tb$Frequency>2]]<-0 # assign 0 to outliers detected more than twice
  } else {
    tb$QC_Pass[rownames(tb)%in%outliers]<-0
  }
  if (GPL_ID=="GPL15207") {tb$Filename <- rownames(pData(gse))} else {tb$Filename <- rownames(tb)} # add filename in a new column
  # save in a new phenotype file
  write.table(tb,pheno_fn_withQC,col.names=T,row.names=F,sep="\t",quote=F)
  # defined outliers
  outlier=as.character(tb$GEO_ID)[which(tb$QC_Pass==0)]
  # summary of phenotype information before QC
  vars=c("Tissue","Response","Disease","QC") # variables of interest
  # before QC
  tb_withoutQC=as.data.frame(table(tb[,names(tb)%in%vars]))
  names(tb_withoutQC)[ncol(tb_withoutQC)]="Counts"
  # after QC
  tb_withQC=as.data.frame(table(tb[which(tb$QC==1),names(tb)%in%vars]))
  names(tb_withQC)[ncol(tb_withQC)]="Counts"
  return(list(outlier=outlier, tb_withoutQC=tb_withoutQC[which(tb_withoutQC$Count>0),], tb_withQC=tb_withQC[which(tb_withQC$Count>0),]))
}
```

The summary of outliers and detection methods

```{r outliersum, eval=T, echo=F, results="asis"}
outlier_tb=outlier_summ_func()
pandoc.table(outlier_tb,caption="Outlier Summary",split.tables=Inf)
```

Create a new column "QC_Pass" in the phenotype file. By default, samples detected as an outlier more than twice are assigned to 0 otherwise to 1.

```{r qcsumm1, eval=T, echo=F}
res_tbQC=tbQC_func()
outlier=res_tbQC$outlier
cat(length(outlier), "outlier(s) are defined.\n")
```

```{r qcsumm2, eval=T, echo=F, results="hide"}
pandoc.table(res_tbQC$tb_withoutQC, split.tables=Inf, caption="Summary of samples without QC")
if (length(outlier)==0) {
  cat("All samples passed QC\n")
} else {
  pandoc.table(res_tbQC$tb_withQC, split.tables=Inf, caption="Summary of samples with QC")
}
```

### Results
Describe your results and include relevant tables, plots, and code/comments used to obtain them. End with a brief conclusion of your findings related to the question you set out to address. You can include references if you'd like, but this is not required.

QC identified no significant outlier samples that needed to be discarded. Description of the analysis findings will precede figures and tables below.

***

This report shows the differential analysis for gene expression microarry data from GEO study, including:

* Raw probe intensity normalization
* Differential expression
* Adjusting for batch effect

Outputs:

* Gene differential expression result file(s) (.csv)
* A gene expression analysis report (.html)

Mannually assign variables used in the RAVED pipeline

```{r, results_var, eval=T, echo=T}

tissue="Tumor" # naming is rigid, should be same as the Tissue defined in QC
# reference condition
con0="Nonresponder" # naming is rigid, should be same as the Response defined in QC
# altered condition
con1="Responder" # naming is rigid, should be same as the Response defined in QC
# Response. Assign "comparison" if this column is used for DE.
Response=c(con0,con1)
# disease. Assign "comparison" if this column is used for DE.
disease="Rectal_cancer"

pheno_fn=paste0(resdir,"/",geo_id,"_Phenotype_withQC.txt")

```

## Obtain Phenotype and GEO Data

### Phenotype data preparation

```{r pheno_utility, eval=T, echo=F}
# The phenosub_func function subsets phenotypes based on the user defined variables
phenosub_func <- function(){
  if (!all(tissue%in%pheno$Tissue)) {stop("Assigned tissue varialbes are not included in the Tissue column")}
  if (!all(Response%in%pheno$Response)) {stop("Assigned Response variables are not included in the Response column")}
  if  (!all(disease%in%pheno$Disease)) {stop("Assigned disease variables are not included in the Disease column")}
  pheno.sub=subset(pheno,(Tissue%in%tissue)&(Response%in%Response)&(Disease%in%disease))
  pheno.sub=droplevels(pheno.sub)
  # assign comparison to "Status" column
  if (identical(sort(levels(pheno.sub$Response)),sort(c(con0,con1)))) {
      pheno.sub$Status=pheno.sub$Response
  }
  if (identical(sort(levels(pheno.sub$Disease)),sort(c(con0,con1)))) {
      pheno.sub$Status=pheno.sub$Disease
  }
  pheno.sub$Status <-factor(pheno.sub$Status,levels=c(con0,con1))
  return(pheno.sub)
}
# The phenoqc_func function excludes outliers from phenotype file 
phenoqc_func <- function(outlier,pheno) {
  if (missing(outlier)) {pheno=subset(pheno, QC_Pass==1)} else {pheno=subset(pheno, Filename%in%outlier)}
  droplevels(pheno)
}
# The phenopair_func function excludes unpaired donor from analysis
phenopair_func <- function(dat) {
  unpaired_samp=names(which(table(dat$Donor)==1))
  dat=dat[which(!dat$Donor%in%unpaired_samp),]
  droplevels(pheno)
  if (length(unpaired_samp)>0) {
    cat(paste0(length(unpaired_samp)," sample(s) with unpaired donor are excluded from analysis\n"))
    cat(paste(unpaired_samp,collapse=", "),"\n")
  }
  return(dat)
}
# The tbsum_func function generates summary of variables of interest
tbsum_func <- function(tb) {
  vars=c("Status", "ScanDate_Group") # variables of interest
  tb=as.data.frame(table(droplevels(tb[,names(tb)%in%vars])))
  names(tb)[ncol(tb)]="Counts"
  return(tb)
}
# The infosumm_function generates summary of the comparison
infosumm_func <- function(pheno) {
  N_Condition0 <- sum(pheno$Status==con0) # count number of samples under condition 0
  N_Condition1 <- sum(pheno$Status==con1) # count number of samples under condition 1
  if (identical(sort(levels(pheno$Response)),sort(c(con0,con1)))) {
    App="Response"
    disease=paste(disease,collapse="_")
    if (geo_GPL=="") {name=paste(geo_id,tissue,disease,con1,"vs",con0, sep="_")} else {{name=paste(geo_id,geo_GPL,tissue,disease,con1,"vs",con0, sep="_")}}
    Disease=disease
    Response=con1
  } else {
    App="Disease"
    Response=paste(Response,collapse="_")
    if (geo_GPL=="") {name=paste(geo_id,tissue,Response,con1,"vs",con0, sep="_")} else {name=paste(geo_id,geo_GPL,tissue,Response,con1,"vs",con0, sep="_")}
    Disease=con1
    Response=Response
  }
  
  df <- data.frame(
    GEO_ID=geo_id,
    Tissue=tissue,
    App=App,
    Disease=Disease,
    Response=Response,
    N_Condition0=N_Condition0,
    N_Condition1=N_Condition1,
    Total=N_Condition0+N_Condition1,
    Unique_ID=name
  )
  return(list(df=df,name=name))
}
```

Read in pre-prepared post-QC phenotype data

```{r pheno_readin, eval=T, echo=F}
pheno <- read.table(pheno_fn, header=TRUE, sep="\t")
```

Subset phenotypes based on the comparison variables. Check variables (before and after QC if outliers are detected).

```{r pheno_sub, eval=T, echo=F}
pheno.sub=phenosub_func()
pheno.of.interest=pheno.sub
```


```{r pheno_sum, eval=T, echo=F, results="asis"}
pandoc.table(tbsum_func(tb=pheno.of.interest), split.tables=Inf, caption="Summary of subsetted samples")
# create a summary table for this comparison
pandoc.table(t(infosumm_func(pheno=pheno.of.interest)$df),split.tables=Inf, caption="Summary of the comparison")
```

Assign colours to status and scan date (if available)

```{r color, eval=T, echo=F}
pheno.of.interest$ScanDate_Group <- factor(pheno.of.interest$ScanDate_Group)

# assign colours to comparison status
colour_status <- c("navy","red")
names(colour_status) <- c(con0,con1) # assign red to condition 1 and navy to condition 2
colour_status_list <- unlist(lapply(pheno.of.interest$Status,function(x){colour_status[x]}))
# assign colours to scan date
colours=c("#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666", "#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#CCEBC5", "#FFED6F") # first 8 colour names derived from Dark2, and last 12 names from Set3

  colour_scandate <- colours[1:4]
  names(colour_scandate) <- levels(pheno.of.interest$ScanDate_Group) # colour to corresponding scan date
  colour_scandate_list <- unlist(lapply(pheno.of.interest$ScanDate_Group,function(x){colour_scandate[x]}))

```

### Gene expression data preparation


Obtain raw.data.of.interest by subsetting raw.data based on the phenotype of interest

```{r sub_rawdata, eval=T, echo=F}
# The subdat_func function subsets data based on the phenotype of interest
subdat_func <- function(raw.data, pheno) {
  # subset raw.data based on the phenotype of interest
  raw.data=raw.data[,colnames(raw.data)%in%pheno$Filename]
  # order phenotype file based on sample order in raw data
  pheno <- do.call(rbind,lapply(colnames(raw.data),function(x)pheno[which(pheno$Filename==x),]))
  # assign phenotype data to raw expression data
  pData(raw.data) <- pheno
  row.names(pData(raw.data)) <- sampleNames(protocolData(raw.data))
  # check if the sample names derived from expression data match those in phenotype file
  if (usesuppl) {matching=mapply(identical,row.names(pData(raw.data)),as.character(pheno$Filename))}
  else {matching=mapply(grepl,row.names(pData(raw.data)),as.character(pheno$Filename))}
  if (!all(matching)) {stop("The sample names derived from expression data do not match those in phenotype file. Please check!")}
  return(raw.data)
}
raw.data.of.interest=subdat_func(raw.data=raw.data, pheno=pheno.of.interest)
```

## Differential Gene Expression Analysis

### Normalize raw gene expression data

Normalize gene expression raw data using robust multi-array average (RMA) method 


If negative/zero intensity values are present, convert them to NAs.

```{r infinite_convert2, eval=T, echo=F, fig.height=10, fig.width=12}
exprs(raw.data.of.interest)=apply(exprs(raw.data.of.interest),2,function(x){replace(x,which(x<=0),NA)})
```

```{r rma, eval=T, echo=F, message=F, results="hide"}

  rma.data.of.interest = rma(raw.data.of.interest)
  cat("RMA normalization is used.\n")

```

```{r rma_plot, eval=T, echo=F}
cols=colour_status_list
boxplot(raw.data.of.interest,target="core",col=cols,main="Raw Probe Intensities",xaxt="n") # view raw data
legend("topright",legend=names(colour_status),fill=colour_status)

boxplot(rma.data.of.interest,col=cols,main="Normalized Probe Intensities",xaxt="n") # view RMA-adjusted data
  legend("topright",legend=names(colour_status),fill=colour_status)

```


### Comparison of Responders vs. Non-Responders

```{r limma_utility, eval=T, echo=F, results="asis"}
limma_func <- function() { # here only con0, con1 are used in comparisons. use a function to reduce the factor levels
  
    # Create a design model matrix for linear model. Fit a linear model using design matrix model.
    design = model.matrix(~ -1+factor(rma.data.of.interest$Status)) # create design model matrix
    colnames(design) = levels(factor(rma.data.of.interest$Status))
  
  fit = lmFit(rma.data.of.interest, design) # fit a linear model to estimate the fold changes and standard error
  # Create a contrast group and fit it in a linear model
  data.contrast = makeContrasts(Response=Responder - Nonresponder, 
                                  levels = design) # create a contrast group by comparing con1 vs con0
  fit2 = contrasts.fit(fit, data.contrast) # get the contrasts for samples of interest
  fit2 = eBayes(fit2) # adjust fit coefficients using an empirical Bayes moderation of standard errors
  return(list(design=design,data.contrast=data.contrast,fit2=fit2))
}
```

Fit a linear model to RMA log-intensity values, fit this model to a contrast matrix for the comparison of interest, and apply empirical Bayes smoothing to obtain more precise standard errors.

```{r limma, eval=T, echo=F, message=F, warning=F, results="asis"}
res_DE=limma_func()
fit2=res_DE$fit2
pandoc.table(data.frame(Sample=colnames(rma.data.of.interest),res_DE$design), split.tables=Inf, caption="A design model matrix for linear model")
pandoc.table(as.data.frame(res_DE$data.contrast), caption="A contract matrix for comparison")
contrast_table <- topTable(fit2, adjust="BH",num=Inf) # get full set of results for each hypothesis test
col.sel=c("logFC","AveExpr","t","P.Value","adj.P.Val","B") # select the columns of DE results
contrast_table <- data.frame(ID=row.names(contrast_table), contrast_table[,col.sel])
```

### Adjusting for Batch Effect

```{r sva_utility, eval=T, echo=F}
# The nbatch_func function obtains number of batches (scan date) in the data
nbatch_func <- function() {
  if (!"ScanDate_Group"%in%names(pData(rma.data.of.interest))) {nbatch=0} else {nbatch=nlevels(rma.data.of.interest$ScanDate_Group)}
}
# The svamod_func function creates full and null models, and Checks if the batch and comparison status are confounded
svamod_func <- function(paired=FALSE) {
  # Create a full model
  modBatch = model.matrix(~factor(rma.data.of.interest$Status)+factor(rma.data.of.interest$ScanDate_Group)) # full model (adjusted variables and variables of interest)
  # Create a null model only including batch variables
  nullBatch =  model.matrix(~factor(rma.data.of.interest$ScanDate_Group)) # null model (adjusted variables only)
  # Check if the scan date and comparison status are confounded
  if (class(try(solve(t(modBatch)%*%modBatch),silent=T))=="matrix") {batchadj=TRUE} else {batchadj=FALSE; message("The scan date and comparison status are highly confounded")}
  # summary of the full model
  tb.fullmod <- as.data.frame(modBatch)
  names(tb.fullmod) <- c("Intercept",levels(rma.data.of.interest$Status)[-1],levels(droplevels(rma.data.of.interest$ScanDate_Group))[-1])
  # summary of the null model
  tb.nullmod <- as.data.frame(nullBatch)
  names(tb.nullmod) <- c("Intercept",levels(droplevels(rma.data.of.interest$ScanDate_Group))[-1])
  donoradj=FALSE # assign variable is donor is adjusted
  tb.nullmod1=NULL # assign null matrix for donor adjustment
  if ((paired)&(batchadj)) { # same donor Response adjust for donor
    # Test if donor and scandate are correlated
    modBatch1 = model.matrix(~factor(rma.data.of.interest$Status)+factor(rma.data.of.interest$ScanDate_Group)+factor(rma.data.of.interest$Donor)) # full model including donor
    nullBatch1 =  model.matrix(~factor(rma.data.of.interest$ScanDate_Group)+factor(rma.data.of.interest$Donor)) # null model including donor
    # summary of the full model
    tb.fullmod1 <- as.data.frame(modBatch1)
    names(tb.fullmod1) <- c("Intercept",levels(rma.data.of.interest$Status)[-1],levels(droplevels(rma.data.of.interest$ScanDate_Group))[-1],levels(droplevels(rma.data.of.interest$Donor))[-1])
    # summary of the null model
    tb.nullmod1 <- as.data.frame(nullBatch1)
    names(tb.nullmod1) <- c("Intercept",levels(droplevels(rma.data.of.interest$ScanDate_Group))[-1],levels(droplevels(rma.data.of.interest$Donor))[-1])
      
    # check if scandate correlated with donor
    if (class(try(solve(t(modBatch1)%*%modBatch1),silent=T))=="matrix") {
      donoradj=TRUE
      modBatch=modBatch1
      nullBatch=nullBatch1
      tb.fullmod=tb.fullmod1
      tb.nullmod=tb.nullmod1
    }
  }
  return(list(modBatch=modBatch, nullBatch=nullBatch, tb.fullmod=tb.fullmod, tb.nullmod=tb.nullmod, batchadj=batchadj, donoradj=donoradj, tb.nullmod_donor=tb.nullmod1))
}
# The batcherror_func function assigns a variable batcherror to decide whether to adjust for batch effect under various scenarios
batcherror_func <- function() {
  if (nbatch==0) {
    batcherror="zero"
  } else if (nbatch==1) {
    batcherror="one"
  } else {
    if (batchadj) { # if scan date is not correlated with status
      if (paired) {if (donoradj) {batcherror="no"} else {batcherror="correlate_donor_scandate"}}
      else {batcherror="no"}}
    else {batcherror="correlate"} # if scan date is correlated with status
    }
  return(batcherror)
}
# The batchadj_func function outputs table with batch effects adjusted p-values
batchadj_func <- function(batcherror=batcherror, contrast_table=contrast_table, paired=paired) {
  if (batcherror=="no") {
    modBatch=svamod_func(paired=paired)$modBatch
    nullBatch=svamod_func(paired=paired)$nullBatch
    pValuesBatch=f.pvalue(exprs(rma.data.of.interest), modBatch, nullBatch) # get batch effect-adjusted p-values
    qValuesBatch=p.adjust(pValuesBatch, method="BH") # get q-values
    tb.sva <- data.frame(ID=names(pValuesBatch),pValuesBatch,qValuesBatch)
    contrast_table <- merge(contrast_table, tb.sva, by="ID", all=TRUE)
  } else { # batcherror=correlate, correlate_donor_scandate, one, zero
    contrast_table$pValuesBatch=contrast_table$qValuesBatch=rep(NA,nrow(contrast_table))
  }
  return(contrast_table)
}
```

Check whether to adjust for scan date and donor. Create a full model that includes all variables and a null model that only includes the batch variable.
**The batch used for adjustment:**

```{r sva_check, eval=T, echo=F}
nbatch=nbatch_func()
if (nbatch>1) {res_svamod=svamod_func(paired=paired);batchadj=res_svamod$batchadj;donoradj=res_svamod$donoradj}
batcherror=batcherror_func()
cat("batcherror =", batcherror)
```

Compute F statistic p-values adjusted for batch effect. Q-values are obtained by the Benjamini-Hochberg method. If the batch and the status are correlated, assign NA to the batch adjusted p- and q-values. If there is no batch variable or only one batch, assign p- and q-values computed by limma to the batch adjusted p-values

```{r sva_tb, eval=T, echo=F, results="asis"}
contrast_table=batchadj_func(batcherror=batcherror, contrast_table=contrast_table, paired=paired)
```

### Assign Official Gene Symbol

Annotate official gene symbol to probes. 

```{r anno_list, eval=T, echo=F}
anno_list=list()
# Affymetrix
anno_list[["pd.hg.focus"]]="hgfocus.db"
anno_list[["pd.hg.u133a"]]="hgu133a.db"
anno_list[["pd.hg.u95av2"]]="hgu95av2.db"
anno_list[["pd.ht.hg.u133.plus.pm"]]= "hgu133plus2.db"
anno_list[["pd.hta.2.0"]]="hta20transcriptcluster.db"
anno_list[["GPL96"]]="hgu133plus2.db"
anno_list[["GPL571"]]="hgu133a2.db"
anno_list[["pd.hg.u133a.2"]]="hgu133a2.db"
anno_list[["pd.hg.u133.plus.2"]]="hgu133plus2.db"
anno_list[["pd.hugene.1.0.st.v1"]]="hugene10sttranscriptcluster.db"
anno_list[["pd.hugene.2.0.st.v1"]]="hugene20sttranscriptcluster.db"
anno_list[["GPL8300"]]="hgu95av2.db"
# Agilent
anno_list[["GPL6480"]]="hgug4112a.db"
# Illumina
anno_list[["GPL6947"]]="illuminaHumanv3.db"
anno_list[["GPL10558"]]="illuminaHumanv4.db"
anno_list[["GPL6101"]]="illuminaRatv1.db" # rat
```


```{r symbol_list, eval=T, echo=F}
symbol_list=list()
# Affymetrix
symbol_list[["GPL15207"]]="Gene Symbol" # PrimeView
# Agilent
symbol_list[["GPL17077"]]="GENE_SYMBOL" # Agilent-039494 SurePrint G3 Human GE v2 8x60K Microarray 039381
symbol_list[["GPL4133"]]="GENE_SYMBOL" # Agilent-014850 Whole Human Genome Microarray 4x44K G4112
symbol_list[["GPL19462"]]="ID" #The official version of this platform is accession number GPL6885. This version includes ILMN_SYMBOL values in the ID column.
symbol_list[["GPL1355"]]="Gene Symbol"
```

```{r glpanno_func, echo=F}
# glpanno_func creates anntoation vector based on GPL annotation from GEO
glpanno_func <- function(GPL_ID){
  gpl <- Table(getGEO(GPL_ID, destdir=datadir))
  if (GPL_ID%in%names(symbol_list)) {
    symbol_col <- symbol_list[[GPL_ID]]
    # set NA for gene symbols of the probes with more than one genes mapped
    gpl[,symbol_col][which(grepl("///",gpl[,symbol_col]))] <- NA # GPL15207
    anno_vect <- gpl[,symbol_col]
  } else {stop("Find out gene symbol column name here: ","https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=",GPL_ID," \nDefine it in symbol_list.")}
  names(anno_vect) <- gpl[,"ID"]
  return(anno_vect)
}
# ranno_func creates anntoation vector based on R annotation database
ranno_func <- function(anno_lib){
  # check if the annotation database is installed
  if (!anno_lib%in%installed.packages()[,1]){source("http://bioconductor.org/biocLite.R"); biocLite(anno_lib)}
  library(anno_lib, character.only=T)
  anno_symbol=gsub(".db","SYMBOL",anno_lib) # The name of the R object mapping between probe id and gene symbol
  x=get(anno_symbol)
  # Get the probe identifiers that are mapped to a gene symbol
  mapped_probes <- mappedkeys(x)
  # Convert to a list
  xx <- as.list(x[mapped_probes])
  # Convert list to annotation vector
  anno_vect <- sapply(xx,function(x){x})
  return(anno_vect)
}
# geneannot_func annotates gene symbol to DE result table
geneannot_func <- function(tb, anno_vect) {
  remove.pm <- function(x) {gsub("_PM", "", x)} # Assign official gene symbol using hgu133plus2.db package if anntoation is based on pd.hg.u133.plus.2. Note that the probe names have additional "PM"s in the results will be removed to match the names in the gene symbol package.
  if (exists("anno_lib")) {
    if (anno_lib=="hgu133plus2.db") {tb$ID=sapply(as.character(tb$ID), remove.pm)}
  }
  tb$ID=as.character(tb$ID)
  tb$SYMBOL=sapply(as.character(tb$ID), function(x){if (x%in%names(anno_vect)){anno_vect[x]} else {"NA"}})
  tb$SYMBOL[which(tb$SYMBOL=="")]="NA"
  # remove probes with NA in logFC column
  tb <- tb[!is.na(tb$logFC),]
  tb[order(tb$P.Value),]
}
```

```{r anno_utility, eval=T, echo=F, warning=F, message=F}
# install corresponding annotation database if it is not installed
anno_array=annotation(rma.data.of.interest)
cat("The platform used is", anno_array, "\n")

  anno_lib=anno_list[[anno_array]] # use the annotation database
  cat("The corresponding R annotation database package is", anno_lib,"\n")
  anno_vect <- ranno_func(anno_lib=anno_lib)

```

```{r contrast_fn, eval=T, echo=F}
contrast_name=infosumm_func(pheno=pheno.of.interest)$name # adopt Unique_ID created in the information summary table
contrast_fn=paste0(resdir,"/", contrast_name, ".csv")
```

```{r DE_readin, eval=T, echo=F}
if (file.exists(contrast_fn)) {res=read.csv(contrast_fn)
res_gsea=res
} else if (!file.exists(contrast_fn)){
  res <- geneannot_func(tb=contrast_table, anno_vect=anno_vect)
  write.csv(res, file=contrast_fn, row.names = FALSE)
  res_gsea=res
}
```

## Gene Expression Results Visualization

### Volcano Plots

```{r vol_utility, eval=T, echo=F}
# The volplot_func function generates volcano plots
volplot_func <- function(df,qval_column,title) {
  # get qvalue column
  qval <- df[,qval_column]
  if (!all(is.na(qval))) {          
    df <- df[!is.na(qval),] # remove NA values
    qval <- df[,qval_column]
    if (min(df[,qval_column])>=0.05) {
      df$sig <- "black" # assign colors to DE and non-DE genes
    } else {
      # assign colors to DE and non-DE genes
      df$sig <- rep(NA,nrow(df))
      df$sig[qval<0.05] <- "red"
      df$sig[qval>=0.05] <- "black"
    }
    df$sig <- as.factor(df$sig)
    color <- levels(df$sig)
    # log10 transformed q values
    df$logqval <- -log10(qval)
    diffgenes <- df$ID[qval<0.05] #Create list of all DEG's
    signum = paste0(length(diffgenes), " significant genes based on ", qval_column)
    if (missing(title)) {title=signum}
    print(
    ggplot(df, aes(x = logFC, y = logqval, color=sig)) + geom_point(size=0.5) +
      theme_bw() +
      labs(title=title,x="logFC",y=paste0("-log10(",qval_column,")")) +
      scale_color_manual(values=color) +
      theme(legend.position="none")
    )
  }
}
```

The differential expression analysis showed no significant genes associated with response to chemoradiation as displayed in the volcano plots, histograms, and heatmaps.

```{r vol, eval=T, echo=F, fig.height=4, fig.width=4.5}
for (qval in c("adj.P.Val","qValuesBatch")) {volplot_func(res, qval)}
```


### Histograms

```{r hist_utility, eval=T, echo=F}
# The histplot_func function generates histogram for p-value distributions
histplot_func <- function(df,qval_column,title) {
  if (missing(title)) {title=""}
  # get qvalue column
  qval <- df[,qval_column]
  if (!all(is.na(qval))) {hist(qval,main=title,xlab=qval_column)}
}
```

Histograms of p-value distributions

```{r histplot, eval=T, echo=F, fig.width=4.5, fig.height=4}
for (pval in c("P.Value","pValuesBatch")) {histplot_func(res, pval)}
for (qval in c("adj.P.Val","qValuesBatch")) {histplot_func(res, qval)}
```

### Top 200 Differentially Expression Results

```{r filter_blank_probes}
res=res[!is.na(res$SYMBOL),]
```

```{r top200_utility, eval=T, echo=F}
# The datreform_func function reformats the DE table
datreform_func <- function(dt,topnum=200) {
  dt=dt[order(dt$P.Value),]
  dt=dt[1:topnum,]
  round2 <- function(x){round(x,2)}
  dt[,c("logFC","AveExpr","t","B")] <- sapply(dt[,c("logFC","AveExpr","t","B")],round2)
  sciform <- function(x){format(x,scientific=TRUE,digits =2)}
  dt[,c("P.Value","adj.P.Val","pValuesBatch","qValuesBatch")] <- sapply(dt[,c("P.Value","adj.P.Val","pValuesBatch","qValuesBatch")],sciform)
  dt
}
```

Show top 200 probes sorted by un-adjusted p-values

```{r top50, eval=T, echo=F, message=F, warning=F, results="asis"}
res <- datreform_func(dt=res)
rownames(res) <- NULL
#pandoc.table(res[1:20,],split.tables=Inf)
DT::datatable(res[1:200,],rownames=FALSE, options = list(columnDefs = list(list(className = 'dt-center', targets = "_all"))))
```

### Boxplots for Top 6 Differentially Expressed Genes

The boxplots for the top differentially expressed genes do show differential expression but after adjustment of the p values none of these were significant.

```{r boxplot_utility, eval=T, echo=F}
# function for top gene boxplot
topgene_boxplot_func <- function(tb,colour,comp) { # comp: comparison status
  for (i in 1:nrow(tb)) {# top i probe in res
    if (missing(comp)) {comp=""}
    if (missing(colour)) {colour=colours[1]}
    probe_top <- tb$ID[i]
    gene_top <- tb$SYMBOL[i]
    row.names(rma.data.of.interest) <- gsub("_PM","",row.names(rma.data.of.interest))
    values=exprs(rma.data.of.interest)[row.names(rma.data.of.interest)%in%probe_top, ]
    status=rma.data.of.interest$Status
    df <- data.frame(values=values,status=status)
    title=paste0(comp," top ",i," probe ", probe_top, " gene ", gene_top)
    print(
      ggplot(df,aes(x=status,y=values)) +
        geom_boxplot(outlier.colour=NA,color="grey18",fill=colour) +
        stat_boxplot(geom ='errorbar', color="grey18") +
        geom_jitter(size=1,position = position_jitter(width=0.3)) +
        labs(title=title) +
        theme_bw() +
        theme(legend.position="none",axis.title=element_blank())
    )
  }
}
```

```{r boxplot, eval=T, echo=F, message=F, warning=F, fig.height=4, fig.width=4}
topgene_boxplot_func(tb=res[1:6,])
```


### Heatmap for Top 200 Differentially Expressed Genes based on normalized raw data

Create plotting function
```{r heatmap_utility2, eval=T, echo=F}
# The heatmap_topgene_func function for top gene heatmap plots
heatmap_topgene_func <- function(tb, topnum=200, colour_status_list, colour_status, main="") { # colour_status_list: color assigned to each sample; colour_status: colour vector for the legend plot
  if (anno_lib=="hgu133plus2.db") { # remove "_PM" from probe name
    remove.pm <- function(x) {gsub("_PM", "", x)}
    top.rma <- rma.data.of.interest[remove.pm(row.names(rma.data.of.interest))%in%tb[1:topnum,"ID"],] # plot heatmap for top 200 genes after removing "PM" from probe names
  } else {
    top.rma <- rma.data.of.interest[row.names(rma.data.of.interest)%in%tb[1:topnum,"ID"],] # plot heatmap for top 200 genes
  }
  array_name <- shortname_func(colnames(exprs(top.rma))) # shorten the sample id
  heatmap.2(na.omit(exprs(top.rma)), col=viridis(256, option="B"),
    ColSideColors=colour_status_list, # use predefined colour_status_list, assign colors to status
    labCol=array_name,labRow = "", # take out gene probe id
    trace="none",
    margins=c(12,20), # (bottom margin, left margin)
    cexRow=1,cexCol=1,
    keysize=1.5,key.title=NA,key.xlab="Gene Expression Values",key.ylab="Counts",
    main=main)
  legend("bottomleft",legend=names(colour_status),fill=colour_status,cex=0.8) # use predifined colour_status
}
```

Phylogeny of genes by Response. This shows that the top 200 genes do not show striking clustering according to response to chemoradiation.
```{r heatmap1, eval=T, echo=F, fig.height=10, fig.width=12}
heatmap_topgene_func(tb=res, topnum=200, colour_status_list=colour_status_list, colour_status=colour_status, main="Gene expression heatmap by comparison status")
```


Phylogeny of genes by Scan year further confirms that no significant batch effect was present.
```{r heatmap2, eval=T, echo=F, fig.height=10, fig.width=12}
  heatmap_topgene_func(tb=res, topnum=200, colour_status_list=colour_scandate_list, colour_status=colour_scandate, main="Gene expression heatmap by scan date")

```

### Heatmap for Top 200 Differentially Expressed Genes based on matrix data
Having created heatmaps using the normalized raw data, I wanted to create one based on the "matrix" data uploaded by the study authors (which is already normalized)

Fit a model using matrix data

```{r}
#fit with matrix data
design.gse <- model.matrix(~ -1 + factor(gse$Response))
colnames(design.gse) <- levels(factor(gse$Response))

#Fit a linear model with limma package. Expression data linked to outcome of a design matrix model
fit.gse <- lmFit(gse, design.gse)
#Create contrast groups of interest
gse.contrast <- makeContrasts(Response=Responder - Nonresponder, 
                                  levels = design.gse)
#Get the contrasts for samples of interest
fit.gse2 <- contrasts.fit(fit.gse, gse.contrast)
#Adjust fit coefficients using an empirical Bayes moderation of standard errors
fit.gse2 <- eBayes(fit.gse2)

#Results for each hypothesis test can be extracted using
treatment_results_matrix <- topTable(fit.gse2, coef = "Response", adjust = "BH", num = 200)
col.sel=c("logFC","AveExpr","t","P.Value","adj.P.Val","B","Gene.Symbol") # select the columns of DE results
treatment_results_matrix<-treatment_results_matrix[treatment_results_matrix$Gene.Symbol!='',]
head(treatment_results_matrix[,col.sel])
```

A heatmap using the authors' uploaded normalized data shows almost perfect clustering according to radiation response. It is difficult to tell from their methods how exactly they normalized their data. This further confirms the utility of having raw data available to perform a high quality re-analysis.

```{r heatmap_utility, eval=T, echo=F}
#heat plot with matrix data
library(gplots)
top.eset <- gse[row.names(exprs(gse)) %in% row.names(treatment_results_matrix)]
status.colors <- unlist(lapply(gse$Response, function(x){if (x == "Responder") "navy" else "red"}))
heatmap.2(exprs(top.eset), col = viridis(256, option = "B"),
          trace = "none", keysize = 1.5, key.title = NA,
          ColSideColors = status.colors)
legend("bottomleft", legend = c("Responder", "Non-responder"), fill = c("navy","red")) 
```


### Principal Component Analysis (PCA) based on normalized raw data

```{r pca_utility2, eval=T, echo=F, warning=F, message=F, results="asis"}
# The pcastat_func function computes principal components
pcastat_func <- function(m) {
  # obtain original expression data
  raw.data.pca <- na.omit(apply(m,2,function(x)replace(x,is.infinite(x),NA))) # replace infinite values to NAs and omit NAs
  # As scale function divides by the variance, the probe with the expression sd=0 across samples must be removed.
  sd <- apply(raw.data.pca,1,sd)
  raw.data.pca <- raw.data.pca[!sd==0,]
  # compute pcs
  pca <- prcomp(t(raw.data.pca), retx = TRUE, center = TRUE, scale = TRUE)
  pc <- data.frame(pca$x)
  # compute variance explained by each PC
  vars <- pca$sdev^2
  pcs <- t(pc)
  pvars <- vars*100.0/sum(vars) # proportion of variance (%) explained by each PC
  cumsum_pvars <- cumsum(pvars) # Cumulative Proportion of Variance (%)
  if (nrow(pcs)>10) {nres <- 10} else {nres=nrow(pcs)} # select top 10 PCs if number of PCs >10
  res <- data.frame(rownames(pcs),pvars,cumsum_pvars)[1:nres,]
  names(res) <- c("PC","Proportion of Variance (%)","Cumulative Proportion of Variance (%)")
  return(list(tb=res,pc=pc))
}
# The pcaplot_func creates plots for pc1 and pc2
pcaplot_func <- function(oligo.data, pc, group_var, legend) { # group_var: column name for a specific group; legend: legend name
  df <- data.frame(
    PC1=pc$PC1,
    PC2=pc$PC2,
    group=pData(oligo.data)[,group_var]
  )
  i=length(levels(pData(oligo.data)[,group_var]))
  group_col <- colours[1:i]
  names(group_col) <- levels(pData(oligo.data)[,group_var]) # colour to corresponding group for plot
  ggplot(df,aes(PC1,PC2,color=group)) + geom_point() +
    theme_bw() +
    scale_color_manual(legend,values=group_col,na.value="grey")
}
# The pca_func function generates multiple pca plots for scan date, disease, Response, and Donor
pca_func <- function(oligo.data, pc) {
  group_vars=c("ScanDate_Group", "Status", "Donor")
  legends=c("ScanDate_Group", "Status", "Donor")
  idx_exist=c(1:length(group_vars))[group_vars%in%names(pData(oligo.data))] # obtain index of existing variables
  plot_list=list() # store plots in a list
  for (i in idx_exist) {
    group_var=group_vars[i]
    legend=legends[i]
    pData(oligo.data)[,group_var]=as.factor(as.character(pData(oligo.data)[,group_var])) # convert to factor
    nlevel=nlevels(pData(oligo.data)[,group_var]) # levels of the variable
    if (group_var=="ScanDate_Group"|(nlevel>=2&nlevel<=10)) {
      if (group_var=="Status") {
        plot_list[[group_var]]=pcaplot_func(oligo.data=oligo.data, pc=pc, group_var=group_var,legend=legend)+scale_color_manual(legend,values=colour_status,na.value="grey") # assign colour to comparison stauts
      } else {plot_list[[group_var]]=pcaplot_func(oligo.data=oligo.data, pc=pc, group_var=group_var,legend=legend)}
    }
  }
  return(plot_list)
}
```

1. Compute PCs and variance explained by the first 10 PCs

```{r pca_tb2, eval=T, echo=F, warning=F, message=F, results="asis"}
res_pca <- pcastat_func(m=exprs(rma.data.of.interest))
pandoc.table(res_pca$tb, split.tables=Inf, caption="Variance explained")
```

2. PCA plots

PCA plots are generated using the first two principle components. The plot shows no significant clustering according to Response to chemoradiation.

```{r pca_plot2, eval=T, echo=F, message=F, warning=F}
plot_list=pca_func(oligo.data=rma.data.of.interest, pc=res_pca$pc)
for (i in plot_list) {print(i)}
```

### Principal Component Analysis (PCA) based on matrix data

Similar to the heatmaps, I wanted to plot a PCA based on the authors' normalized data to compare it to my analysis of the normalized raw data.

1. Compute PCs and variance explained by the first 10 PCs

```{r pca_tb3, eval=T, echo=F, warning=F, message=F, results="asis"}
res_matrix_pca <- pcastat_func(m=exprs(gse))
pandoc.table(res_matrix_pca$tb, split.tables=Inf, caption="Variance explained")
```

2. PCA plots

PCA plots are generated using the first two principle components. Similar to the PCA of the normalized raw data, these do not show significant clustering. However this is in contrast to the heiarchical clustering and perhaps reflects the different methodology these techniques use to identify clusters.

```{r pca_plot3, eval=T, echo=F, message=F, warning=F}
plot_list=pca_func(oligo.data=gse, pc=res_matrix_pca$pc)
for (i in plot_list) {print(i)}
```


###Gene Set Enrichment Analysis (GSEA)

The previous analyses examined the significance of individual genes. GSEA examines entire pathways and results in enrichment scores that suggest whether a pathway is upregulated, down-regulated, or not differentially expressed. Based on my subject matter knowledge of radiation oncology, before this analysis I hypothesized that I would see over-expression of cell cycle pathways and down-regulation of DNA double strand break repair in the Responding patients compared to non-responding. This is because radiotherapy exerts its anti-cancer effect partially through DNA double strand breaks, and impaired ability to repair these breaks could lead to more cell kill.  It is also known that cells actively going through the cell cycle are much more radiosensitive than cells that are quiescent. 

Load packages and import differential expression analysis data set generated earlier
```{r}

library(fgsea)
library(ggplot2)
library(dplyr)
library(pander)

dir="C:/Users/jahan/Documents/BMIN503_Final_Project/fgsea/"


res_gsea=read.csv("C:/Users/jahan/Desktop/GSE35452/GSE35452_Tumor_Rectal_cancer_Responder_vs_Nonresponder.csv")

res_modi <- res_gsea %>%
  dplyr::mutate(adj.P.Val=P.Value, Gene=SYMBOL) %>%
  dplyr::filter(!is.na(Gene)) %>% # remove probes cannot be mapped to genes
  dplyr::filter(!is.na(P.Value)) %>% # remove probes with NA p.value
  dplyr::arrange(Gene, P.Value,-abs(logFC)) %>% # order by gene name, p value and descending absolute logFC values
  dplyr::group_by(Gene) %>% # group by gene name
  dplyr::filter(row_number()==1) %>% # select first row in each gene
  dplyr::ungroup() %>%
  dplyr::rename(stat=t) %>% # rename t value to stat
  dplyr::select(Gene,stat) %>% # select column names
  dplyr::arrange(stat) %>%
  as.data.frame()
gene_stat <- res_modi$stat
names(gene_stat) <- res_modi $Gene


pathways.msigkeggreac=readRDS(file=paste0(dir,"/","MSigkeggreactome_list.RDS"))

```

Create FGSEA data set
```{r}
fgsea_res=fgsea(pathways= pathways.msigkeggreac,stats= gene_stat,minSize=15,maxSize=500,nperm=10000,gseaParam=1)
fgsea_res <- fgsea_res[order(-NES),]

collapsedPathways <- collapsePathways(fgseaRes= fgsea_res, pathways= pathways.msigkeggreac, stats= gene_stat, gseaParam=1)
mainPathways = collapsedPathways$mainPathways

fgsea_res$enriched=ifelse(fgsea_res$NES>0,"Up-regulated","Down-regulated")

fgsea_res_collapse=fgsea_res[fgsea_res$pathway %in% mainPathways,]

```

Plot lollipop chart of main Pathways in FGSEA. This shows that cell cycle pathways are indeed up-regulated, but contrary to my hypothesis DNA repair pathways are also up-regulated. After examining these results my interpretation is that DNA repair pathways are up-regulated because the cells in Responding patients are more actively cycling than cells in Nonresponding patients. Thus their tumors are radiosensitive because they are cycling and this is in spite of the fact that they are overexpressing DNA repair pathways. 

Among pathways that are down-regulated, I don't see any that to my knowledge are associated with response to radiotherapy. 

```{r, fig.width=12, fig.height=12}

ggplot(fgsea_res_collapse, aes(x=NES,y=reorder(pathway,NES),color=enriched)) +
        geom_segment(aes(x = 0, y=reorder(pathway,NES), xend = NES, yend = pathway), color = "grey50") +
        geom_point() +xlab("Normalized Enrichment Score") + ylab("REACTOME/KEGG Pathway")
```

Plot enrichment pathways

```{r}

plotEnrichment(pathway = pathways.msigkeggreac[["REACTOME_DNA_DOUBLE_STRAND_BREAK_REPAIR"]], stats = gene_stat) + labs(title="REACTOME_DNA_DOUBLE_STRAND_BREAK_REPAIR")

plotEnrichment(pathway = pathways.msigkeggreac[["REACTOME_DNA_REPLICATION"]], stats = gene_stat) + labs(title="REACTOME_DNA_REPLICATION")

plotEnrichment(pathway = pathways.msigkeggreac[["KEGG_CELL_CYCLE"]], stats = gene_stat) + labs(title="KEGG_CELL_CYCLE")

```

### Conclusion
I analyzed gene expression array data to determine whether any genes were differentially expressed in patients who responded to chemoradiation compared to those who did not respond. I was not able to identify any individual genes that were differentially expressed after adjustment for multiple testing. However on gene set enrichment analysis I identified several pathways that were up-regulated in Responders compared to Non-responders. The up-regulated pathways that were most striking were for cell cycle and DNA repair pathways. Cells that are actively cycling are known to be more radioresponsive.  Cells with deficient DNA repair are also more radiosensitive, and I believe that DNA repair pathways were upregulated in Responders because their tumors were actively cycling and thus required DNA repair machinery to be available. 

#### Session information

```{r sessioninfo, eval=T, echo=F}
pander(sessionInfo())
```
